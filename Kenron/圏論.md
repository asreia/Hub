# 圏論

## 基礎

- **対象**とは、**点**である。圏論の言葉において特に意味はなく、他の概念やモデルによって意味付けをする。
- **射**とは、何らかの対象から対象への方向をもった矢印であり**矢印(射)の繋がり**は、
  合成において**推移律と単位律と結合律**を満たす。その射がどんな**性質**を持っているかを調べるが、射が具体的に何なのかについては言及しない(意味論)
- **圏**とは、**矢印(射)の繋がり**を圏という枠で囲ったもの
  - **矢印**が書ける所に**圏論を適用**できる余地があるかも知れない(矢印と矢印の合成可能性(矢印の合成の九九表))
- **関手**とは、圏の中の**対象と射の繋がり方の構造**を保って他の圏に**マッピング**する(関手で射(関数)を移す: fmap :: (a -> b) -> (f a -> f b))
  - 関手は**文脈(コンテキスト)というモノ**と見ることも出来る
  - 関手がレトラクション？(取り出せる形で含んでいる(F: A -> A×Bとか?))であれば恒等関手と自然同型であり、他のレトラクション関手？とも自然同型な関手が存在する、
    つまり中身と文脈を自由に交換できる？
- **自然変換**とは、関手と関手の間の射を言い、関手のコドメインと関手のコドメインの間の射を全て集めたものを言うが、
  自然変換は**関手(文脈)に作用する**ものなので関手のドメインの具体的な要素に影響しない
- **関手圏**とは、対象を**関手**、射を**自然変換**とする圏で**Cat(圏の圏)の指数対象**でもある
  - 文脈から他の文脈に変換する圏
- **随伴**とは、**2つの圏の射の対応関係**(自然同型)を互いに関手することで表す
- **同型**とは、A-(f)-> B、A <-(f')- B である時、f'○f = id、f○f' = id になる時、fは同型射f'をその逆射と言う
  - 同型ならば圏論の言葉で区別できない
- **普遍性**とは、定義したい**対象とその射が普遍**である事を示すために、任意の対象をXとし、Xからの射:fを、定義したい射とXからの射:u(普遍射)の合成により、射:fを**一意的に分解**(普遍射が唯一定まる)すると言う性質のこと
- **指数対象**とは、Hom集合をその**圏の中に埋め込む**(InternalHomSet)もので、その関数の集合に**構造を入れる**(関数空間,point wise)と、それもその**圏の対象にできる**
  - Hom_c(A,B)はSetsの対象だが、B^AはCの対象になる。(SetsではHom(A,B) == B^A(構造が無い))
  - [指数対象](https://youtu.be/gmVxVp2oLCw?list=PLzJWjr7AvxH37O6GPqx20NpF0HaSrndVc&t=222)
- **デカルト閉圏**とは、**任意の積**と**任意の指数対象**が存在する事。そして**任意の余積**が存在するならば**分配的**である
  - これによって**代数的データ型**(直積,直和)と、それを適用する**関数**(射(指数対象))を圏の対象にできる
    - Haskell: 積:(a,b) == a*b, 余積:Either a b == a+b, 射: a -> b == b^a
    例: ((a,b) -> c) -> a -> b -> c
- **Curry-Howard-Lambek対応**とは、証明できない型は書けない。直積:(a,b)をa∧b, 直和: Either a bをa∨b, 射: a -> bをa⇒b に対応させる。
  - 多相変数は全ての型(Int,String,Bool,Maybe a..)の意味?`∀a == Γ`みたいな
- **モナド**とは、
ある**型**(関手,文脈):**T** と、T型で二重(T^2)以上にラップされた型を**アンラップ**する関数(T^2->T,自然変換):**μ**(join) と、T型で**ラップ**する関数(I->T自然変換):**η**(return)
これら3つを合わせて**自己関手の圏におけるモノイド対象(モナド)**と言う。[プログラマのためのモナド入門](https://www.youtube.com/watch?v=fhuAlDPgi2Q)
プログラミングの文脈では**メソッドチェーン**の様なもの({.Func()}=={>>= KFunc}(**クライスリ射**(a -> m b),{(>>=) :: m a -> (a -> m b) -> m b}), {?.Func()(**Maybeモナド**)})
- [圏論の教え](https://www.youtube.com/watch?v=I8LbkfSSR58&list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_)
- 関手は関手の積付け、自然変換は関手の変換のイメージ..

## 型の圏

- 代数的構造は直和と直積
  - **ポリモーフィズム**を**直和**、**複数のメンバ変数**と**複数の引数**を**直積**、と見ることもできる(ポリモーフィズムの直和は**型チェック**(❰is¦as❱)が必要)
  または、構造体は継承不可なので、メンバ変数の中のEnumで状態で場合分けする(直和)、共用体(Union型)(先頭アドレスのEnumを呼んで値を識別する?)
- 代数的構造データ型 --(射(プログラム(関数)))--> 代数的構造データ型
  - 射(**関数**)を作るのは大変なので、関数を抽象化して**組み合わせる事で簡単**にする
  - 手続き型の場合、関数への**入出力が穴だらけ**なのでその全ての入力と出力を考慮する。
  - 手続き型言語ではデータの生成や変換と言う視点について役立つと思う
  - オブジェクト指向で関数型するには**フィールド**(静的も)(状態)を**持たない**事(順序回路ではなく組み合わせ回路)
    - フィールドメンバの変数に**一つの関数**が利用するだけなら**共有はされない**が**時間的状態**はもつ
    - 状態の更新は**Stateモナド**で考える
  - アクセス指定子が**private**ならその**クラス内の共有**だとわかるが、**public**にしてしまうと**共有の把握が困難**
    - 非共有として**privateな内部クラス**も有効的
  - 関数の中の書き方で、**合成可能性**により、まず、**材料を用意または生成**し変数に束縛する。それから、
  **演算(関数、if文、for文)**して**統合**する。この演算の一般的な方法は**mapとfold**である。Haskellではこれを合成したfoldMapがある。

  - Haskell
    - 関数型には**直和型**(必須という訳ではないが)と**カリー化**があるが、手続き型言語には無いため、関数型の恩恵をダイレクトに取り入れにくい
    - Haskellのコードが簡素なのは、抽象性が非常に高く、副作用を書ける余地が無く(関数は式しか書けないと言うより**関数が式**)、
      - 実装を意識した具体的な処理(ポインタとか)の記述がないから? あと文法がガチガチ
    - Haskellの**プログラム**は**全て展開**すると**一つの式**になっている(純粋関数型)(状態を持たない==参照透過性==時間的に結果が変わらない遅延評価が可能==並列処理に貢献)**Erlang Elixir F#**
    - 引数あり: a(n)=>n+1, a n = n+1, 引数無し: a()=>1, a = 1 と、なりHaskellは関数と定数を区別せず、引数なしは**0個を引数**にとる**定数関数**となる
    - ❰1:2:3:[] == [1,2,3]❱=>True 糖衣構文❰"abc" ==  ['a','b','c']❱=>True 文字列は**Charのリスト([Char])**と同じ
    - 中置記法に❰'❱は使えない
    - **パターマッチ=>ガードの順**で評価し、パターマッチは**上から**マッチし、その中にあるガードも**上から**マッチする。
      - `(a,b,c) = (1,2,3)`パターンマッチで定義することもできる
    - 中置記法の定義(^) :: a -> b -> a;a ^ b = a
    - リストの比較は辞書順
    - 型クラスの関数fがあるとして、そのインスタンスIがありそのIの値をiとするとすると、f i は i.f()の様なもの?(型クラスはインターフェースに似ている)
      - 型クラスの継承関係がある
    - **a,b,c の IO更新関数つくる====================**恐らくIOはプログラム
    - `a -> b -> c -> d`という型は、`a -> (b -> (c -> d))`であり、圏論の指数対象では`a -> (d^c)^b`となり、
      - `a -> (d^(c*b))`,`(d^(c*b))^a`,`d^(c*b)^a`,`d^(c*b*a)`,`(c*b*a) -> d`のような変換ができる(多分)
    - show型クラスのshow関数は値を文字列化する(ToString()のような)、
      - read型クラスのread関数は文字列を値化する(字句解析のような)、`read :: (Read a) => String -> a`
      で出力が`Read a`である事を期待されるため`read "4"`はエラーになり`read "4"::Int`は**出力がInt(Read**のインスタンス)となり通る
        - `read . show $ 1 + 2 :: Int`=>3
    - 型注釈(::Boolなど)は、`$`よりも優先度が低い?
    - Enum型クラスはsuccとpred関数がある。つまり、整数(単位元が無い場合もあるから自然数ではないかな?)
    - whereのスコープは**直前のパターンマッチ**にしか見えていない
    - > Haskellの**モジュール**は、いくつかの**関数や型、型クラス**などを定義したファイルです。Haskellのプログラムはモジュールの集合です。
      - つまり、`ファイル == .hs` でプログラムは `.hs` の集合?
      - **デフォルト**でインポートされているのは**Prelude**(`Prelude>`と同じ)
      - GHCiでインポートする場合は`:m + Data.List ＠⟦～⟧❰Data...❱`,デインポートは`:m - Data.List ＠⟦～⟧❰Data...❱`
      - .hsファイルでインポートする場合は、
        - `import ＠❰qualified❱『名前衝突回避(Data.List.∫LAny∫)』 ｢Data.List｣ ＠❰as ｢L｣❱『名前衝突回避の別名(L.∫LAny∫)』 ＠❰｡❰(｢nub｣, ｢sort｣)❱『特定の関数のみ指定できる』¦❰hiding (｢nub｣)❱『特定の関数を除く』｡❱`
    - 型クラスの値コンストラクタは関数(つまり、**値は関数**)。C#のstructの全てのフィールドが埋まると値を返すイメージ?
    - **型引数**(ジェネリック),**値引数**(メンバ変数),**関数引数**(関数引数) それぞれ**カリー化**でき**型引数以外**は**関数**である
    - **型引数は小文字**から(大抵一文字)、List Int,List m の様に**型**なのか**型引数か多相型**なのか**区別**している
    - 関数を返す関数は実際の計算をしていない
    - a = (x0 (x1 x2) x3 x4) x5 x6 (x7 x8) x9 .. のx~は全て関数と見る事もできる
    - アプリカティブ・スタイル
      - pure (+) <*> Just 3 <*> Just 5 -- 文脈付きのまま計算することができる(C#のNullable型)
    - 型クラスの関数と非型クラスの関数がある。定義済みの非型クラスの関数を型クラスの関数にできない。逆もそう。と言うより単純に同じ関数を2度定義できない。オーバーロード不可
    - Functor(fmap)は`fmap f a`の`f`は**ただの関数**で`a`が**文脈付き**の値で、Applicative(<*>)は`(<*>) f a`の`f`は**文脈付き**の関数で`a`も**文脈付き**の関数である。
    - 型定義(data)は多分型制約できない。関数はできる(型注釈も)。classも出来る(サブクラス化)。instanceはclassで制約しているので無い。
    - 型クラスは型のクラスつまり、型の集まり。とも考えられる。オブジェクト指向では、interfaceが型の集まり?と言うより基底クラスが型の集まり?
    - `(->) r`のモナドはある?
    - 型コンストラクタは(オブジェクトの)関手。例: a -> [a] (リスト関手)。関数(射)の関手はfmap
    - `=<< :: (a -> t b) -> (t a -> t b)` クライスリ射を平坦(文脈付きの射)にするとも見える
      - ====== =<<,fmap,<*>の型を並べる(.),タプル,リスト,$,foldmap,GHCi,GHC,ラムダ式,パターンマッチ,オーバーロード不可,型引数,値引数,関数引数,型と値は大文字,
      - 型コンストラクタはオブジェクトの関手,圏論でfmapやjoinなどで射を変換するプログラム運算,error関数
    - パターンマッチは値コンストラクタにマッチする?
    - [GHCiの基本的な使い方まとめ](https://qiita.com/Izawa_/items/6fc0a7583dc71be48c2a)
    - ラムダ式
      - [ポイントフリースタイル入門](https://melpon.hatenadiary.org/entry/20111031/1320024473)
      - [ポイントフリーコンバータ](http://kar.s206.xrea.com/js/pointfree.html)
      - ラムダ式のスコープは`()`で囲まなければ`\x`から式の終わりまで?そう
      - map \x -> x
          関数アプリケーションで予期しないラムダ式が発生しました。
            \ x -> x
          括弧で囲んで書けばいいのに
          それとも、BlockArgumentsを有効にしたのでしょうか？
        - ~~ラムダ式はラムダ式のスコープが関数の式部分全体で無ければ括弧`()`で囲む事を強制する`(\x -> x)`~~
          ~~スコープが式部分全体であれば括弧はしなくてもいい。つまり`=`の右が`\`から始まる`l = \x -> ~`~~
          ラムダ式のスコープはラムダ式の始まり(`\x`)から式の終わりまでであり、`\a -> ~ \b -> ~ \c -> ~`は`(\a -> ~ (\b -> ~ (\c -> ~)))`と解釈される
          しかし、関数を引数に取る関数`f g = ()`を定義し`\a -> ~ f \b -> ~ f \c -> ~`と定義するとBlockArgumentsエラーになる。(↑括弧の付き方にinfix＠❰l¦r❱が関係してると思ったが関係無かった)
          `\a -> ~ f (\b -> ~ f (\c -> ~))`とすると通る。または↑の状態でBlockArgumentsを有効にすると通る
          中置記法の場合はBlockArgumentsを有効にしなくても通る。
          恐らく、中置記法では無い関数は、関数の右側に複数個引数を取る可能性があるため、**ラムダ式への括弧のつけ忘れか、本当に1つのラムダ式しか取らないか**、分かりづらくなるため?
      - 関数/ラムダ式の引数は、**変数(小文字から始まる,重複不可)** または **値コンストラクタ(大文字から始まる か 記号(中置記法))**(パターンマッチ)(複数、語が並ぶ場合は括弧で囲む必要がある)
        - パターンマッチの値コンストラクタの中を変数にすることもできる(文脈の中の値を変数で扱う)((as pattern)(@)もある) _ も
        - 引数を捨てる事も可能
      - `l = \x x -> ()`はエラーなのに`l = \x -> \x -> ()`は通る謎
        `l = \x x -> ()`は意味のない構文だが`l = \x -> ~ \x -> ()`は`l = \x -> ~ f \x -> ()`とすると`f`は関数を引数にとるため`x`には別々の値が入りうる
        例:`(\u -> u + (\v -> v 1) (\u -> u )) 2`最初のラムダ式の`u`は2が入り最後のラムダ式の`u`には1が入る(キャプチャした最後の`u`上書きしている?)
           `(\u -> u + (\v -> v 1) (\k -> u )) 2`最後のラムダ式の`u`を`k`に変えると最後のラムダ式の`u`は最初のラムダ式`u`をキャプチャする

- Haskellメモ

  - **関数**(変数も)は**小文字**からはじまる
    - データコンストラクタ(型)は大文字から(型定義でa->bとでるのは型変数(ジェネリックな型))
  - パターンマッチは行の**先頭からマッチ**する
  - 中置記法は'(シングルクオート)ではなく **`(バックスラッシュ)**
  - [標準ライブラリのソースコード](https://hackage.haskell.org/package/base)
  - パターンマッチが網羅できない場合は[error :: forall a. HasCallStack => [Char] -> a](https://tnomura9.exblog.jp/28225909/)を使う

  - ターミナル(powershell) [GHCの４つの実行方法](https://haskell.jp/blog/posts/2017/08-ghc-4way-execution.html)
    - `terminal font size`を**14=>24**変更 **====================================================**
    - `x = x + 1`などを実行して無限再帰した場合は`ctrl + C`で`Interrupted.`と出て抜けれる
    - ソースコード(**.hs**)のコンパイルと実行 [Haskellの実行](https://qiita.com/Nipper1357/items/4b4b9d60d8067fcf238c)
      - コンパイル: `ghc ｢ファイルパス.hs｣`(相対パスをコピー)
        - 出力されたexeの実行: `｢ファイルパス｣`
      - **コンパイル&実行**: `runghc ｢ファイルパス.hs｣`
    - `GHCi` で対話型インターフェースが起動する
      - `:q` 終了
      - 複数行入力
        - `:{`,`:}`の間 もしくは `;`で一行で書く
      - **GHCiに任意の関数を読ませたい**場合、**関数をコピー**してGHCiに **:{**を入力&Enterし **Ctrl + V**を押し何も起こらないが、その後右クリックを押すと貼り付けたいですか?と効いてくるのでハイと答えると貼り付けられる。その後 **:}**を入力&Enterを押すとGHCiに関数を読ませる事ができる
        - **確認しないようにした**
      - `GHCi`に`.hsファイル`を**ロードする======================================**
        - `:l ファイルパス.hs`(絶対パス か ghciを起動したパスからの相対パス)でロードできる
          - (`:r`だとリロードらしい)(`Prelude>`が`*Main>`に変わる)(例:`:l ❰C:\python学習メモ\vscode-works_study\git_test\Kenron\haskellTest.hs¦Kenron\haskellTest.hs❱`)
      - Haskell
        - `:t`: 型を調べる
        - `:k`: カインドを調べる
        - `:info` 型、型クラスの情報を調べる
