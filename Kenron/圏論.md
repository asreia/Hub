# 圏論

## 基礎

- **圏**とは、**矢印(射)の繋がり**を表現し、矢印(射)とモノ(対象)の内部に付いては一切求言しない
  - 圏は、射の合成において**推移律と反射率と結合律**を満たす
  - **矢印**が書ける所に**圏論を適用**できる余地があるかも知れない(矢印と矢印の合成可能性)
- **関手**とは、圏の中の**対象と射の繋がり方の構造**を保って他の圏に**マッピング**する(関手で射(関数)を移す: fmap :: (a -> b) -> (f a -> f b))
  - 関手は**文脈(コンテキスト)というモノ**と見ることも出来る
- **自然変換**とは、関手と関手の間の射を言い、関手のコドメインと関手のコドメインの間の射を全て集めたものを言うが、
  自然変換は**関手(文脈)に作用する**ものなので関手の具体的な要素に影響しない
- **関手圏**とは、対象を**関手**、射を**自然変換**とする圏で**Catの指数対象**でもある
  - 文脈から他の文脈に変換する圏
- **随伴**とは、**2つの圏の射の対応関係**(自然同型)を互いに関手することで表す
- **同型**とは、A-(f)-> B、A <-(f')- B である時、f'○f = id、f○f' = id になる時、fは同型射f'をその逆射と言う
  - 同型ならば圏論の言葉で区別できない
- **普遍性**とは、定義したい**対象とその射が普遍**である事を示すために、ある射を、定義したい射と他の射(普遍射)の合成により、ある射を**一意的に分解**(普遍射が唯一定まる)すると言う性質のこと
- **指数対象**とは、Hom集合をその**圏の中に埋め込む**(internalHomSet)もので、その関数の集合に**構造を入れる**(関数空間,point wise)とその**圏の対象にできる**
  - Hom_c(A,B)はSetsの対象だが、B^AはCの対象になる。(SetsではHom(A,B) == B^A(構造が無い))
  - [指数対象](https://youtu.be/gmVxVp2oLCw?list=PLzJWjr7AvxH37O6GPqx20NpF0HaSrndVc&t=222)
- **デカルト閉圏**とは、**任意の積**と**任意の指数対象**が存在する事。そして**任意の余積**が存在するならば**分配的**である
  - これによって**代数的データ型**(直積,直和)と、それを適用する**関数**(射(指数対象))を圏の対象にできる
    - Haskell: 積:(a,b) == a*b, 余積:Either a b == a+b, 射: a -> b == b^a
    例: ((a,b) -> c) -> a -> b -> c
- **Curry-Howard-Lambek対応**とは、証明できない型は書けない。直積:(a,b)をa∧b, 直和: Either a bをa∨b, 射: a -> bをa⇒b に対応させる
- **モナド**とは、
ある**型**(関手,文脈):**T** と、T型で二重(T^2)以上にラップされた型を**アンラップ**する関数(T^2->T,自然変換):**μ**(join) と、T型で**ラップ**する関数(I->T自然変換):**η**(return)
これら3つを合わせて**自己関手の圏におけるモノイド対象(モナド)**と言う。[プログラマのためのモナド入門](https://www.youtube.com/watch?v=fhuAlDPgi2Q)
プログラミングの文脈では**メソッドチェーン**の様なもの({.Func()}=={>>= KFunc}(**クライスリ射**(a -> m b),{(>>=) :: m a -> (a -> m b) -> m b}), {?.Func()(**Maybeモナド**)})
- [圏論の教え](https://www.youtube.com/watch?v=I8LbkfSSR58&list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_)
- 関手は関手の積付け、自然変換は関手の変換のイメージ..

## 型の圏

- 代数的構造は直和と直積
  - **ポリモーフィズム**を**直和**、**複数のメンバ変数**と**複数の引数**を**直積**、と見ることもできる(ポリモーフィズムの直和は**型チェック**(❰is¦as❱)が必要)
  または、構造体は継承不可なので、メンバ変数の中のEnumで状態で場合分けする(直和)、共用体(Union型)(先頭アドレスのEnumを呼んで値を識別する?)
- 代数的構造データ型 --(射(プログラム(関数)))--> 代数的構造データ型
  - 射(**関数**)を作るのは大変なので、関数を抽象化して**組み合わせる事で簡単**にする
  - 手続き型の場合、関数への**入出力が穴だらけ**なのでその全ての入力と出力を考慮する。
  - 手続き型言語ではデータの生成や変換と言う視点について役立つと思う
  - オブジェクト指向で関数型するには**フィールド**(静的も)(状態)を**持たない**事(順序回路ではなく組み合わせ回路)
    - フィールドメンバの変数に**一つの関数**が利用するだけなら**共有はされない**が**時間的状態**はもつ
    - 状態の更新は**Stateモナド**で考える
  - アクセス指定子が**private**ならその**クラス内の共有**だとわかるが、**public**にしてしまうと**共有の把握が困難**
    - 非共有として**privateな内部クラス**も有効的
  - 関数の中の書き方で、**合成可能性**により、まず、**材料を用意または生成**し変数に束縛する。それから、
  **演算(関数、if文、for文)**して**統合**する。この演算の一般的な方法は**mapとfold**である。Haskellではこれを合成したfoldMapがある。

  - Haskell
    - 関数型には**直和型**(必須という訳ではないが)と**カリー化**があるが、手続き型言語には無いため、関数型の恩恵をダイレクトに取り入れにくい
    - Haskellのコードが簡素なのは、抽象性が非常に高く、副作用を書ける余地が無く(関数は式しか書けないと言うより**関数が式**)、
      - 実装を意識した具体的な処理(ポインタとか)の記述がないから? あと文法がガチガチ
    - Haskellの**プログラム**は**全て展開**すると**一つの式**になっている(純粋関数型)(状態を持たない==参照透過性==時間的に結果が変わらない遅延評価が可能==並列処理に貢献)**Erlang Elixir F#**
    - 引数あり: a(n)=>n+1, a n = n+1, 引数無し: a()=>1, a = 1 と、なりHaskellは関数と定数を区別せず、引数なしは**0個を引数**にとる**定数関数**となる
    - ❰1:2:3:[] == [1,2,3]❱=>True 糖衣構文❰"abc" ==  ['a','b','c']❱=>True 文字列は**Charのリスト([Char])**と同じ
    - 中置記法に❰'❱は使えない
    - **パターマッチ=>ガードの順**で評価し、パターマッチは**上から**マッチし、その中にあるガードも**上から**マッチする。
      - `(a,b,c) = (1,2,3)`パターンマッチで定義することもできる
    - 中置記法の定義(^) :: a -> b -> a;a ^ b = a
    - リストの比較は辞書順
    - 型クラスの関数fがあるとして、そのインスタンスIがありそのIの値をiとするとすると、f i は i.f()の様なもの?(型クラスはインターフェースに似ている)
      - 型クラスの継承関係がある
    - **a,b,c の IO更新関数つくる====================**恐らくIOはプログラム
    - `a -> b -> c -> d`という型は、`a -> (b -> (c -> d))`であり、圏論の指数対象では`a -> (d^c)^b`となり、
      - `a -> (d^(c*b))`,`(d^(c*b))^a`,`d^(c*b)^a`,`d^(c*b*a)`,`(c*b*a) -> d`のような変換ができる(多分)
    - show型クラスのshow関数は値を文字列化する(ToString()のような)、
      - read型クラスのread関数は文字列を値化する(字句解析のような)、`read :: (Read a) => String -> a`
      で出力が`Read a`である事を期待されるため`read "4"`はエラーになり`read "4"::Int`は**出力がInt(Read**のインスタンス)となり通る
        - `read . show $ 1 + 2 :: Int`=>3
    - 型注釈(::Boolなど)は、`$`よりも優先度が低い?
    - Enum型クラスはsuccとpred関数がある。つまり、整数(単位元が無い場合もあるから自然数ではないかな?)
    - whereのスコープは**直前のパターンマッチ**にしか見えていない
    - > Haskellの**モジュール**は、いくつかの**関数や型、型クラス**などを定義したファイルです。Haskellのプログラムはモジュールの集合です。
      - つまり、`ファイル == .hs` でプログラムは `.hs` の集合?
      - **デフォルト**でインポートされているのは**Prelude**(`Prelude>`と同じ)
      - GHCiでインポートする場合は`:m + Data.List ＠⟦～⟧❰Data...❱`,デインポートは`:m - Data.List ＠⟦～⟧❰Data...❱`
      - .hsファイルでインポートする場合は、
        - `import ＠❰qualified❱『名前衝突回避(Data.List.∫LAny∫)』 ｢Data.List｣ ＠❰as ｢L｣❱『名前衝突回避の別名(L.∫LAny∫)』 ＠❰｡❰(｢nub｣, ｢sort｣)❱『特定の関数のみ指定できる』¦❰hiding (｢nub｣)❱『特定の関数を除く』｡❱`
    - 型クラスの値コンストラクタは関数(つまり、**値は関数**)。C#のstructの全てのフィールドが埋まると値を返すイメージ?
    - **型引数**(ジェネリック),**値引数**(メンバ変数),**関数引数**(関数引数) それぞれ**カリー化**でき**型引数以外**は**関数**である
    - **型引数は小文字**から(大抵一文字)、List Int,List m の様に**型**なのか**型引数か多相型**なのか**区別**している
    - 関数を返す関数は実際の計算をしていない
    - a = (x0 (x1 x2) x3 x4) x5 x6 (x7 x8) x9 .. のx~は全て関数と見る事もできる
    - アプリカティブ・スタイル
      - pure (+) <*> Just 3 <*> Just 5 -- 文脈付きのまま計算することができる(C#のNullable型)
    - 型クラスの関数と非型クラスの関数がある。定義済みの非型クラスの関数を型クラスの関数にできない。逆もそう。と言うより単純に同じ関数を2度定義できない。オーバーロード不可
    - Functor(fmap)は`fmap f a`の`f`は**ただの関数**で`a`が**文脈付き**の値で、Applicative(<*>)は`(<*>) f a`の`f`は**文脈付き**の関数で`a`も**文脈付き**の関数である。
    - 型定義(data)は多分型制約できない。関数はできる(型注釈も)。classも出来る(サブクラス化)。instanceはclassで制約しているので無い。
    - 型クラスは型のクラスつまり、型の集まり。とも考えられる。オブジェクト指向では、interfaceが型の集まり?と言うより基底クラスが型の集まり?
    - `(->) r`のモナドはある?
    - 型コンストラクタは(オブジェクトの)関手。例: a -> [a] (リスト関手)。関数(射)の関手はfmap
    - `=<< :: (a -> t b) -> (t a -> t b)` クライスリ射を平坦(文脈付きの射)にするとも見える
      - ====== =<<,fmap,<*>の型を並べる(.),タプル,リスト,$,foldmap,GHCi,GHC,ラムダ式,パターンマッチ,オーバーロード不可,型引数,値引数,関数引数,型と値は大文字,
      - 型コンストラクタはオブジェクトの関手,圏論でfmapやjoinなどで射を変換するプログラム運算,error関数
    - パターンマッチは値コンストラクタにマッチする?
    - [GHCiの基本的な使い方まとめ](https://qiita.com/Izawa_/items/6fc0a7583dc71be48c2a)
    - ラムダ式
      - [ポイントフリースタイル入門](https://melpon.hatenadiary.org/entry/20111031/1320024473)
      - [ポイントフリーコンバータ](http://kar.s206.xrea.com/js/pointfree.html)
      - ラムダ式のスコープは`()`で囲まなければ`\x`から式の終わりまで?そう
      - map \x -> x
          関数アプリケーションで予期しないラムダ式が発生しました。
            \ x -> x
          括弧で囲んで書けばいいのに
          それとも、BlockArgumentsを有効にしたのでしょうか？
        - ~~ラムダ式はラムダ式のスコープが関数の式部分全体で無ければ括弧`()`で囲む事を強制する`(\x -> x)`~~
          ~~スコープが式部分全体であれば括弧はしなくてもいい。つまり`=`の右が`\`から始まる`l = \x -> ~`~~
          ラムダ式のスコープはラムダ式の始まり(`\x`)から式の終わりまでであり、`\a -> ~ \b -> ~ \c -> ~`は`(\a -> ~ (\b -> ~ (\c -> ~)))`と解釈される
          しかし、関数を引数に取る関数`f g = ()`を定義し`\a -> ~ f \b -> ~ f \c -> ~`と定義するとBlockArgumentsエラーになる。(↑括弧の付き方にinfix＠❰l¦r❱が関係してると思ったが関係無かった)
          `\a -> ~ f (\b -> ~ f (\c -> ~))`とすると通る。または↑の状態でBlockArgumentsを有効にすると通る
          中置記法の場合はBlockArgumentsを有効にしなくても通る。
          恐らく、中置記法では無い関数は、関数の右側に複数個引数を取る可能性があるため、**ラムダ式への括弧のつけ忘れか、本当に1つのラムダ式しか取らないか**、分かりづらくなるため?
      - 関数/ラムダ式の引数は、**変数(小文字から始まる,重複不可)** または **値コンストラクタ(大文字から始まる か 記号(中置記法))**(パターンマッチ)(複数、語が並ぶ場合は括弧で囲む必要がある)
        - パターンマッチの値コンストラクタの中を変数にすることもできる(文脈の中の値を変数で扱う)((as pattern)(@)もある) _ も
        - 引数を捨てる事も可能
      - `l = \x x -> ()`はエラーなのに`l = \x -> \x -> ()`は通る謎
        `l = \x x -> ()`は意味のない構文だが`l = \x -> ~ \x -> ()`は`l = \x -> ~ f \x -> ()`とすると`f`は関数を引数にとるため`x`には別々の値が入りうる
        例:`(\u -> u + (\v -> v 1) (\u -> u )) 2`最初のラムダ式の`u`は2が入り最後のラムダ式の`u`には1が入る(キャプチャした最後の`u`上書きしている?)
           `(\u -> u + (\v -> v 1) (\k -> u )) 2`最後のラムダ式の`u`を`k`に変えると最後のラムダ式の`u`は最初のラムダ式`u`をキャプチャする
      - **ラムダ式まとめ**
        - 引数は捨てることも可能
        - スコープはラムダ式の始まり **(`\~`)から**(定義している関数本体の)**式の終わり**まで
          - 中置記法では無い**関数にラムダ式を適用**する場合は、ラムダ式に**括弧が必要**(またはBlockArgumentsを有効)(括弧を入れた場合は当然スコープもその括弧内)
        - `\x -> x`のように引数とラムダ式本体に同じ変数が現れる場合は**キャプチャしない**そうで無い場合はキャプチャしている
        - 優先順位(infix＠❰l¦r❱)は関係なし
    - IO
      - IOは足が生えた箱らしい。その箱が現実世界に出て、出力したり入力したりして、またHaskellの純粋な世界に入力データを持ち帰ってくる?
      - mainはIO()型
      - 不純な処理(`<-`代入?とか)は不純な環境のなかで行われる。不純な領域と純粋な領域を分けている
      - IOアクションのdo記法の中ならIOアクションが実行される?
      - IOはMain関数の中だけ(もしくは、その周辺)に書いてMain関数から他の関数にはデータリレーで渡しているようなイメージかな?..
      - `IO a`という型は`(->) a b`のように型はあるけど`data`で表す具体的な値コンストラクタは定義されていない?(できない)`data IO a = IO String a`String(プログラム)みたいな?
      - `IO a`は`IO a -> a`という型の関数が実行される時に副作用がある不純な処理をし、戻り値を`a`で受け取る?            ↑惜しい`newtype IO a = IO (RealWorld -> (RealWorld, a))`
    - モナド
      - `(>>=) :: Monad m => m a -> (a -> m b) -> m b`
      - `>>=`は**モナドからモナド**という**モナドとしての処理**をしつつ、`>>=`によって**取り出された普通の値**を**ユーザー定義されたクライスリ射**`a -> m b`
      によって**その値を自由に利用**し処理することができる。そしてまた**自由にそのモナドの文脈を付けて**、処理を`>>=`に戻す。
        - **モナド**(`>>=`)という**システムの中**で**ユーザー定義されたコードを実行**させる。と見ることもできる
      - `>>=`の**定義方法**として、入力`m a`がモナド値で出力`m b`もモナド値なので(`>>=`)の**結果は`m a`と同じモナド文脈**としての構造を返さなければならない
        - do記法

          ```haskell
          listDo = do       -- クライスリ射へ取り出される所までが一行。上から実行される。
            op <- [(+),(*)] -- [(+),(*)] >>= (\op ->
            x <- [2,3]      -- [2,3] >>= (\x ->
            y <- [4,5]      -- [4,5] >>= (\y ->     [(+),(*)] >>= (\op ->[2,3] >>= (\x ->[4,5] >>= (\y ->[op x y])))
            [op x y]        -- [op x y])))          [op x y|op <- [(+),(*)], x <- [2,3], y <- [4,5]] と等価
          ```

        do記法は`｢モナド値｣ >>= (｢クライスリ射 >>= (｢クライスリ射 >>= ｢クライスリ射｣｣｣))`の様に**クライスリ射**と`>>=`が**ネスト状**になっていて、
        do記法は**一行づつ**クライスリ射と`>>=`を**実行を開始**して行き、**最後の行で同時に終わる**ような構造をしている。そうする事で、再帰関数のように
        複数のモナド文脈を伴った処理を**一つの`>>=`で処理**している様に見え、**外側で取り出された普通の値**は**どの行でも参照**することができる。
        **最後の行**は、クライスリ射の`\x -> ココ`にあたる部分になるため、取り出す記号`<-`は使えません。そしてこれが、再帰関数の最底のように
        クライスリ射と`>>=`が実行し終わった**最終結果**として一番外側の`>>=`まで返され、これが**do記法の結果のモナド値**となります。
      - IOモナド
        キーボードから入力を受け取ったり、画面に出力したりする処理と言うのは具体的には、キーボードから入力されたデータをメモリに保存しそれをHaskellプログラムから
        参照したり、画面に出力するために、Haskellプログラムからグラフィックデバイスドライバが参照するアドレス空間にデータを書き込むことである。(多分)
        そのため、外の世界とインタラクティブな処理をするためには、Haskellプログラムのある部分つまり、**ある関数では外の世界と通信**するために、
        特定のアドレス空間に対して読み書きし、**Haskellの中と外を繋がなく**てはならない。その結果、その関数では与える引数がおなじでも、毎回違う結果を返し
        参照透過ではなかったり、**関数を実行すると**、外部に影響をあたえるという**副作用を伴う処理**をしたりする。(追記:副作用を伴う処理をすると
          言う**プログラムを返す**)(←の訂正:**現実世界という状態**を引数に取り、副作用を伴うプログラムを実行すると言う関数を返す)
        そんな純粋関数型言語でも純粋ではない関数を実行しなければHaskellプログラムの結果を見ることもできないし、入力を与えることもできない。
        では、どの関数が不純な処理を実行するのかというと、**IOという文脈が付いた値を解釈し実行する関数**である。
        その関数が`>>=`(もしくは、それを作る型クラスのメソッド(多分))である。(訂正:`>>=`は**IOモナドを糊付け**しているだけで実行はしていない)
        IOという文脈が付いた値には、具体的に**不純な処理を実行すると言うプログラムが書かれている**思われます。(想像)
        例えば`IO ()`という型の値の中には`print("Hello_World")`のような画面に"Hello_World"と表示してくださいというプログラムが書かれているかも知れません
        しかし、それは値であり関数ではないので、その値が自身のプログラムを勝手に実行する事はない。それと、その`IO`という文脈付きの値を作るには、
        その`IO`という文脈を付ける関数、例えば、
        引数に`"Hello_World"`と渡すと、`print("Hello_World")というプログラムが書かれた値`を返す`putStrLn :: String -> IO ()`関数があったり、
        `getLine :: IO String`という`キーボードからの入力をStringとして受け取ります。というプログラムが書かれた値`という値があります。
        その`IO`という文脈付きの値を引数にとり唯一`IO`型に書かれたプログラムを実行できる存在が`(>>=) :: Monad m => m a -> (a -> m b) -> m b`であり、
        この`m`を`IO`に置き換えると`(>>=) :: Monad IO => IO a -> (a -> IO b) -> IO b`となります。これは、入力に`IO a`を取りその`IO a`の`a`を取り出すために
        `IO a`型の**値の中に書かれたプログラムを実行**します。そして`a`を取り出します。この`a`は**外の世界から取ってきた(かもしれない)値**であり、これを
        クライスリ射`(a -> IO b)`に適用しこの**クライスリ関数からHaskellプログラムの純粋な世界で処理**することができます。そしてまたクライスリ射が
        `IO`というプログラムが書かれた値を作ります。そしてまたそれを`>>=`が実行し、っとなって不純な処理を実行するIOモナドの`>>=`と純粋な処理をするクライスリ射(関数)で
        不純な処理をする特定の場所(`>>=`)と純粋な処理をする場所(クライスリ関数)を**綺麗に分ける**ことができ純粋な場所では参照透過性の恩恵を受けられます。
        (正確には`>>=`も**IO型を返す**ので、**プログラムを実行するというプログラム(IO型の値)を返す**かも知れません。そのプログラムを実際の処理系で実行..。
        つまりHaskellの全ての.exe形式で実行可能なプログラムソースコードはプログラム(IO型)を返す..(mainはIO型(プログラム)でなければならない理由)それと、
        `main = putStrLn "Hello_World"` でも実行されるので`>>=`は複数のIO型(プログラム)順番に実行するために`>>=`で繋げて一つのIO型(プログラム)に纏める(糊付けする)だけかも知れない)
        後、`>>=`は`IO a -> (a -> IO b) -> IO b`の`IO a -> IO b`というふうに`IO`の中に閉じ込められているため、
        `iOFunc :: Maybe (IO String);iOFunc = Just (getLine >>= \x -> return x)`とやっても、Haskellの遅延評価により先に`getLine`が`>>=`で処理されず
        (追記:`>>=`もプログラム(IO型)を返すだけで実行はしてない?)`IO b`を引数にとる関数はその出力も必ずIO型であり、IOから非IOを返す関数は存在しない(多分)し、
        IO型を引数に取らない関数に与えると`getLine`が`>>=`で処理される前にエラーとなる?
        IOから非IOを返す関数`IO a -> a`な関数が存在しないとすれば、ある部分の関数がIO型を返せばルートの関数(mainとか)にまでIO型もしくはIO型をもつ文脈が返る?
        つまり、式木と関数スタックが、main -> 不純 -> 不純 -> 不純 -> 不純 -> 不純 -> 不純 -> 純粋 -> 純粋 -> 純粋 -> 純粋 -> 純粋 -> 純粋 -> 純粋 なイメージ
        `"IO a -> a"`でググったら`unsafePerformIO :: IO a -> a`というやばげな関数が出てきたｗ
        (追記:`unsafePerformIO`は、`unsafePerformIO iO = runIO iO realWorld`? {`runIO (IO f) realWorld = f realWorld`})
        `❰import System.IO.Unsafe❱ unsafeExe :: String; unsafeExe = unsafePerformIO getLine ++ "!!"` 本当に`getLine`を実行している..
        `unsafePerformIO`は本来、処理系が実行すべきもの? [禁断の機能「unsafePerformIO」の深淵](https://xtech.nikkei.com/it/article/COLUMN/20090512/329783/)

        - [Haskell の IO モナドと参照透過性の秘密](https://www.timedia.co.jp/tech/haskell-io-monad/)
          - **現実世界という状態**?(RealWorld)を引数にし**Stateモナド風**の関数合成のような感じで、合成していき、**結果を値コンストラクタに出力**することで
          アドレス空間に書き込み?**画面に出力**していた?
          これだと**プログラムが完了するまで**画面に**出力できない**気がするし、入力も評価中に実行しなければならないので、**評価中に副作用が発生する実行をしている**だろう
  - その他
    - [「参照透明な言語は並列化可能なポイントを簡単に見分けることができる」](https://qiita.com/hiruberuto/items/26a813ab2b188ca39019)
    ![並列化](並列化.png)
    - [Chocolatey インストール(chocoコマンド)](https://qiita.com/ShortArrow/items/ec3b77af1d53a84131a0)

- Haskellメモ
  - Haskell環境セットアップ(VScode)(色々やったけどうまく言ったと思われるやつ)
    - VScodeの拡張機能から、Haskell v2.2.0をインストール 右下から"Project requires GHC but isn't installed"と言われてエラーが出たのでリンクをクリックし
    [GHCup](https://www.haskell.org/ghcup/)と言うやつに貼ってある
    `Set-ExecutionPolicy Bypass -Scope Process -Force;[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072;Invoke-Command -ScriptBlock ([ScriptBlock]::Create((Invoke-WebRequest https://www.haskell.org/ghcup/sh/bootstrap-haskell.ps1 -UseBasicParsing))) -ArgumentList $true`
    を、VScodeのターミナル(powershell)に貼りEnterキーを押す
    最初に止めるか聞かれるので❰c❱を押した、その後デフォルトのパスにするか聞かれるので❰Enter❱を押した、後、色々インストールするけどいいか効いてくるでもよく分からないので適当に❰y❱を連打した(みんな、出てきた全ての用語を既に知っているものなのか?)
    すると色々がちゃがちゃ始まってVScodeのHaskellのインストールが終わった見たいだ(完)
      - 他に(多分↑でインストールされるので**要らない**と思うが、)[native OS package manager](https://www.haskell.org/downloads/)の`Show Windows package`の`Chocolatey: GHC, cabal, Stack`をインストールした

  - **関数**(変数も)は**小文字**からはじまる
    - データコンストラクタ(型)は大文字から(型定義でa->bとでるのは型変数(ジェネリックな型))
  - パターンマッチは行の**先頭からマッチ**する
  - 中置記法は'(シングルクオート)ではなく **`(バックスラッシュ)**
  - [標準ライブラリのソースコード](https://hackage.haskell.org/package/base)
  - パターンマッチが網羅できない場合は[error :: forall a. HasCallStack => [Char] -> a](https://tnomura9.exblog.jp/28225909/)を使う

  - ターミナル(powershell) [GHCの４つの実行方法](https://haskell.jp/blog/posts/2017/08-ghc-4way-execution.html)
    - `terminal font size`を**14=>24**変更 **====================================================**
    - `x = x + 1`などを実行して無限再帰した場合は`ctrl + C`で`Interrupted.`と出て抜けれる
    - ソースコード(**.hs**)のコンパイルと実行 [Haskellの実行](https://qiita.com/Nipper1357/items/4b4b9d60d8067fcf238c)
      - コンパイル: `ghc ｢ファイルパス.hs｣`(相対パスをコピー)
        - 出力されたexeの実行: `｢ファイルパス｣`
      - **コンパイル&実行**: `runghc ｢ファイルパス.hs｣`
    - `GHCi` で対話型インターフェースが起動する
      - `:q` 終了
      - 複数行入力
        - `:{`,`:}`の間 もしくは `;`で一行で書く
      - **GHCiに任意の関数を読ませたい**場合、**関数をコピー**してGHCiに **:{**を入力&Enterし **Ctrl + V**を押し何も起こらないが、その後右クリックを押すと貼り付けたいですか?と効いてくるのでハイと答えると貼り付けられる。その後 **:}**を入力&Enterを押すとGHCiに関数を読ませる事ができる
        - **確認しないようにした**
      - `GHCi`に`.hsファイル`を**ロードする======================================**
        - `:l ファイルパス.hs`(絶対パス か ghciを起動したパスからの相対パス)でロードできる
          - (`:r`だとリロードらしい)(`Prelude>`が`*Main>`に変わる)(例:`:l ❰C:\python学習メモ\vscode-works_study\git_test\Kenron\haskellTest.hs¦Kenron\haskellTest.hs❱`)
      - Haskell
        - `:t`: 型を調べる
        - `:k`: カインドを調べる
        - `:info` 型、型クラスの情報を調べる
