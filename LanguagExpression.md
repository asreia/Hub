`❰\u{2770}❱\u{2771}ˆ\u{2C6}¦\u{A6}≈\u{2248}∫\u{222B}＃\u{FF03}＄\u{FF04}＠\u{FF20}％\u{FF05}＆\u{FF06}⇒\u{21D2}⟪\u{27EA}⟫\u{27EB}`  
`❰❱ˆ¦≈∫＃＄＠％＆⇒⟪⟫！⏎✖｡` //！⏎✖｡追加  [Tab] [Alt] []<=括弧記号考える  
✖⏎//改行とスペース禁止  
❰小括弧❱❰｡中括弧｡❱❰｡｡大括弧｡｡❱ ｡¦｡  ｡はスペース替わりにも使える
拡張BNF…  \\n

LOperatorここの説明だけ
∫∫∫ => 新しい記号∫
`❰A❱⟦if⟧~⟦end⟧`//条件編集//`❰A❱∠⟦if⟧~⟦end⟧`予定
`~~⟦if⟧❰A¦B❱⇒❰A❱⟦then⟧❰C❱⟦else⟧❰D❱⟦end⟧~~`//`⟦if⟧❰..❱⇒❰..❱❰⟦then⟧¦⟦else⟧❱❰..❱⟦end⟧`として`⟦if⟧`の条件で処理を分岐できる。(後で`⟦if⟧`まとめる)  
`❰..❱⟦if⟧⟦this⟧∠❰⸨..⸩❱⇒❰⟪..⟫❱⟦then⟧⟦this⟧∠❰⸨⸩❱..⟦end⟧` //`⟦this⟧`は`⟦if⟧`の左側を指している。(式木として繋がっているなら`⟦this⟧`必項(常に必項かも..なら`⟦this⟧∠`を省略できるな..)) 

`＄val＝❰⟪A¦B¦C⟫_⟪D¦E⟫❱ ∫val∫⟪A¦B¦C⟫⇒❰C❱｡⟪D¦E⟫⊃❰D❱ ⟪⟪A¦B⟫_⟪D¦E⟫¦C_⟪D¦E⟫⊃❰D❱⟫`
`＄val＝❰⟪A¦B¦C⟫_⟪D¦E⟫❱ ∫val∫⟪A¦B¦C⟫⇒❰C❱｡＠⟪D¦E⟫ ⟪⟪A¦B⟫_⟪D¦E⟫¦C_＠⟪D¦E⟫⟫`
`＄val＝❰⟪A¦B¦C⟫_⟪D¦E⟫❱ ∫val∫⟪A¦B¦C⟫⇒⟪B¦C⟫｡＠⟪D¦E⟫ ⟪❰A❱_⟪D¦E⟫¦⟪B¦C⟫_＠⟪D¦E⟫⟫`
`       ❰⟪A¦B¦C⟫❱❰⟪D¦E⟫❱     ⟪A¦B¦C⟫⇒⟪B¦C⟫｡＠⟪D¦E⟫ ⟪❰❰A❱⟪D¦E⟫❱¦❰⟪B¦C⟫＠⟪D¦E⟫⟫❱⟫`  
`⟦if⟧【】⟦else⟧【】` `∫val∫⊃`
`{【❰⟪A¦B¦C⟫_⟪D¦E⟫❱⊃❰⟪B¦C⟫_D❱⇒✖⸨⟪D¦E⟫⸩】} => {⟪❰A❱_⟪D¦E⟫¦⟪B¦C⟫_❰E❱⟫∪❰⟪B¦C⟫_❱}` `{❰⟪B¦C⟫_D❱∩✖⟪D¦E⟫} => {❰⟪B¦C⟫_D❱∩Ø} => {Ø}`  
`{【❰⟪A¦B¦C⟫_⟪D¦E⟫❱⊃❰⟪B¦C⟫_D❱∠✖⸨D⸩】} => {⟪❰A❱_⟪D¦E⟫¦⟪B¦C⟫_❰E❱⟫∪❰⟪B¦C⟫_✖❰D❱❱}`  
`{【∫val0∫⊃∫val1∫∠∫OP∫∫val1の抽出∫】} => {❰∫val0∫∸∫val1∫❱∪❰⟪＃∫val1∫に変更を加えたもの＃⟫❱}`  `{❰⟪A¦B¦C⟫_❱∩❰⟪B¦C⟫_❱} => {⟪B¦C⟫_}`  `{❰⟪B¦C⟫_D❱∪✖⟪D¦E⟫} => {❰⟪B¦C⟫_D❱}`



基礎([token](#token), [token block](#tokenb)) -> [xorステージ](#xors) -> [xor変換系](#xorc) -> [合成ステージ](#gousei) -> [tagステージ](#tag) -> [variableステージ](#var) -> [`xorとスキップと"∫∫"とlineステージによる構造と評価手順`](#tegyun)  
↑をさらっと読んだほうが分かりやすいかも  

- `{..} => {..}`という表現について  
    `＠❰..:❱{..} => {..}`という表現は、`{..}`内(または`❰..❱`)になんらかの`評価する対象`があり`=>`の`前`が`評価前`を表し、`後`が`評価後`を表す。  
    [例] `+:{1+2} => {3}`というのは、評価する対象`+`があり、評価前は`1+2`で評価後は`3`である。  
- `[表現]`について  
    `[表現]`は`変数ブロックとFoxブロックが評価された直後の状態を表す`とし、その項で説明している`メタ文字`の`使われ方を表現`している。  
- `∫LExpress∫`は`言語表現`を使って`構成`された`任意の式`である。`∫LExpress∫`を単に`式`または`ブロック`と呼ぶ場合がある。  

# 言語表現(LanguageExpression)  

- 基礎  
    - Token(トークン) <a id="token"></a>  
        [表現] `∫LToken∫`  
        [例] `{❰static❱}の{static}, {❰System❰.Object❱❱}の{System,.Object},`  
             `{❰ A B C ❱}の{ A B C }, {⟪肉¦魚⟫}の{肉,魚}, {⟪ans = ⟦1.0⟧ / ⟦2.0⟧⟫}の{ans = ,1.0, / ,2.0}がトークン`  
        [説明] トークンとは、ほぼ任意の文字列。`トークンブロック(❰❱)`または`関数ブロック(⟪⟫)`内でのみ現れる必要がある。  
                ほぼ任意とは、この言語表現(LanguageExpression)を構成する(エスケープされていない)構成文字(❰❱¦＄＝∫などの特殊文字)(メタ文字とも言う)が含まれない文字列。  
        - [詳細]  
            `トークン`とは言語表現によって組み替えたり複製されたりして加工される文字列の事。  
            `変数ブロック`や`Fox関数ブロック`内の任意の文字列は変換されるためだけの文字列なのでトークンではない。  
    - Null(ヌル)(`Ø`)  
        [表現] `Ø`  
        [説明] ヌル％❰トークン❱(Ø(U+00D8))は、そこに`トークンが無い`事を示す。  
               `ライン処理`で`解決`される。  

    - ブロック (❰❱,⟪⟫,∫∫,∫∫∫,【∠⸨⸩】)  
        - Token block(トークンブロック(`❰❱`)) <a id="tokenb"></a>  
            [表現] `{¥❰∫LExpress∫¥❱}`  
            [例] `{❰token0❰token1❰token2❱❱❰token3❱❱}`  
            [説明] トークンブロック(`❰❱`(U+2770,U+2771))は、トークンを区切る役割を持つ。  
            - [詳細]  
                `{＠❰token❱}`の`"＠"`や`{❰token0❱∪❰token1❱}`の`"∪"`は`ブロック演算子`と言い`トークンブロック`に対して作用する。  

        - Function block(関数ブロック(`⟪⟫`(`¦,～,⟦：⟧,＃`)))  
            [表現] `{¥⟪⟪＃各関数ブロックの中身＃⟫¥⟫}`  
            [例] `Xor: {⟪A¦B⟫}, Index: {⟪2～4⟫} => {⟪2¦3¦4⟫}, Permutation: {⟪⟦A⟧⟦B⟧⟫} => {⟪AB¦BA⟫}, Fox: {⟪＃五影＃⟫} => {⟪火影¦風影¦土影¦水影¦雷影⟫}`  
            [説明] 関数ブロック(`⟪⟫`(U+27EA,U+27EB))は、トークンまたは数値を引数に、新しい`Xorブロック`または`トークンブロック`を`生成して返します`。  
                   関数ブロックの種類は`Xor(¦)`,`Index(～)`,`Permutation(⟦：⟧)`,`Fox(＃)`があります。  

        - Variable block(変数ブロック(`∫∫,∫∫∫`))  
            [表現] `⟪¥∫¦¥∫¥∫⟫∫LToken∫¥∫`  
            [例] `{∫val∫} => {⟪A¦B⟫}, {∫∫val∫} => {❰A❱}`  
            [説明] 変数ブロックは、`同期変数ブロック`(`∫∫∫`)と`非同期変数ブロック`(`∫∫`)があり、評価するとその位置に代入された`式`を展開する。  
        
        - Change extraction block(抽出変更ブロック(`【⇒∠⸨⸩】`))  
            [表現] `＄OP＝＠⟪＃"⸨⸩"へのブロック演算系の操作＃⟫ ＃0："【"の右に現れる式の中のブロックを跨がない文字列`  
                   `¥【∫LExpress∫｡⟦¥┃┃～⟧❰｡｡｡⟦～⟧❰¥⇒∫LExpress∫❱｡＠❰｡｡¥⇒¥＄∫LToken∫¥＝¥⸨∫LExpress∫¥⸩｡｡❱｡＠❰｡｡∠∫LExpress∫∫OP∫｡¥⸨⟪＃＃0＃⟫¥⸩｡∫OP∫∫LExpress∫｡｡❱｡｡｡❱¥】`  
            [例] `{【❰A❰B❱❱∠✖⸨B⸩】} => {❰A❰✖❰B❱❱❱}, {＄val＝❰A⟪B¦C⟫❱【∫val∫∠✖⸨B⸩】} => {❰A⟪✖❰B❱¦C⟫❱}`  
                 `{＄val0＝❰B∫val1∫❱ ＄val1＝❰B⟪D¦B⟫❱【❰A∫val0∫❱⇒∫val0∫⇒∫val1∫⇒⟪D¦B⟫∠✖⸨B⸩】} => {❰A❰B❰B⟪D¦✖❰B❱⟫❱❱❱}`  
            [説明] 抽出変更ブロック(`【⇒∠⸨⸩】`(U+3010,U+21D2,U+2220,U+2E28,U+2E29,U+3011))は、  
                   `式`の`部分`を`抽出`し`変更`を加えてしまう、`式木の部分木`に`変更を加える`やばいブロックである。  
            - [詳細]  
                下記の式は、`ブロックの中の一番の左`が`抽出される元`になる`式(❰A⟪B¦C⟫)`で、`⇒`の`右項`が`抽出`された`式(⟪B¦C⟫)(⇒抽出対象)`で、  
                    `∠`の`右項`が`抽出`された`トークンの部分(C)(∠抽出対象)` に`変更を加えたもの(✖⸨C⸩)`になります。  
                `{【❰A⟪B¦C⟫❱⇒⟪B¦C⟫∠✖⸨C⸩】}`  

                `抽出`する`機能`は`⇒`と`∠`の大きく`2つ`になります。  
                `⇒`は`式`単位で抽出して変更でき、`∠`は`トークンの連続部分文字列`単位で抽出して変更できます。
                - `∠`の機能  
                    `∠`は、まず、`式`から`トークンを構成する文字列`の`連続した範囲`を`抽出`します。  
                    `{【❰A❰B❱❱∠⸨B⸩】}`  
                    そして、それに`変更を加える(✖)`事ができます。  
                    `{【❰A❰B❱❱∠✖⸨B⸩】} => {❰A❰✖❰B❱❱❱}`  

                    `連続した範囲`を`抽出`できます。  
                    `{【❰ABCD❱∠✖⸨BC⸩】} => {❰A✖❰BC❱D❱}` ｢`❰ABCD❱`の場合、`連続した範囲の全ての集合`は`{ABCD,ABC,AB,A,BCD,BC,B,CD,C,D}`になります。  

                    `抽出元`が`変数ブロック`であっても`変数の定義元を参照`し`抽出`することができます。  
                    `{＄val＝❰A⟪B¦C⟫❱【∫val∫∠✖⸨B⸩】} => {【❰A⟪B¦C⟫❱∠✖⸨B⸩】} => {❰A⟪✖❰B❱¦C⟫❱}, `  

                    `抽出対象の文字列`が`抽出元から複数の抽出`を`表す`場合、その`複数の抽出全て`を`変更の対象`にします。  
                    `{【❰ABCB❱∠✖⸨B⸩】} => {❰A✖❰B❱C✖❰B❱❱}, `  

                    `変更の方法`は`ブロック演算子以外`にも、`ブロック関数の引数`にしたり、`抽出対象の前後に式を並べる`事ができます。  
                    `{【❰AB❱∠⟪⸨B⸩¦D⟫】} => {❰A⟪❰B❱¦D⟫❱}, {【❰AB❱∠C⸨B⸩D】} => {❰AC❰B❱D❱}`  

                - `⇒`の機能  
                    `⇒`は`抽出対象を絞り込む`事と、`⇒`で`ブロック演算系の操作`と`抽出された式と同期`する事ができます。  

                    `抽出対象の絞り込み`は、`抽出元`から`⇒`の`右項`が`抽出した式`になり、`⇒`を`連続して繋げる`ことで`更に絞り込む`事ができます。(式木を頂点から下るイメージ)  
                    `{＄val0＝❰B⟪D¦B⟫❱【❰A❰B∫val0∫❱❱⇒❰B∫val0∫❱⇒∫val0∫⇒⟪D¦B⟫∠✖⸨B⸩】} => {❰A❰B❰B⟪D¦✖❰B❱⟫❱❱❱}`  
                    `抽出元`から`一段ずつ抽出しなくても`一気に`複数段とんで抽出`する事ができます。  
                    `{＄val0＝❰B⟪D¦B⟫❱【❰A❰B∫val0∫❱❱⇒⟪D¦B⟫∠✖⸨B⸩】} => {❰A❰B❰B⟪D¦✖❰B❱⟫❱❱❱}`  
                    `⇒`による`式の抽出なし`で`∠`による`抽出対象の抽出`をやってしまうと`抽出元の式`の`式木に現れる全ての対象`から`抽出`されてしまいます。  
                    `{＄val0＝❰B⟪D¦B⟫❱【❰A❰B∫val0∫❱❱∠✖⸨B⸩】} => {❰A❰✖❰B❱❰✖❰B❱⟪D¦✖❰B❱⟫❱❱❱}`  
                    
                - `⇒`の`ブロック演算系の操作`  
                    `∠`と同じで`ブロック演算子`の適用、`ブロック関数の引数`にする、`抽出対象の前後に式を並べる`事ができます。  
                    `{【❰A⟪B¦C⟫❱⇒＠⸨⟪B¦C⟫⸩】} => {❰A＠❰⟪B¦C⟫❱❱}, {【❰A⟪B¦C⟫❱⇒⟪⸨⟪B¦C⟫⸩¦D⟫】} => {❰A⟪❰⟪B¦C⟫❱¦D⟫❱}, {【❰A⟪B¦C⟫❱⇒D⸨⟪B¦C⟫⸩E】} => {❰A❰D❰⟪B¦C⟫❱E❱❱}`  

                - `⇒`の`抽出代入`とその`同期`  
                    `⇒の抽出`を`⸨⸩`で囲み、それを`変数に代入する`とその`抽出した式を代入(式木の部分木)`でき`抽出元`との`同期`もできる。  
                    `{【❰A＄val0＝⟪B¦C⟫❱⇒＄val1＝⸨⟪B¦C⟫⸩】} => {{∫∫val0∫}⇔{∫∫val1∫}}` ｢`val0`と`val1`は`同期`している。  

                - `┃`の連続抽出変更  
                    `⇒`や`∠`による操作を`┃で区切る`ことで、`抽出変更ブロック`を`ネスト`したものに変換できる。  
                    `{【❰ABCD❱∠✖⸨B⸩┃∠✖⸨D⸩】} => {【【❰ABCD❱∠✖⸨B⸩】∠✖⸨D⸩】} => {【❰A✖❰B❱CD❱∠✖⸨D⸩】} => {❰A✖❰B❱C✖❰D❱❱}`  

                ＄Static_Class_name=∫Static_Class∫∠●∫name∫●`, ∫∫Static_Class_name∫  
                の、`●`は`∫∫∫`を使うことで`●`の意味にする。  
                つまり、`∠`の前(抽出元)と後(抽出した部分)は同期している。   

    - Block operator(ブロック演算子(`＄＝,✖,＠,％,⟦┃～⟧,⊃,∪,∸,⚺,≡`))  
        [表現] `{∫LUnaryOperator∫｡∫LExpress∫}, {∫LExpress∫｡∫LBinaryOperator∫｡∫LExpress∫}`  
        [例] `{＠❰A❱} => {⟪A¦Ø⟫}, {✖⟪A¦B⟫} => {Ø}, {⟪A¦B¦C⟫⊃⟪A¦B⟫} => {⟪A¦B⟫}, {⟪A¦B¦C⟫∩⟪B¦C¦D⟫} => {⟪B¦C⟫}`  
        [説明] ブロック演算子には、`ブロック単項演算子`と`ブロック2項演算子`があります。  
               ブロック演算子は、`ブロック`に作用し、新しい`Xorブロック`または`トークンブロック`を`生成して返します`。  
               ブロック単項演算子は`代入演算子(＄＝)`,`破棄(✖)`,`オプション(＠)`,`デフォルト(％)`,`量化(⟦┃～⟧)`があります。  
               ブロック2項演算子は`インプ(⊃)`,`和(∪)`,`差(∸)`,`排他(⚺)`,`積(∩)`,`イコール(≡)`があります。  
               `ブロック単項演算子`は`左から作用`します。  

    - ブロック単項演算子の合成則 <a id="gousei"></a>  
        [表現] `⟦2～⟧∫LUnaryOperator∫｡∫LExpress∫`  
        [例] `{⟦～⟧＠❰A❱} ⇔ {⟦～⟧❰＠❰A❱❱}`  
        [説明] `ブロック単項演算子`が`トークンブロックの左側`に`連続して並んでいる`とき`トークンブロック`で`区切って作用`させるのと同じになります(`右結合`)。  

    - 関数ブロックとブロック演算子の評価順序と結合規則  
        評価順序は、  
            [`代入演算子(＄＝)(非同期の代入)`] => [`Xor(¦)以外のブロック`] => [`代入演算子(＄＝)以外のブロック単項演算子`] =>  
            [`包含(⊃)`] => [`和集合(∪)`] => [`差集合(∸)`] => [`排他集合(⚺)`] => [`積集合(∩)`] => [`イコール(≡)`] => [Xor(¦)] =>  
            [`代入演算子(＄＝)(同期の代入)`] => [ライン]  
        となります。  
        -[例]  
            ｢`非同期の代入`を`＄HiDouki＝`で表し、`同期の代入`を`＄Douki＝`で表している  
            `＄HiDouki＝:{＄HiDouki＝＠⟪⟦A⟧⟦B⟧⟫⊃⟪AB¦Ø⟫} => ⟦：⟧:{＄Douki＝＠⟪⟦A⟧⟦B⟧⟫⊃⟪AB¦Ø⟫} => ＠:{＄Douki＝＠⟪AB¦BA⟫⊃⟪AB¦Ø⟫} =>`  
            `⊃:{＄Douki＝⟪AB¦BA¦Ø⟫⊃⟪AB¦Ø⟫} => ¦:{＄Douki＝⟪AB¦Ø⟫} => ＄Douki＝:{＄Douki＝{❰AB❱}または{Ø}} => line:{{❰AB❱}または{Ø}} =>`  
            `{{AB}または{}}`  
        
        結合規則は、`ブロック単項演算子`は`右結合`、`ブロック2項演算子`は`左結合`です。  

        評価順序を変えたい場合はトークンブロック(`❰❱`)で囲むことにより変えることができます(数学の`()`と同じ様に)。  
        `{✖❰A❱∪❰B❱} => {Ø∪❰B❱} => {⟪Ø¦❰B❱⟫} => {❰B❱}`, `{✖❰❰A❱∪❰B❱❱} => {✖⟪❰A❱¦❰B❱⟫} => {Ø}`  

    - 補助機能  
        - Comment(コメント(`｢｣`))  
            [表現]`{¥｢⟪＃任意の文字列＃⟫¥｣},{¥｢⟪＃任意の文字列＃⟫}`   
            [例] `{｢コメント｣} => {}, {｢コメント   \n} => {}` (`\n`は改行コード)  
            [説明] コメント(`｢｣`(U+FF62,U+FF63))はC言語と同じで`//`は`｢`と同じで、`/**/`は`｢｣`と同じ。  

        - Escape(エスケープ(`¥`))  
            [表現] `{¥¥⟪＃メタ文字＃⟫}`  
            [例] `{¥＠}, {¥∫¥∫val¥∫}`  
            [説明] エスケープ％❰演算子❱(`¥`(U+00A5))はC言語のエスケープ文字`\`と同じで`メタ文字`を`メタ文字ではない文字`にする。  

        - macro(マクロ(`＃,＃：`))  
            - マクロ定数  
                ＃：..\n
            - マクロ関数作る?  

        - Space character(スペースキャラクタ(`｡`))  
            [表現] `⟪＃任意の文字列＃⟫¥｡⟪＃任意の文字列＃⟫`  
            [例] `{ldc⟪❰｡｡❰.i4❱＠⟪｡❰.⟪0~8⟫❱¦.m1¦.s｡⟫｡｡❱¦.i8¦.r4¦.r8⟫} => {ldc⟪❰❰.i4❱＠⟪❰.⟪0~8⟫❱¦.m1¦.s⟫❱¦.i8¦.r4¦.r8⟫}`  
                 `{＄Method＝⟪∫Normal_method∫｡¦｡∫Instance∫｡¦｡∫Static∫｡¦｡∫part_method∫｡¦｡∫Interface_method∫｡¦｡∫expr_method∫｡¦｡∫Tructor∫⊃⟪∫cctor∫¦∫ctor∫¦∫Finalize∫⟫｡¦⏎`  
                 `｡∫Prodexer∫⊃⟪∫Property∫¦∫Indexer∫⟫｡¦｡∫Iterator∫｡¦｡∫Extension∫｡¦｡∫Operator∫⟫} =>`  
                 `{＄Method＝⟪∫Normal_method∫¦∫Instance∫¦∫Static∫¦∫part_method∫¦∫Interface_method∫¦∫expr_method∫¦∫Tructor∫⊃⟪∫cctor∫¦∫ctor∫¦∫Finalize∫⟫¦⏎`  
                 `∫Prodexer∫⊃⟪∫Property∫¦∫Indexer∫⟫¦∫Iterator∫¦∫Extension∫¦∫Operator∫⟫}`  
            [説明] スペースキャラクタ(`｡`(U+FF61))は、`{｡} => {}`となり、ただ消えるだけで何もしません。スペースを`｡`で作って分かりやすさのために使います。  
                  通常のスペース` `は、`{ } => { }`となり` `は消えません。  
                  つまり、` `は`{⟪ A ¦ B ⟫} => {⟪ A ¦ B ⟫} => { A }`ですが、`｡`は`{⟪｡A｡¦｡B｡⟫} => {⟪A¦B⟫} => {A}`となります。  

        - 改行(`⏎`)  
            a  

- variable(変数(`＄＝`,`∫∫`,`∫∫∫`)) <a id="var"></a>  
    [表現] (定義と代入)`¥＄∫∫LToken∫¥＝∫LExpress∫`  
          (変数の使用)`⟪¥∫¦¥∫¥∫⟫∫∫LToken∫❰¥∫❱`  
    [例] (定義と代入)`{＄val＝⟪A¦B⟫} => {⟪A¦B⟫}`, (変数の使用)`{∫val∫} => {⟪A¦B⟫}`  
    [説明]  `代入％❰演算子❱`(`＄＝`(U+FF04,U+FF1D))は、変数に`式`を代入できる。  
            `同期変数％❰ブロック❱`(`∫∫∫`(U+222B))と`非同期変数％❰ブロック❱`(`∫∫`)(まとめて`変数％❰ブロック❱`)は、それが使われた位置に代入された`式`を展開できる。 
    - [詳細]
        (定義と代入)`{＄val＝⟪A¦B⟫} => {⟪A¦B⟫}`
        `val`は定義された変数名でそれに`⟪A¦B⟫`を代入している。`＄val＝`の部分は評価すると消えるだけで右側の`⟪A¦B⟫`になんの影響も与えない。  
        (変数の使用)`{∫val∫} => {⟪A¦B⟫}`
        `∫val∫`の様に変数名を`∫`で囲むとその位置に代入された`⟪A¦B⟫`を展開する。
        - `∫∫∫`の`同期変数ブロック`と`∫∫``非同期変数ブロック`の違い  
            とりあえず`val`を`＄val＝⟪A¦B⟫`の様に代入する。  
            このとき、`∫val∫`と書くと、その位置に`⟪A¦B⟫`が展開される。  
            そして、`∫∫val∫`と書くと大元の`⟪A¦B⟫`が`❰A❱`と決定されると`∫∫val∫`の展開も`❰A❱`となる。同様に`❰B❱`と決定すると展開も`❰B❱`となる。  
            つまり、`❰∫val∫_∫val∫❱`と書くと`❰A_B❱`となるパターンがあり`∫val∫`と`∫val∫`の結果が違う事がありえるが、  
            `❰∫∫val∫_∫∫val∫❱`の場合は一つの大元の`⟪A¦B⟫`の決定により`❰A_A❱`か`❰B_B❱`しかありえない。  
        - `∫∫∫`の`同期変数ブロック`は展開が`❰&Null❱`になる事がある。  
            とりあえず、`val`を`⟪＄val＝❰A❱¦❰B❱⟫`と言う状況で代入する。  
            このとき、`⟪＄val＝❰A❱¦❰B❱⟫`が`❰B❱`に決定して、`＄val＝❰A❱`が選択されなかった場合は、
            `∫∫val∫`は`❰&Null❱`になります。`∫val∫`の場合は`❰A❱`になります。
        - いくつか組み込みで変数を定義している。(Lから始まる)  
            `$LToken=❰#ブロック演算子を含んでいない文字列(空集合は含まない)#❱ ❰/:原子論理式のようなもの` ⟪＃⟦～⟧❰U+⟪0x┃～⟫❱を文字コード化したもの＃⟫  
            `$LExpress=❰#ブロック演算子による操作を含むかもしれない文字列(空集合は含まない)#❱ ❰/:論理式のようなもの` 定義できるかな?  
            //↓の３つは組み込みから外すここの説明用なのでここの先頭で定義する。===================================================  
            `＄LOperator=❰#全てのブロック演算子(＄＝,✖,＠,％,⟦┃～⟧,⊃,∪,∸,⚺,∩,≡)#❱ ❰/:論理演算子のようなもの`  
            `＄LUnaryOperator＝⟪＃全てのブロック単項演算子(＄＝,✖,＠,％,⟦┃～⟧)＃⟫`  
            `＄LBinaryOperator＝⟪＃全てのブロック2項演算子(⊃,∪,∸,⚺,∩,≡)＃⟫`  
            `$LIndex=#lit❰#自然数#❱`//ボツ    
            `$LAny=❰#対象言語でその位置に出現可能な全てのトークン#❱`  

- ブロック演算系  
    - Destruction(破棄(`✖`))  
        [表現] `¥✖∫LExpress∫`  
        [例] `{✖❰A❱} => {Ø}`  
        [説明] 廃棄％❰演算子❱(`✖`(U+2716))は`ブロック`を`破棄`します。  
        - [詳細]  
            `{✖∫LExpress∫} ⊃ {Ø}`  
            `✖`は`ブロック`に作用すると`Ø`になります。  

    - Xor構成系 <a id="xorc"></a>  
        - Xor(エックスオア(`¦`)) <a id="xors"></a>  `{⟪A¦B¦B⟫} => {⟪A¦B⟫}`
            [表現] `¥⟪⟦¥¦┃2～⟧∫LExpress∫¥⟫`  
            [例] `{⟪A¦B⟫} => {{❰A❱}または{❰B❱}}`｢`⟪A¦B⟫`という`Xorブロック`から、`❰A❱`というトークンブロックを返す または `❰B❱`というトークンブロックを返します。  
            [説明] Xor％❰ブロック❱(`¦`(U+00A6))は、`与えられたトークン`から`一つ選び`トークンブロックを生成して返します。  
            - [詳細]  
                このXorブロックは言語表現(LanguageExpression)の中で`一番重要で中心的な処理`である。  
                `与えられたトークン`から`一つ選び`ますが、`どう選ぶかは定義しません`。  
                ただ、`⟪A¦B⟫`という文から`❰A❱`が選ばれる`可能性`もあるし、`❰B❱`が選ばれる`可能性`もある。と考えてください。  

        - Option(オプション(`＠`))  
            [表現] `¥＠∫LExpress∫`  
            [例] `{＠❰A❱} => {⟪A¦❰&Null❱⟫}, {＠⟪A¦B⟫} => {⟪A¦B¦❰&Null❱⟫}`  
            [説明] オプション％❰演算子❱(`＠`(U+FF20))は、ブロックに`❰&Null❱`が選択される可能性を`Xor`で足します。  

        - Default(デフォルト(`％`))  
            [表現] `¥％∫LExpress∫`  
            [例] `{％❰A❱} => {⟪A¦❰&Null❱⟫}, {％⟪A¦B⟫} => {⟪A¦B¦❰&Null❱⟫}`  
            [説明] デフォルト％❰演算子❱(％(U+FF05))は、Optionと全く同じ処理をします。  
            - [詳細]  
                `オプション`と`デフォルト`の`違い`は、メタ的な事柄によるものになります。  
                この言語表現(LanguageExpression)は、大抵の場合、対象となる`モデル`(大体はプログラミング言語かな)が存在すると思います。  
                その中で、`あるトークン`が`明記していなくても、明記したのと変わらない事を示す`ために`デフォルト`が使われます。  
                - [考え方]  
                    [具体例] `私は％❰｡｡⟪％❰財布から❱¦口から⟫⟪100円¦400円⟫を出して｡｡❱買った。`, `class C{％❰private❱ int n;}`  
                    この様に書かなくてもわかる事やプログラミング言語的に決められている事に対して効果があります。  
                    `＠⟪％❰A❱¦B⟫`の様に`Xorブロック内`で使われた場合、`❰&Null❱`であったとしてもモデルの中では`❰A❱`であることを示す。  

        - Index(インデックス(`～`)) ⟪0x┃～0xFF┃2^i⟫,⟪┃2┃⟫,Operator(⟪2～4┃i*2⟫,⟪2～4┃2^i⟫)  
            [表現] `¥⟪＠⟪＃自然数＃⟫¥～＠⟪＃自然数＃⟫¥⟫`  
            [例] `{⟪1～3⟫ => ⟪1¦2¦3⟫}, {⟪～2⟫} => {⟪0¦1¦2⟫}, {⟪2～⟫} => {⟪2¦3¦4¦..⟫}, {⟪～⟫} => {⟪0¦1¦2¦..⟫}`  
            [説明] インデックス％❰ブロック❱(`～`(U+FF5E))は、自然数を0個～2個を引数に取り、その`範囲`を`Xorで繋げたもの`をXorブロックかトークンブロックで返します。  
            - [詳細]  
                開始の自然数を省略すると`0～2`になります。  
                `{⟪～2⟫} => {⟪0～2⟫} => {⟪0¦1¦2⟫}`  
                終了の自然数を省略すると`2～無限`になります。  
                `{⟪2～⟫} => {⟪2¦3¦4¦..⟫}`  
                両方の自然数を省略すると`0～無限`になります。  
                `{⟪～⟫}  => {⟪0¦1¦2¦..⟫}`  
                両方の自然数を同じにするとその自然数になり`トークンブロック`で返ります。  
                `{⟪2～2⟫} => {❰2❱}`  

        - Replicate(レプリケート(`⟦┃～⟧`))  
            [表現] `¥⟦｡｡｡❰｡｡∫LExpress｢区切り文字｣∫＠❰¥┃❱＠⟪～⟫¥～＠⟪～⟫｡｡❱｡∪｡❰¥┃⟪～⟫¥┃❱¥｡｡｡⟧∫LExpress∫`  
            [例] `{⟦,┃1～3⟧❰A❱} => {⟪A¦A,A¦A,A,A⟫}`  
            [説明] レプリケート％❰演算子❱(`⟦┃～⟧`(U+27E6,U+2503,U+FF5E,U+27E7))は、指定回数分、式を複製し、複製と複製の間を`区切り文字`で区切ります。そして、  
                   それを、指定回数の範囲分複製し、それを`Xor`で繋げます。  
            - [詳細]  
                `,`は区切り文字となり、1～3は1回,2回,3回の複製のパターン全てを`Xor`で繋げる。  
                `{⟦,┃1～3⟧❰A❱} => {⟪A¦A,A¦A,A,A⟫}`  
                区切り文字を省略して無くすことができる。  
                `{⟦2～4⟧❰A❱} => {⟪AA¦AAA¦AAAA⟫}`  
                ～4として開始の回数を省略すると0～4の意味となり0回から複製が開始される  
                `{⟦～4⟧❰A❱} => {⟪❰&Null❱¦A¦AA¦AAA¦AAAA⟫}`  
                2～として終了の回数を省略すると2～無限の意味となり複製が無限に続く  
                `{⟦2～⟧❰A❱} => {⟪AA¦AAA¦..⟫}`  
                ～とすると0～無限の意味となり0回から複製が無限に続く  
                `{⟦～⟧❰A❱} => {⟪❰&Null❱¦A¦AA¦..⟫}`  
                複製が無限の時に区切り文字が指定されても無限に続く最後は`A`で終わる  
                `{⟦,┃～⟧❰A❱} => {⟪❰&Null❱¦A¦A,A¦..,A⟫}`  
                指定回数の範囲が無い場合、`┃`で囲むことで数字を1個にできる。そして返り値がトークンブロックになる。  
                `{⟦,┃2～2⟧❰A❱} <=> {⟦,┃2┃⟧❰A❱} => {❰A,A❱}`, `{⟦┃2～2┃⟧❰A❱} <=> {⟦┃2┃⟧❰A❱} => {❰AA❱}`  
        
        - Permutation(置換(`⟦：⟧`))  
            [表現] `¥⟪⟦1～⟧⟪｡｡∫LExpress∫｡¦｡¥⟦∫LExpress∫¥⟧｡¦｡¥⟦∫LToken∫¥：∫LExpress∫¥⟧｡｡⟫¥⟫` ｢`⟦..⟧`が一つ以上出現すること  
            [例] `⟪⟦1⟧ + ⟦2⟧ * ⟦3⟧⟫ => ⟪1 + 2 * 3¦1 + 3 * 2¦2 + 1 * 3¦2 + 3 * 1¦3 + 1 * 2¦3 + 2 * 1⟫`  
            [説明] 置換(`⟦：⟧`(U+27E6,U+FF1A,U+27E7))は、複数の`⟦∫LExpress∫⟧`の並び替えた全ての結果を`Xor`で繋ぐ。(`[例]`の場合は3!=6個の並び替え)  
            - [詳細]  
                `⟦∫LToken∫：∫LExpress∫⟧`とする事で、同じ`∫LToken∫`同士で並び替えする事ができる(この場合は3!*2!=12個の並び替え)  
                `{⟪⟦1⟧ ⟦op：+⟧ ⟦2⟧ ⟦op：*⟧ ⟦3⟧⟫} => {⟪1 + 2 * 3¦1 + 3 * 2¦2 + 1 * 3¦2 + 3 * 1¦3 + 1 * 2¦3 + 2 * 1¦⏎`  
                                                   `1 * 2 + 3¦1 * 3 + 2¦2 * 1 + 3¦2 * 3 + 1¦3 * 1 + 2¦3 * 2 + 1⟫}`  

        - Fox(フォックス(`＃`))  
            [表現] `¥⟪¥＃∫LToken∫¥＃¥⟫`  
            [例]  `{⟪＃π＃⟫} => {❰3.1415926..❱}, {⟪＃GAFA＃⟫} => {⟪google¦amazon¦facebook¦apple⟫}, {⟪＃ウニの数え方＃⟫} => {⟪⟪1~⟫⟪壺¦個¦腹¦匹⟫⟫} => {Xorブロック}`  
            [説明] フォックス％❰ブロック❱(`＃`(U+FF03))は、引数の文字列から分かる集合を`Xor構成系`で表現し`Xorブロック`または`トークンブロック`で返す。~~(ｲﾝﾁｷ臭いブロック関数である)~~  

    - Xor集合演算系  
        - Xor集合比較演算系  
            - Inclusion(包含(`⊃`))  
                [表現] `∫LExpress∫¥⊃∫LExpress∫`  
                [例] `{⟪A¦B¦C⟫⊃⟪A¦B⟫} => {⟪A¦B⟫}, {⟪A¦B⟫⊃⟪A¦B¦C⟫} => {Ø}`  
                [説明] 包含(`⊃`(U+2283))は、`トークンのXorの連なり`において、`左項の⟪トークン¦Xor⟫ブロック`が`右項の⟪トークン¦Xor⟫ブロック`の`部分集合`になっているか検証し、  
                       なっていれば`右項`をそのまま返し、なっていなければ`Ø`を返します。  
                - [詳細]  
                    `⟪A¦B¦C⟫`は`⟪A¦B⟫`の`部分集合`なので`右項(⟪A¦B⟫)`が返ります。  
                    `{⟪A¦B¦C⟫⊃⟪A¦B⟫} => {⟪A¦B⟫}`  

            - Equal(イコール(`≡`))  
                [表現] `∫LExpress∫¥≡∫LExpress∫`  
                [例] `{⟪A¦B⟫≡⟪A¦B⟫} => {⟪A¦B⟫}, {⟪A¦B¦C⟫≡⟪A¦B⟫} => {Ø}`  
                [説明] イコール(`≡`(U+2261))は、`トークンのXorの連なり`において、`左項の⟪トークン¦Xor⟫ブロック`と`右項の⟪トークン¦Xor⟫ブロック`が`等しい集合`になっているか検証し、  
                       なっていれば`その集合のXorの連なり`をそのまま返し、なっていなければ`Ø`を返します。  

        - Union(和集合(`∪`))  
            [表現] `∫LExpress∫¥∪∫LExpress∫`  
            [例] `{⟪A¦B⟫∪⟪B¦C⟫} => {⟪A¦B¦C⟫}`  
            [説明] 和集合(`∪`(U+222A))は、`トークンのXorの連なり`において、`左項の⟪トークン¦Xor⟫ブロック`と`右項の⟪トークン¦Xor⟫ブロック`の`和集合`を取り、  
                   `その集合のXorの連なり`を返します。  
            - [詳細]  
                `⟪トークン¦Xor⟫ブロック`を`和集合で繋げた`ものと、`Xorで繋げたもの`は、`同値`になります。  
                `{{⟪A¦B⟫∪⟪B¦C⟫∪❰D❱} => {⟪A¦B¦C¦D⟫}} ⇔ {{⟪⟪A¦B⟫｡¦｡⟪B¦C⟫｡¦｡❰D❱⟫} => {⟪A¦B¦C¦D⟫}}`  

        - Meet(積集合(`∩`))  
            [表現] `∫LExpress∫¥∩∫LExpress∫`  
            [例] `{⟪A¦B⟫∩⟪B¦C⟫} => {❰B❱}`  
            [説明] 積集合(`∩`(U+2229))は、`トークンのXorの連なり`において、`左項の⟪トークン¦Xor⟫ブロック`と`右項の⟪トークン¦Xor⟫ブロック`の`積集合`を取り、  
                   `その集合のXorの連なり`を返します。  

        - Difference(差集合(`∸`))  
            [表現] `∫LExpress∫¥∸∫LExpress∫`  
            [例] `{⟪A¦B⟫∸⟪B¦C⟫} => {❰A❱}`  
            [説明] 差集合(`∸`(U+2238))は、`トークンのXorの連なり`において、`左項の⟪トークン¦Xor⟫ブロック`と`右項の⟪トークン¦Xor⟫ブロック`の`差集合`を取り、  
                   `その集合のXorの連なり`を返します。  

        - Exclusive(排他集合(`⚺`))  
            [表現] `∫LExpress∫¥⚺∫LExpress∫`  
            [例] `{⟪A¦B⟫⚺⟪B¦C⟫} => {⟪A¦C⟫}`  
            [説明] 排他集合(`⚺`(U+26BA))は、`トークンのXorの連なり`において、`左項の⟪トークン¦Xor⟫ブロック`と`右項の⟪トークン¦Xor⟫ブロック`の`排他集合`を取り、  
                   `その集合のXorの連なり`を返します。  

- line(ライン)  
    "_"はスペース、"\n"は改行コードとする。  
    [表現] `＄recursion＝❰¥❰❰⟦～⟧⟪｡｡∫LToken∫∸⟪_¦\n⟫｡¦｡Ø｡¦｡⟦～⟧⟪_¦\n⟫｡¦｡∫recursion∫｡｡⟫❱¥❱❱`  
    [例]  `{❰_❰A❱_❰&Null❱_\n_B__❱} => {❰_A_\n_B__❱} => {_A_\n_B__}`  
    [説明] ラインは、`トークンブロック`(`❰❱`)と`ヌル`(`Ø`)を除去して一つの文にします。  
    - [詳細]  
        `トークンブロック`を`除去`します。  
        `{❰A❱} => {A}`  
        - `ヌル(Ø)`の`解決`  
            `ヌル`単体か`ヌルの前後に隣接している改行かスペースの連なり`があり`先頭か末尾`に`改行かスペース以外の文字`がある場合、`ヌル`と`隣接している改行とスペースの連なり`を`除去`します。  
            `{Ø} => {}`, `{❰_\n_\nØ_\n❱} => {❰❱} => {}`, `{❰A_\n_\nØ_\n❱} => {❰A❱} => {A}`, `{❰_\n_\nØ_\nB❱} => {❰B❱} => {B}`  
            `ヌル`の`前後に隣接している改行かスペースの連なり`があり`先頭と末尾に改行かスペース以外の文字`がある場合、`ヌル`と`前方の隣接している改行とスペースの連なりのみ`を`除去`します。  
            `{❰A_\n_\nØ_\nB❱} => {❰A_\nB❱} => {A_\nB}`  
        - [例]  
            `{❰_Ø_❰_A_Ø_B_❰_Ø_❱❰_C_❱_D_❱_Ø_E❱}`  
            =>  
            `{❰_Ø_❰_A_Ø_B_❰❱❰_C_❱_D_❱_Ø_E❱}`  
            =>  
            `{❰_Ø_❰_A_B__C__D_❱_Ø_E❱}`  
            =>  
            `{❰_A_B__C__D__E❱}`  
            =>  
            `{_A_B__C__D__E}`  
