`❰\u{2770}❱\u{2771}ˆ\u{2C6}¦\u{A6}≈\u{2248}∫\u{222B}＃\u{FF03}＄\u{FF04}＠\u{FF20}％\u{FF05}＆\u{FF06}⇒\u{21D2}⟪\u{27EA}⟫\u{27EB}`  
`❰❱ˆ¦≈∫＃＄＠％＆⇒⟪⟫！⏎✖｡` //！⏎✖｡追加  [Tab] [Alt] []<=括弧記号考える  
✖⏎//改行とスペース禁止  
❰小括弧❱❰｡中括弧｡❱❰｡｡大括弧｡｡❱ ｡¦｡  ｡はスペース替わりにも使える
拡張BNF…  

トークン(abc)、トークンブロック(❰❱)、変数の代入と変数の展開(＄val＝,∫val∫(変数ブロック(∫∫,∫∫∫)))、
    ブロック演算系(プリプロセス(●),破棄(✖),xor構成系(関数ブロック(⟪a¦b⟫,⟪0~2⟫,⟪⟦a⟧⟦b⟧⟫,⟪#GAFA#⟫),単項演算子(＠,％,⟦,|2～4⟧)),xor集合演算系(⇒,¦¦,∸,⚺,∩,⇔))  
    ブロック演算子{●,¥,＄＝,✖,＠,％,⟦┃～⟧,⇒,¦¦,∸,⚺,∩,⇔}  
抽出変型(【∠⸨⸩】)  
❰&Null❱(null文字)の記号
LOperatorここの説明だけ

基礎([token](#token), [token block](#tokenb)) -> [xorステージ](#xors) -> [xor変換系](#xorc) -> [合成ステージ](#gousei) -> [tagステージ](#tag) -> [variableステージ](#var) -> [`xorとスキップと"∫∫"とlineステージによる構造と評価手順`](#tegyun)  
↑をさらっと読んだほうが分かりやすいかも  

- `{..} => {..}`という表現について  
    `{..} => {..}`という表現は、`{..}`内になんらかの`評価する対象`があり`=>`の`前`が`評価前`を表し、`後`が`評価後`を表す。  
    [例] `{1+2} => {3}`というのは、評価する対象`+`があり、評価前は`1+2`で評価後は`3`である。  
- `[表現]`について
    `[表現]`は`PreProcessの評価後の状態`を表すとし、その項で説明している`メタ文字`の`使われ方を表現`している。

# 言語表現(LanguageExpression)  

- 基礎  
    - Token(トークン) <a id="token"></a>  
        [表現] `●∫LToken∫`  
        [例] `{❰static❱}の{static}, {❰System❰.Object❱❱}の{System,.Object},`  
             `{❰ A B C ❱}の{ A B C }, {⟪肉¦魚⟫}の{肉,魚}, {⟪ans = ⟦1.0⟧ / ⟦2.0⟧⟫}の{ans = ,1.0, / ,2.0}がトークン`  
        [説明] トークンとは、ほぼ任意の文字列。`トークンブロック(❰❱)`または`関数ブロック(⟪⟫)`内でのみ現れる必要がある。  
                ほぼ任意とは、この言語表現(LanguageExpression)を構成する(エスケープされていない)構成文字(❰❱¦＄＝∫などの特殊文字)(メタ文字とも言う)が含まれない文字列。  
        - [詳細]  
            `トークン`とは言語表現によって組み替えたり複製されたりして加工される文字列の事。  
            `fox関数ブロック`内の任意の文字列は変換されるためだけの文字列なのでトークンではない。  

    - ブロック (❰❱,⟪⟫,∫∫,∫∫∫,【∠⸨⸩】)  
        - Token block(トークンブロック) <a id="tokenb"></a>  
            [表現] `{¥❰∫LExpress∫¥❱}`  
            [例] `{❰token0❰token1❰token2❱❱❰token3❱❱}`  
            [説明] トークンブロック(`❰❱`(U+2770,U+2771))はトークンを区切る役割を持つ。  
            - [詳細]  
                `{＠❰token❱}`の`"＠"`や`{❰token0❱¦¦❰token1❱}`の`"¦¦"`は`ブロック演算子`と言い`トークンブロック`に対して作用する。  

        - Function block(関数ブロック)  
            [表現] `{¥⟪⟪＃各関数ブロックの中身＃⟫¥⟫}`  
            [例] `Xor: {⟪A¦B⟫}, Index: {⟪2～4⟫} => {⟪2¦3¦4⟫}, Sequence: {⟪⟦A⟧⟦B⟧⟫} => {⟪AB¦BA⟫}, Fox: {⟪＃五影＃⟫} => {⟪火影¦風影¦土影¦水影¦雷影⟫}`  
            [説明] 関数ブロック(`⟪⟫`(U+27EA,U+27EB))は、トークンまたは数値を引数に新しい`Xorブロック`または`トークンブロック`を`生成して返します`。  
                   関数ブロックの種類は`Xor(¦)`,`Index(～)`,`Sequence(⟦⟧)`,`Fox(＃)`があります。  

        - Variable block(変数ブロック)  
            [表現] `⟪¥∫¦¥∫¥∫⟫●∫LToken∫¥∫`  
            [例] `{∫val∫} => {⟪A¦B⟫}, {∫∫val∫} => {❰A❱}`  
            [説明] 変数ブロックは、`同期変数ブロック`(`∫∫∫`)と`非同期変数ブロック`(`∫∫`)があり、評価するとその位置に代入された`∫LExpress∫`を展開する。  
        
        - Extract hakai block(抽出破壊ブロック)  
            【∠⸨⸩】やばいやつ  

    - Block operator(ブロック演算子)  
        [表現] `{●∫LUnaryOperator∫｡∫LExpress∫}, {∫LExpress∫｡●∫LBinaryOperator∫｡∫LExpress∫}`  
        [例] `{＠❰A❱} => {⟪A¦❰＆Null❱⟫}, {✖⟪A¦B⟫} => {❰＆Null❱}, {⟪A¦B¦C⟫⇒⟪A¦B⟫} => {⟪A¦B⟫}, {⟪A¦B¦C⟫∩⟪B¦C¦D⟫} => {⟪B¦C⟫}`  
        [説明] ブロック演算子には、`ブロック単項演算子`と`ブロック2項演算子`があります。  
               ブロック演算子は、`ブロック`に作用し、新しい`Xorブロック`または`トークンブロック`を`生成して返します`。  
               ブロック単項演算子は`プリプロセス(●)`,`代入演算子(＄＝)`,`破棄(✖)`,`オプション(＠)`,`デフォルト(％)`,`量化(⟦┃～⟧)`があります。  
               ブロック2項演算子は`インプ(⇒)`,`和(¦¦)`,`差(∸)`,`排他(⚺)`,`積(∩)`,`同値(⇔)`があります。  
               `ブロック単項演算子`は`左から作用`します。  

    - ブロック単項演算子の合成則 <a id="gousei"></a>  
        [表現] `●❰⟦2～⟧∫LUnaryOperator∫❱｡∫LExpress∫`  
        [例] `{⟦～⟧＠❰A❱} ⇔ {⟦～⟧❰＠❰A❱❱}`  
        [説明] `ブロック単項演算子`が`トークンブロックの左側`に`連続して並んでいる`とき`トークンブロック`で`区切って作用`させるのと同じになります(`右結合`)。  

    - 関数ブロックとブロック演算子の評価順序と結合規則  
        評価順序は、  
            [`代入演算子(＄＝)(非同期の代入)`] => [`Xor(¦)以外のブロック`] => [`代入演算子(＄＝)以外のブロック単項演算子`] =>  
            [`インプ(⇒)`] => [`和(¦¦)`] => [`差(∸)`] => [`排他(⚺)`] => [`積(∩)`] => [`同値(⇔)`] => [Xor(¦)] =>  
            [`代入演算子(＄＝)(同期の代入)`] => [ライン]  
        となります。  
        結合規則は、`ブロック単項演算子`は`右結合`、`ブロック2項演算子`は`左結合`です。  

        評価順序を変えたい場合はトークンブロック(`❰❱`)で囲むことにより変えることができます(数学の`()`と同じ様に)。  
        `{✖❰A❱¦¦❰B❱} => {❰＆Null❱¦¦❰B❱} => {⟪❰＆Null❱¦❰B❱⟫} => {❰B❱}`, `{✖❰❰A❱¦¦❰B❱❱} => {✖⟪❰A❱¦❰B❱⟫} => {❰＆Null❱}`  

    - 補助機能  
        - Comment(コメント)  
            [表現]`{¥｢⟪＃任意の文字列＃⟫¥｣},{¥｢⟪＃任意の文字列＃⟫}`   
            [例] `{｢コメント｣} => {}, {｢コメント   \\n} => {}` (`\\n`は改行コード)  
            [説明] コメント(`｢｣`(U+FF62,U+FF63))はC言語と同じで`//`は`｢`と同じで、`/**/`は`｢｣`と同じ。  

        - Escape(エスケープ)  
            [表現] `{¥¥⟪＃メタ文字＃⟫}`  
            [例] `{¥＠}, {¥∫¥∫val¥∫}`  
            [説明] エスケープ％❰演算子❱(`¥`(U+00A5))はC言語のエスケープ文字`\`と同じで`メタ文字`を`トークン`にする。  

        - Space character(スペースキャラクタ)  
            [表現] `⟪＃任意の文字列＃⟫¥｡⟪＃任意の文字列＃⟫`  
            [例] `{ldc⟪❰｡｡❰.i4❱＠⟪｡❰.⟪0~8⟫❱¦.m1¦.s｡⟫｡｡❱¦.i8¦.r4¦.r8⟫} => {ldc⟪❰❰.i4❱＠⟪❰.⟪0~8⟫❱¦.m1¦.s⟫❱¦.i8¦.r4¦.r8⟫}`  
                 `{＄Method＝⟪∫Normal_method∫｡¦｡∫Instance∫｡¦｡∫Static∫｡¦｡∫part_method∫｡¦｡∫Interface_method∫｡¦｡∫expr_method∫｡¦｡∫Tructor∫⇒⟪∫cctor∫¦∫ctor∫¦∫Finalize∫⟫｡¦⏎`  
                 `｡∫Prodexer∫⇒⟪∫Property∫¦∫Indexer∫⟫｡¦｡∫Iterator∫｡¦｡∫Extension∫｡¦｡∫Operator∫⟫} =>`  
                 `{＄Method＝⟪∫Normal_method∫¦∫Instance∫¦∫Static∫¦∫part_method∫¦∫Interface_method∫¦∫expr_method∫¦∫Tructor∫⇒⟪∫cctor∫¦∫ctor∫¦∫Finalize∫⟫¦⏎`  
                 `∫Prodexer∫⇒⟪∫Property∫¦∫Indexer∫⟫¦∫Iterator∫¦∫Extension∫¦∫Operator∫⟫}`  
            [説明] スペースキャラクタ(`｡`(U+FF61))は、`{｡} => {}`となり、ただ消えるだけで何もしません。スペースを`｡`で作って分かりやすさのために使います。  
                  通常のスペース` `は、`{ } => { }`となり` `は消えません。  
                  つまり、` `は`{⟪ A ¦ B ⟫} => {⟪ A ¦ B ⟫} => { A }`ですが、`｡`は`{⟪｡A｡¦｡B｡⟫} => {⟪A¦B⟫} => {A}`となります。  

- variable(変数) <a id="var"></a>  
    [表現] (定義と代入)`¥＄●∫∫LToken∫¥＝∫LExpress∫`  
          (変数の使用)`⟪¥∫¦¥∫¥∫⟫●∫∫LToken∫❰¥∫❱`  
    [例] (定義と代入)`{＄val＝⟪A¦B⟫} => {⟪A¦B⟫}`, (変数の使用)`{∫val∫} => {⟪A¦B⟫}`  
    [説明]  `代入％❰演算子❱`(`＄＝`(U+FF04,U+FF1D))は、変数に`∫LExpress∫`を代入できる。  
            `同期変数％❰ブロック❱`(`∫∫∫`(U+222B))と`非同期変数％❰ブロック❱`(`∫∫`)(まとめて`変数％❰ブロック❱`)は、それが使われた位置に代入された`∫LExpress∫`を展開できる。 
    - [詳細]
        (定義と代入)`{＄val＝⟪A¦B⟫} => {⟪A¦B⟫}`
        `val`は定義された変数名でそれに`⟪A¦B⟫`を代入している。`＄val＝`の部分は評価すると消えるだけで右側の`⟪A¦B⟫`になんの影響も与えない。  
        (変数の使用)`{∫val∫} => {⟪A¦B⟫}`
        `∫val∫`の様に変数名を`∫`で囲むとその位置に代入された`⟪A¦B⟫`を展開する。
        - `∫∫∫`の`同期変数ブロック`と`∫∫``非同期変数ブロック`の違い  
            とりあえず`val`を`＄val＝⟪A¦B⟫`の様に代入する。  
            このとき、`∫val∫`と書くと、その位置に`⟪A¦B⟫`が展開される。  
            そして、`∫∫val∫`と書くと大元の`⟪A¦B⟫`が`❰A❱`と決定されると`∫∫val∫`の展開も`❰A❱`となる。同様に`❰B❱`と決定すると展開も`❰B❱`となる。  
            つまり、`❰∫val∫_∫val∫❱`と書くと`❰A_B❱`となるパターンがあり`∫val∫`と`∫val∫`の結果が違う事がありえるが、  
            `❰∫∫val∫_∫∫val∫❱`の場合は一つの大元の`⟪A¦B⟫`の決定により`❰A_A❱`か`❰B_B❱`しかありえない。  
        - `∫∫∫`の`同期変数ブロック`は展開が`❰&Null❱`になる事がある。  
            とりあえず、`val`を`⟪＄val＝❰A❱¦❰B❱⟫`と言う状況で代入する。  
            このとき、`⟪＄val＝❰A❱¦❰B❱⟫`が`❰B❱`に決定して、`＄val＝❰A❱`が選択されなかった場合は、
            `∫∫val∫`は`❰&Null❱`になります。`∫val∫`の場合は`❰A❱`になります。
        - いくつか組み込みで変数を定義している。(Lから始まる)  
            `$LToken=❰#ブロック演算子を含んでいない文字列(空集合は含まない)#❱ ❰/:原子論理式のようなもの`  
            `$LExpress=❰#ブロック演算子による操作を含むかもしれない文字列(空集合は含まない)#❱ ❰/:論理式のようなもの`  
            //↓の３つは組み込みから外すここの説明用なのでここの先頭で定義する。===================================================  
            `＄LOperator=❰#全てのブロック演算子(●,＄＝,✖,＠,％,⟦┃～⟧,⇒,¦¦,∸,⚺,∩,⇔)#❱ ❰/:論理演算子のようなもの`  
            `＄LUnaryOperator＝⟪＃全てのブロック単項演算子(●,＄＝,✖,＠,％,⟦┃～⟧)＃⟫`  
            `＄LBinaryOperator＝⟪＃全てのブロック2項演算子(⇒,¦¦,∸,⚺,∩,⇔)＃⟫`  
            `$LIndex=#lit❰#自然数#❱`//ボツ    
            `$LAny=❰#対象言語でその位置に出現可能な全てのトークン#❱`  

- ブロック演算系  
    - PreProcess(プリプロセス)  
        [表現]  `{●⟪＃ブロック＃⟫}`  
        [例] `{●⟪¥＠¦¥✖⟫}, {●❰＠❰¥¥❱❱}`  
        [説明] プリプロセス％❰演算子❱(`●`(U+25CF))は`ブロック`に作用し作用していない部分よりも先に評価される。  
               つまり、`{●⟪¥＠¦¥✖⟫⟪A¦B⟫} => {❰¥✖❱⟪A¦B⟫} => {¥✖⟪A¦B⟫}`となる。  

    - Destruction(破棄)  
        [表現] `¥✖∫LExpress∫`  
        [例] `{✖❰A❱} ⇒ {❰＆Null❱}`  
        [説明] 廃棄％❰演算子❱(`✖`(U+2716))は`ブロック`を`破棄`します。  
        - [詳細]  
            `{✖∫LExpress∫} ⇒ {❰＆Null❱}`  
            `✖`は`ブロック`に作用すると`❰＆Null❱`になります。  

    - Xor構成系 <a id="xorc"></a>  
        - Xor <a id="xors"></a>  
            [表現] `¥⟪⟦¥¦┃2～⟧∫LExpress∫¥⟫`  
            [例] `{⟪A¦B⟫} => {{❰A❱}または{❰B❱}}`｢`⟪A¦B⟫`という`Xorブロック`から、`❰A❱`というトークンブロックを返す または `❰B❱`というトークンブロックを返します。  
            [説明] Xor％❰ブロック❱(`¦`(U+00A6))は、`与えられたトークン`から`一つ選び`トークンブロックを生成して返します。  
            - [詳細]  
                このXorブロックは言語表現(LanguageExpression)の中で`一番重要で中心的な処理`である。  
                `与えられたトークン`から`一つ選び`ますが、`どう選ぶかは定義しません`。  
                ただ、`⟪A¦B⟫`という文から`❰A❱`が選ばれる`可能性`もあるし、`❰B❱`が選ばれる`可能性`もある。と考えてください。  

        - Option(オプション)  
            [表現] `¥＠∫LExpress∫`  
            [例] `{＠❰A❱} => {⟪A¦❰&Null❱⟫}, {＠⟪A¦B⟫} => {⟪A¦B¦❰&Null❱⟫}`  
            [説明] オプション％❰演算子❱(`＠`(U+FF20))は、ブロックに`❰&Null❱`が選択される可能性を`Xor`で足します。  

        - Default(デフォルト)  
            [表現] `¥%∫LExpress∫`  
            [例] `{％❰A❱} => {⟪A¦❰&Null❱⟫}, {％⟪A¦B⟫} => {⟪A¦B¦❰&Null❱⟫}`  
            [説明] デフォルト(％(U+FF05))は、Optionと全く同じ処理をします。  
            - [詳細]  
                `オプション`と`デフォルト`の`違い`は、メタ的な事柄によるものになります。  
                この言語表現(LanguageExpression)は、大抵の場合、対象となる`モデル`(大体はプログラミング言語かな)が存在すると思います。  
                その中で、`あるトークン`が`明記していなくても、明記したのと変わらない事を示す`ために`デフォルト`が使われます。  
                - [考え方]  
                    [具体例] `私は％❰｡｡⟪％❰財布から❱¦口から⟫⟪100円¦400円⟫を出して｡｡❱買った。`, `class C{％❰private❱ int n;}`  
                    この様に書かなくてもわかる事やプログラミング言語的に決められている事に対して効果があります。  
                    `＠⟪％❰A❱¦B⟫`の様に`Xorブロック内`で使われた場合、`❰&Null❱`であったとしてもモデルの中では`❰A❱`であることを示す。  

        - indexステージ  (～)//アスキーコード並び替え❰.⟪0~8⟫❱=======================❰1～3❱ => `⟪1～3⟫`
            [表現] `\❰@❰∫ˆn0❱\~@❰∫ˆn1❱\❱ $n0=ˆ$n1=❰∫∫ˆLIndex❱`   
            [例] `❰1~3❱ ⇒ ❰1¦2¦3❱`  
            [説明] "[表現]"の様な形を`indexブロック`と言い、0~∞のまでの添字を生成する。(indexブロックは`トークンブロック扱い`)  
            - [詳細]  
                `❰~2❱ ⇒ ❰0~2❱ ⇒ ❰0¦1¦2❱`  
                //開始の数字を省略すると`0~`になります。  
                `❰2~❱ ⇒ ❰2~∞❱ ⇒ ❰2¦3¦4¦..❱`  
                //終了の数字を省略すると`~∞`になります。  
                `❰~❱ ⇒ ❰0~∞❱ ⇒ ❰0¦1¦2¦..❱`  
                //両方の数字を省略すると`0~∞`になります。  

        - 量化ステージ ⟪⟫ => ⟦⟧ ⟦,┃1～⟧❰｡＠⟪in ¦out ⟫∫Type∫⇒∫Gene∫｡❱ `｢＄n＝⟪2～⟫｣⟦┃∫∫n∫┃⟧❰\❰❱∫LExpress∫⟦┃∫∫n∫┃⟧❰\❱❱`量化である事を特徴ずけるため`┃`か`～`が存在する必要がある
            [表現] `\⟦&0@❰\❰❰∫ˆDelimiter❱\❱❱&0@❰,❱@❰∫ˆn0❱\~@❰∫ˆn1❱\⟧\❰❰∫ˆLExpress❱\❱`    
                    `❰/:$Delimiter=#lit❰#区切り文字⊂∫LToken#❱, $n0=ˆ$n1=❰∫∫ˆLIndex❱`  
            [例] `{⟦❰,❱,1~3⟧❰A❱} ⇒ {❰❰❰A❱❱¦❰❰A❱❰,❱❰A❱❱¦❰❰A❱❰,❱❰A❱❰,❱❰A❱❱❱}`  
            [説明] `⟦❰,❱,1~3⟧`の部分を`量化演算子`と言い、`❰A❱`を区切り文字`❰,❱`を挟んで`1~3`回繰り返す。  
                    そして、各xorの間と評価結果の始まりから終わりまでをトークンブロックで囲う。  
            - [詳細]  
            `{⟦❰,❱,1~3⟧❰A❱} ⇒ {❰❰❰A❱❱¦❰❰A❱❰,❱❰A❱❱¦❰❰A❱❰,❱❰A❱❰,❱❰A❱❱❱}`  
            //❰,❱は区切り文字となり、1~3は1回,2回,3回の繰り返しのパターン全てをxorで繋げる。  
            `{⟦❰❰_¦,❱❰/❱❱,2~2⟧❰A❱} ⇒ {❰❰A❱❰❰_¦,❱❰/❱❱❰A❱❱}`  
            //区切り文字はトークンブロックなのでそのままトークンブロックが区切り文字として挿入される  
            `{⟦2~4⟧❰A❱} ⇒ {❰❰❰A❱❰A❱❱¦❰❰A❱❰A❱❰A❱❱¦❰❰A❱❰A❱❰A❱❰A❱❱❱}`  
            //区切り文字を省略して無くすことができる。  
            `{⟦~4⟧❰A❱} ⇒ {❰❰❰&Null❱❱¦❰❰A❱❱¦❰❰A❱❰A❱❱¦❰❰A❱❰A❱❰A❱❱¦❰❰A❱❰A❱❰A❱❰A❱❱❱}`  
            //~4として開始回数を省略すると0~4の意味となり0回から繰り返しが開始される  
            `{⟦2~⟧❰A❱} ⇒ {❰❰❰A❱❰A❱❱¦❰❰A❱❰A❱❰A❱❱¦..❱}`  
            //2~として終了回数を省略すると2~∞の意味となり繰り返しが無限に続く  
            `{⟦~⟧❰A❱} ⇒ {❰❰❰&Null❱❱¦❰❰A❱❱¦❰❰A❱❰A❱❱¦..❱}`  
            //~とすると0~∞の意味となり0回から繰り返しが無限に続く  
            `{⟦❰,❱,~⟧❰A❱} ⇒ {❰❰❰&Null❱❱¦❰❰A❱❱¦❰❰A❱❰,❱❰A❱❱¦..❰,❱❰A❱❱❱}`  
            //繰り返しが無限の時に区切り文字が指定されても無限に続く最後は❰A❱で終わる  
        
        - Sequenceステージ //[]を⟪⟫にする？ ⟪⟫ => ⟦⟧, ❰¦⟪1⟫ ⟪op¦+⟫ ⟪2⟫ ⟪op¦*⟫ ⟪3⟫¦❱ => `⟪ans = ⟦1⟧ ⟦op：+⟧ ⟦2⟧ ⟦op：*⟧ ⟦3⟧⟫`==========  
            [表現] `\❰\¦＃1⟪1~⟫❰∫ˆLExpress¦\⟪∫ˆLExpress\⟫¦\⟪∫ˆLToken\¦∫ˆLExpress\⟫❱\¦\❱`  
                    `❰/;＃1:"⟪∫ˆLExpress⟫"または"⟪∫ˆLToken¦∫ˆLExpress⟫"が１つ以上出現すること`  
            [例] `❰¦⟪1⟫ + ⟪2⟫ * ⟪3⟫¦❱ ⇒ ❰1 + 2 * 3¦1 + 3 * 2¦2 + 1 * 3¦2 + 3 * 1¦3 + 1 * 2¦3 + 2 * 1❱`  
            [説明] `❰¦`から`¦❱`をsequenceブロックと言い、複数の`⟪∫ˆLExpress⟫`の並び替えた全ての結果をxorする。(`[例]`の場合は3!=6個の並び替え)  
            - [詳細]  
                `❰¦⟪1⟫ ⟪op¦+⟫ ⟪2⟫ ⟪op¦*⟫ ⟪3⟫¦❱ ⇒ ＃1❰1 + 2 * 3¦1 + 3 * 2¦2 + 1 * 3¦2 + 3 * 1¦3 + 1 * 2¦3 + 2 * 1¦`  
                                                `1 * 2 + 3¦1 * 3 + 2¦2 * 1 + 3¦2 * 3 + 1¦3 * 1 + 2¦3 * 2 + 1❱`
                                                `❰/;＃1:実際は改行しない`  
                //`[∫ˆLToken¦∫ˆLExpress]`とする事で、同じ`∫ˆLToken`同士で並び替えする事ができる(この場合は3!*2!=12個の並び替え)  
                    //¦を：にする?  

        - foxステージ  
            [表現] `\⟪\#❰∫ˆLToken❱\#\⟫`   ❰#GAFA#❱ => `⟪#GAFA#⟫`
            [例]  `{❰#π#❱} ⇒ {❰3.141592653589793238462643383279502884197169399375105820974944592307..❱}`  
            [説明] `❰#`から`#❱`を`foxブロック`と言い、(foxブロックは`トークンブロック扱い`)  
                    明確な意味がある、文字列で表現可能な言葉を`❰#`と`#❱`囲むと、それに対するxor変換系以下のステージによる操作を返す。
                    ~~(ｲﾝﾁｷ臭いステージである)~~  
            - [詳細]  
                `{❰#GAFA#❱} ⇒ {❰google¦amazon¦facebook¦apple❱}`  
                `{❰#ウニの数え方#❱} ⇒ {❰❰1~❱❰壺¦個¦腹¦匹❱❱}`  
                //あいまいになるほど他人との共通の認識を持つことは難しい。  
                //自分のみ理解していればいいのであれば何でもいいと思う。  

    - xor集合演算系
        - impステージ  //ここからxorステージ節の終わりまでただのxorの絞り込みなのでxorステージより前に行われるべきだと思う
                                                                    - //xor⟪a¦b⟫という表現とxorの処理は別として後で処理されると考える
            [表現] `\❰#1❰∫ˆLExpress❱\❱⇒\❰#2❰∫ˆLExpress❱\❱ ❰/;ただし#2は#1のLExpress内の選択で出現しうるもの`  
            [例] `{❰A¦B¦C❱⇒❰A¦B❱} ⇒ {❰A¦B❱}`  
            [説明] impステージは`このステージに到達した時`、`"⇒"(ならば)`の`右側のトークンブロックが左側のトークンブロックのxorの部分的な選択になっているか検証`し、  
                なっていればこのステージを`通過`でき、なっていなければエラーになり処理が`失敗`します。  
                `左側のトークンブロックは`右側が左側の部分的な選択になっているかのみに使用され`評価後は削除`されます。  
                左側について右側を検証するだけなので`このステージは何もしません`。(検査するために網羅はする)  
                //スキップ使いたくない..
            - [詳細]
                `{❰A¦B❱⇒❰A❱} ⇒ {❰A❱}`  
                //`"⇒"`の左側のトークンブロック(`❰A¦B❱`)は削除されます。  
                `{❰A¦B¦C❱⇒❰A¦B❱⇒❰A❱} ⇒ {❰A¦B❱⇒❰A❱} ⇒ {❰A❱}`  
                //`"⇒"`は左結合です。  
                `{❰A¦❰B¦C❱❱⇒❰B¦C❱⇒❰C❱} == {❰A¦❰B¦C❱❱⇒❰C❱}}`  
                //xorの入れ子に対しても抜き出せます。あと`"⇒"`は論理学の"⇒"と同じ推移律が成り立つようです。  
                `{❰❰A¦B❱⇒❰A❱ ❰C¦D❱❱} ⇒ {❰❰A❱ ❰C¦D❱❱}`  
                //もちろんトークンブロック内でも使えます。  
                `X:{❰❰A¦B❱⇒❰A❱ ❰C¦D❱❱⇒❰❰B❱ ❰C❱❱} ⇒ {❰❰A❱ ❰C¦D❱❱⇒❰❰B❱ ❰C❱❱}`  
                //`"⇒"`はトークンブロックの入れ子の中から評価され、抜き出せない状態になる事もあります。  
                `{@❰A❱⇒❰A❱} ⇒ {❰A¦&Null❱⇒❰A❱} ⇒ {❰A❱}`  
                //`"⇒"`の左側のオプション(`@`)はimpステージに到達する前に`❰A¦&Null❱`に展開されるので処理できます。  
                `{@❰A❱⇒not❰A❱} ⇒ {❰A¦&Null❱⇒❰&Null❱} ⇒ {❰&Null❱}`  
                //同様に右側の`not`はimpステージに到達する前に`❰&Null❱`に展開されるので処理できます。  
                `{❰❰A¦B❱¦C❱⇒❰$val=❰A¦B❱❱ ∫val∫ ∫∫val∫} ⇒　{❰❰A¦B❱¦C❱⇒❰A¦B❱ ❰A¦B❱ ∫∫val∫} ⇒ {❰A¦B❱ ❰A¦B❱ ∫∫val∫} ⇒ {❰A❱ ❰B❱ ❰A❱}(❰A¦B❱の１つ目が"A"２つ目が"B"が選択された場合)`  
                //同期変数演算子`"∫∫"`はimpステージ後に評価されますが`$val=`の部分はimpステージ前に消えるので使えます。  
                `X:{❰A¦B¦C❱⇒❰&0ˆA¦B❱}`  //許す？========================================================================================
                //`&0`は`スキップステージ`のセレクトフラグ変数で`impステージ後に評価`されるのでimpステージに到達しても`&0`は無くならず、  
                //右側は左側の部分にならず処理が失敗します。(`スキップステージ`以外のステージ内演算子なら、impステージかそれより前に評価されるので大丈夫です)  
                `O:{❰&0ˆA¦B¦C❱⇒❰&0ˆA¦B❱} ⇒ {❰&0ˆA¦B❱}`  
                //`&0`が付いているもの(まだ処理されてないもの)をそのまま抜き出すなら問題ありません。  
                `{$body=❰#身長❰小人¦大人❱, #胸❰絶壁¦小玉メロン❱, #体型❰干物¦❰普通¦熱盛❱❱❱}`  
                `{∫body∫⇒❰❰小人¦大人❱, ❰小玉メロン❱, ❰普通❱❱}`  
                //変数の内部を制約できます。  
                `{❰#あにまる#❱⇒❰#ほにゅうるい#❱⇒❰#れいちょうるい#❱⇒❰#にんげん#❱⇒❰#にほんじん#❱⇒❰#わい#❱}`  
                //xor変換系を通過しているのでfoxはxorで構成されています。  
                `{{~}❰あんぱん❱⇒❰❰あんぱん❱❰あんぱん❱❰あんぱん❱❰あんぱん❱❰あんぱん❱❰あんぱん❱❰あんぱん❱❰あんぱん❱❰あんぱん❱❰あんぱん❱❰あんぱん❱❰あんぱん❱❱}`  
                //あんぱん、抜き出せます。  
                `{❰¦[う][こ][ん]¦❱⇒❰うんこ❱}`  
                //はぁ…(呆れ)  
                `O:{∫Type∫⇒❰int❱} ⇒ {❰byte¦int¦char❱⇒❰int❱} ❰/:$Type=❰bool¦int¦char❱`  
                //非同期変数演算子は`impステージの前で評価`されるので使えます。  
                ~~`X:{∫∫Type∫⇒❰int❱}`~~  
                ~~//同期変数演算子は`impステージの後で評価`されるのでxorで構成されたトークンブロックを`表現できず評価できません`。~~
                    O:`∫∫v∫..❰＄v=❰..❱❱..`, X:`＄v=❰..∫∫v∫..❱`, X:`{＄v=..∫∫w∫..}, {＄w=..∫∫v∫..}`//∫..∫(非同期変数)は◯  
                    //同期変数は再帰的になっていなければ使える  
                `{❰&aˆA¦B❱⇒❰&aˆA❱} {{❰&[a]C¦D❱} ⇒ {❰&[a]C❱}}の選択のみを通す`  
                //セレクトフラグ変数が付いているトークンを抜き出した場合、それが選択されたものとします。(&a=True)  
                //逆にそれを抜き出さなかった(`{❰&aˆA¦B❱⇒❰B❱}`)の場合、それが選択されなかったのもとします。(&a=False)  
        - 差集合ステージ∸  
            - `{❰A¦B❱∸❰A¦C❱} ⇒ {❰B❱}`//左側の網羅の集合と右側の網羅の集合の積集合を左側の網羅の集合から取り除き取り除かれた左側の網羅の集合を出力する  
            - `＄Xor=❰∫XS∫¦∫XS∫❱ ＄Sub=❰∫XS∫∸∫XS∫❱ ＄XS=❰∫Sub∫¦∫Xor∫❱`//差集合した結果はxorで表現可能。つまり差集合した結果にxorを適用することができる    
            - `∫XS∫∸❰∫XS∫¦∫XS∫❱¦❰❰∫XS∫∸❰❰∫XS∫∸∫XS∫❱¦❰∫XS∫¦∫XS∫❱❱∸∫XS∫❱∸❰∫XS∫¦∫XS∫❱❱`//既に示した通りxorの結果から差集合することができる。つまりxorと差集合の入れ子構造が可能。  
            - //xorと差集合が入れ子になる場合は入れ子の中から処理される
        - 積集合ステージ(考えまとめ)  
            - `{❰A¦B❱∩❰B¦C❱} ⇒ {❰B❱}`//積集合をとるステージ。xor,差集合,impと同列  
            - `❰A¦B❱`//xor  //これは次のステージで処理される
            - `❰A❱¦¦❰B❱`//ブロックではない版 //他の演算子と同じ形式にすると思えばアリかな  
            - `❰A❱∩❰B❱`//積集合  
            - `❰A❱∸❰B❱`∠ //差集合 `❰A❱`から`❰B❱`を除外する  
            - `❰A❱⚺❰B❱`//排他的論理和  
            - `❰A❱⇒❰B❱`∠ ⊃ //imp boolを返す。パスするかしないか決める それと同期するかしないか
            - `❰A❱⇔❰B❱`//同値      boolを返す。パスするかしないか決める
            - これはまた別`❰A❱≪❰B❱`∠ //破壊 `❰⸨∫name∫⸩❱≪❰⟪≪❰＃定義元のinterface名＃❱.≫∫name∫⟫❱`//`≪`は左側の`⸨⸩`の部分を破壊的に拡張できる。  
            - `❰A❱⟦if⟧~⟦end⟧`//条件編集//`❰A❱∠⟦if⟧~⟦end⟧`予定  
            - 全て同列。  
            
            - 機能的な事  
                - `⸨⸩と⟪⟫は二項演算子の左項が⸨⸩で右項が⟪⟫で分かりやすく表しているだけだっけ?..`
                - `❰｡⸨∫ab∫⸩∸⸨∫ab∫⸩ C｡❱`の`⸨~⸩∸⸨~⸩`の`"∸"`は任意のトークン＠❰ブロック❱が存在する可能性を示している。両端(`"❰"~"❱"`)も`"∸"`は無いが`"∸"`があるものとする  
                - `∫v∫∠❰⸨∫A∫⸩❱∩❰⟪∫w∫∠❰⸨∫B∫⸩❱⚺❰⟪∫C∫⟫❱⟫❱`//`❰⸨被数⸩❱*❰⟪数⟫❱`という制約がある(複雑を避ける(という事にして置く..))  
                - `{＄abc'''=❰∫abc''∫∠❰＠⸨∫ab∫⸩∸⸨∫ab∫⸩ C❱⇒❰⟪A⟫⟪B⟫❱❱} `//`∠`は部分的に⇒を適用している  
                - `❰ABC❱∠❰⸨AB⸩❱≪❰⟪≪ab≫⟫❱`//トークンよりも細かい文字単位で位置を示せる(しかしトークンブロックをまたがない事)  
                - `❰❰❰A¦B❱C❱D❱∠❰⸨❰❰A¦B❱C❱∠❰C❱⸩❱⇒❰⟪..⟫❱`//`⸨⸩`内で`∠`を使うことでさらに絞った位置を示せる。(`∠`はファイルシステムの`/`のような)  
                - `~~⟦if⟧❰A¦B❱⇒❰A❱⟦then⟧❰C❱⟦else⟧❰D❱⟦end⟧~~`//`⟦if⟧❰..❱⇒❰..❱❰⟦then⟧¦⟦else⟧❱❰..❱⟦end⟧`として`⟦if⟧`の条件で処理を分岐できる。(後で`⟦if⟧`まとめる)  
                    `⟦if⟧~`は条件によって~~一つの文を返すか、~~一つの文を編集した一つの文を返す(xorで繋げていない)  
                    `❰..❱⟦if⟧⟦this⟧∠❰⸨..⸩❱⇒❰⟪..⟫❱⟦then⟧⟦this⟧∠❰⸨⸩❱..⟦end⟧` //`⟦this⟧`は`⟦if⟧`の左側を指している。(式木として繋がっているなら`⟦this⟧`必項(常に必項かも..なら`⟦this⟧∠`を省略できるな..)  
                    //`⟦if⟧⟦this⟧∠❰⸨n0⸩❱⇒❰⟪..⟫❱..`というふうに位置を条件に使うと位置によって`⸨n0⸩`は`∫n0∫⇒∫n1∫⇒∫n2∫..`という関係からいろんなパターンがありえる。(↓法則参照)  
                        多分位置は`⸨..⸩`以外意味がないので`＠⸨..⸩`,`●⸨..⸩`は禁止。(`⟦if⟧❰⸨..⸩❱⟦then⟧❰⸨..⸩❱⟦else⟧❰⸨..⸩❱⟦end⟧`のそれぞれの`⸨..⸩`は位置が被ってはいけない)  
                - `❰⸨~⸩∸＠⸨~⸩..keyword_⸨~⸩❱⇒❰⟪~⟫⟪~⟫..⟪~⟫❱`//左側だけトークン＠❰ブロック❱を入れられ場所の目印にできる  
                - `..∠●∫v∫●`//`∠`の後に一つだけ文字かトークン＠❰ブロック❱を置き`●`で囲むとそのものが存在する網羅でそのものだけ返せる(`..∠❰●⸨∫v∫⸩●　~❱`の方がいいかも..)  
                - `{❰A¦B¦C❱∠❰●⸨B⸩❱≪❰⟪≪E≫⟫❱}`//`●⸨~⸩`とすることでxorの網羅から`~`が存在するもののみを通す(位置と範囲)(`⇒`としたかったが紛らわしいので`●`にした)  
                    `＠⸨@位置⸩∸⸨位置⸩∸●⸨位置と範囲⸩∸＠●⸨@(位置と範囲)⸩`  

            - 法則的な事(`[∠]`,`[⇒,∸,..]`,`[＄]`)//基本的にxorの網羅した集合同士の演算  
                - O:`∫∫v∫..❰＄v=❰..❱❱..`, X:`＄v=❰..∫∫v∫..❱`, X:`{＄v=..∫∫w∫..}, {＄w=..∫∫v∫..}`//∫..∫(非同期変数)は◯  
                - `{＄abcd=❰｡＄ab=❰A¦B❱ ∫ab∫ ❰C¦D❱｡❱}, {＄abc=∫abcd∫⇒❰｡❰A¦B❱ ❰A¦B❱ C｡❱}, {∫abc∫⇒❰｡⸨∫ab∫⸩ C｡❱⇒❰⟪B⟫❱} ⇒ {❰❰A¦B❱ B C❱}`  
                    //`∫abc∫`に`∫ab∫`は無いが`∫abc∫`を定義した時に使った`∫abcd∫`内に`＄ab`と`∫ab∫`があり、かつ`C`が右側にあると言う情報から位置を特定することができる  
                        `{＄abc'=❰∫ab∫ C❱}, {＄abc''=❰∫abc∫¦∫abc'∫❱}, {＄abc'''=❰∫abc''∫∠❰｡＠⸨∫ab∫⸩∸⸨∫ab∫⸩ C｡❱⇒❰⟪A⟫⟪B⟫❱❱} ⇒ {∫abc'''∫ == ❰｡❰A B C❱¦❰B C❱｡❱}`  
                        //`∫abc''∫⇒❰｡＠⸨∫ab∫⸩∸⸨∫ab∫⸩ C｡❱⇒❰⟪A⟫⟪B⟫❱`は`∫abc''∫`を網羅してその中の一つのパターンで`＠⸨~⸩`が存在しないパターンも通せる  
                - //`..＄n2=❰∫n1∫⇒❰~❱❱,＄n1=❰∫n0∫⇒❰~❱❱ == ∫n0∫⇒∫n1∫⇒∫n2∫..`という関係なら  
                    //`a<b`として`∫nb∫`内の`要素(word0 wrod2..)`は`∫na∫`内の`∫変数∫(トークンブロックでもいいかも(❰word0¦word1❱))`で`⸨位置⸩`を示せる  
                - `{＄v=∫obj∫∠❰⸨∫proc0∫⸩❱⇒❰⟪e⟫❱∠❰⸨∫proc1∫⸩❱∸..∠❰⸨∫proc2∫⸩❱..} ⇒ {＄v=∫obj∫.⸨proc0⸩.⸨proc1⸩.⸨proc2⸩}`  
                    //`❰..❱∠..∠..`と続くのは`❰..❱`がLinqのように加工されていくイメージ。(`(((❰..❱∠..)∠..)∠..)`左結合的)  

- スキップステージ(せっかく作ったけどボツかも)  
    [表現] (セレクトフラグ変数演算子)`\&&0@❰#idˆ∫ˆLToken❱&1@❰-❱&0@❰#idˆ∫ˆLIndex❱\❰❰∫ˆLExpress❱\❱`  
            (パス条件演算子)`\&\[❰∫ˆcondition❱\]\❰❰∫ˆLExpress❱\❱ ❰/:$condition=❰#セレクトフラグ変数との論理演算#❱ (パス条件参照)`  
            (セレクトフラグ変数とパス条件演算子)`{~}❰\&&0@❰#idˆ∫ˆLToken❱&1@❰-❱&0@❰#idˆ∫ˆLIndex❱❱@❰\&\[❰∫ˆcondition❱\]❱\❰❰∫ˆLExpress❱\❱`  
            (フラグ設定条件ブロック)`\❰\&\[❰∫ˆcondition❱\]{~}❰_¦\\n❱\=>{~}❰_¦\\n❱{❰,❱,1~}❰∫ˆLToken❱\❱ ❰/;"_"はスペース"\\n"は改行コードとする`  
            //フラグ設定条件で定義されるセレクトフラグ変数は再代入不可  
    [例] `{❰&aˆA¦B❱ ❰&bˆC¦D❱ ❰&[a&b]ˆE¦F❱}`は、  
        `{{{❰&aˆA¦B❱} ⇒ {❰&aˆA❱}}, {{❰&bˆC¦D❱} ⇒ {❰&bˆC❱}}}`の時、
        `{{❰&[a&b]ˆE¦F❱} ⇒ {❰&[a&b]ˆE❱}}`の選択のみを通す(パスする)  
        そしてその時、最終的に`{❰A❱ ❰C❱ ❰E❱}`  
        //スキップステージはxorブロックの結果を絞り込むかのように働きます。  
    [説明] スキップステージの評価手順。  
    1. `❰&aˆA¦B❱`のように`セレクトフラグ変数(&a)`を`xorブロックの引数に付け(&aˆA¦)`て`xorステージ後`で選択中かそうでないか記憶する。  
           詳しくは、`xorとスキップと"∫∫"とlineステージによる構造と評価手順`参照。  
    1.5. (フラグ設定条件)
    1. `❰&[a&b]ˆE¦F❱`のように`パス条件(&[a&b])`はセレクトフラグ変数を引数として取り(a,b)、  
        そのパス条件も`xorブロックの引数に付けて(&[a&b]ˆE¦)`、条件が真になる時、その引数の選択のみパスし、  
        それ以外はスキップする。条件が偽の時は全てパスする。  

    パス条件は条件が満たす時その引数が必ず選択されてほしい時に付ける。  
    - [詳細]  
        `xorとスキップと"∫∫"とlineステージによる構造と評価手順`の評価手順の`1.`のxorブロックで選択を確定させ、`2.`のスキップステージに移り、  
        望ましくない選択の(違法な)パターンを`パス条件`で検知して、`1.`のxorブロックに戻ることによってそのパターンを`スキップ`します。  
        望ましい選択の(合法な)パターンの場合は`3.`のvariableステージにそのパターンを渡します。  
        例えば`{❰&aˆA¦B❱ ❰&bˆC¦D❱ ❰&[a&b]ˆE¦F❱}`は、`A`と`C`が選択されたとき`F`が選択されるのは望ましくないので、  
        `{❰A❱,❰C❱,❰F❱}`の組み合わせのパターンはスキップされてvariableステージに渡されず`1.`のxorブロックに戻され`スキップ`されます。  
        `A`と`C`が選択されたとき`E`が選択されるのは望ましいのでvariableステージにそのパターンが渡され`パス`されます。  
        パスされるかスキップされるかは、`❰&[a&b]ˆE¦F❱`の場合は`[a&b]`の条件が真の時、`[a&b]`が付いているxorブロックの引数`E`が、  
        選択されているなら`パス`されていないなら`スキップ`になります。  
        `[a&b]`が偽の場合、その時に望まれていないパターンは無いので`E`と`F`どちらが選択されててもパスします。  
        つまり、パス条件が真なら、その引数を選択している時のみパスする。パス条件が偽なら、全ての引数の選択をパスする。  

        - パスかスキップか  
            `{❰A¦B¦C¦D❱}`  
            //この場合はパス条件がありません。つまり、ある選択の条件下で望まれるパターンがないので全ての選択のパターンをパスします。  
            `{❰&[False]ˆA¦&[False]ˆB¦&[False]ˆC¦&[False]ˆD❱}`  
            //`{❰A¦B¦C¦D❱}`の例はパス条件が真である引数が無い。つまり、ある選択の条件下で望まれるパターンがないので、  
            //全ての引数のパス条件が偽(False)であるのと同じになります。つまり、この全てのパス条件がFalseである例は全てパスします。  
            `{❰&[False]ˆA¦&[True]ˆB¦&[False]ˆC¦&[False]ˆD❱}`  
            //この例にはパス条件が真(True)である引数が１つあります。つまり、`B`以外の選択は望まれていません。  
            //なのでその引数(B)が選択されている時のみパスされ、それ以外の引数(A,C,D)が選択されている場合はスキップされます。  
            `{❰&[True]ˆA¦&[True]ˆB¦&[False]ˆC¦&[False]ˆD❱}`  
            //この例にはパス条件が真(True)である引数が２つあります。つまり、`A`または`B`以外の選択は望まれていません。  
            //なのでその２つの引数(A,B)のどちらかが選択されている時のみパスされ、それ以外の引数(C,D)が選択されている場合はスキップされます。  

            よってTrueがあるならそれのみパスして、全てがFalseなら全ての選択をパスします。  

        - パス条件  
            `{❰&[!(a&(b/(c¦(d&(True/(False¦use))))))]ˆA¦B❱} (論理演算子を全て使った例)`  
            セレクトフラグ変数をパス条件のフラグとして論理演算して真でその引数が選択されている時のみパスする。  
            セレクトフラグ変数の`&a`はパス条件の`[]`の中では`a`となります。  
            論理演算は`"["`と`"]"`の間に記述し論理演算子と優先順位は、  
            `{!==not, /==or, &==and, ¦==xor}.`の順で、  
            真理値は、`{True==真, False==偽, use==真}`で、  
            結合性の解決に`()`が使えます。  
            `use`は`True`のエイリアスと言うことにします。  
            `{❰&lˆA❱} ⇒ {❰A❱}`　`{❰&[a&b]ˆE❱} ⇒ {❰E❱}`  
            //全てのセレクトフラグ変数またはパス条件が付いた形式は最終的に無くなります。  
        
        - セレクトフラグ変数が複数定義されている場合はor演算されます。  
            `{❰&aˆA¦B❱ ❰&aˆC¦D❱ ❰&[a]ˆE¦F❱}`は、  
            `{{❰&aˆA¦B❱} ⇒ {❰&aˆA❱}}`の時、
            `{{{❰&aˆC¦D❱} ⇒ {{&aˆC}または{D}}}, {{❰&[a]ˆE¦F❱} ⇒ {❰&[a]ˆE❱}}}`の選択のみをパスする。  
            そしてその時、最終的に`{❰A❱ {❰C❱または❰D❱} ❰E❱}`  
            //`{{❰&aˆA¦B❱} ⇒ {❰&aˆA❱}}`なので、`&a==True`ですが、  
            //`❰&aˆC¦D❱`の`&a`は`Trueの場合`と`Falseの場合`があります。  
            //この場合、`上記の２つをor演算してTrue`にします。

        - リンクステージ  
            リンクステージはスキップステージの応用に`非常に近い`操作です。  
            リンクステージを有効にするにはセレクトフラグ変数を`&❰∫ˆLIndex❱`か`&❰∫ˆLToken❱-❰∫ˆLIndex❱`の形式にします。  

            `{❰❰&2ˆA¦B❱❰&1ˆC¦D❱❰&0ˆE¦F❱❱}`は、  
            `{{❰&2ˆA¦B❱} ⇒ {❰&2ˆA❱}}`の時、`{{❰&1ˆC¦D❱} ⇒ {❰&1ˆC❱}}, {{❰&0ˆE¦F❱} ⇒ {❰&0ˆE❱}}`の選択のみをパスする。  
            `{{❰&1ˆC¦D❱} ⇒ {❰&1ˆC❱}}`の時、`{{❰&0ˆE¦F❱} ⇒ {❰&0ˆE❱}}`の選択のみをパスする。  
            `{{❰&0ˆE¦F❱} ⇒ {❰&0ˆE❱}}`の時は何も起こらず、任意の選択をパスする。  
            //つまり、`数字が大きい`セレクトフラグ変数の引数が選択された時、  
            //`それより数字が同じか小さい`セレクトフラグ変数の引数の選択のみをパスする。  
            //リンクステージはスキップステージで言う、  
            `{❰❰&"2"&["2"/"3"/"4"/..]ˆA¦B❱❰&"1"&["1"/"2"/"3"/..]ˆC¦D❱❰&"0"&["0"/"1"/"2"/..]ˆE¦F❱❱}`であるかのように動作します。  

            `{❰&a-2ˆA¦B❱  ❰&a-1ˆC¦D❱  ❰&a-0ˆE¦F❱}`  
            //`&❰∫ˆLToken❱-❰∫ˆLIndex❱`の場合は`独立したトークンブロック間にも作用`し`同じ❰∫ˆLToken❱間`で上記と同じ動作をします。  

        - セレクトフラグ変数とパス条件の付け方と影響範囲  
            1. `X{❰{~}ˆ&aˆA¦B❱}, O{❰&aˆ{~}ˆA¦B❱} ({~}ˆ&aのようなセレクトフラグ変数の後ろに任意のステージを繋げることはできない)`  
               //`{❰{~}ˆ&aˆA¦B❱} ⇒ {❰{~}❰&a❰A❱❱¦B❱}`となり`&a❰A❱`が`{~}`の引数となってしまって直接`xorブロックの引数にならない`。  
            2. `{{❰&aˆA¦B❱},{❰C¦&aˆD❱}}(&aはAとD間に影響を与える)`  
               //`&`に`❰∫ˆtoken❱`が付く場合、variableステージの様に`独立したトークンブロック間にも影響を与えます。`  
            3. `{{❰&a-1ˆA¦B❱},{❰C¦&a-0ˆD❱}}`  
               //`&`に`❰∫ˆtoken❱`と`❰∫ˆLIndex❱`が付く場合、間に`-`を付けて区切ります。  
               //(トークンブロック間に影響を与えつつ、`同じ❰∫ˆLToken❱間`でリンクステージが働く)  
            4. `{{❰&0ˆA¦B❱},{❰C¦&0ˆD❱}}  (&0ˆAの&0と、&0ˆDの&0は、別の識別のセレクトフラグ変数)`  
               //`&`に`❰∫ˆLIndex❱`のみが付く場合、`独立したトークンブロック間に影響を与えず別々のセレクトフラグ変数`になります。
            5. `{❰&a&bˆA¦B❱} (&aと&bの間に"ˆ"を入れると1.の様にxorブロックの引数にならない)`  
               //１つのトークンに複数のセレクトフラグ変数を付けたい場合は`ˆ`を入れずに繋げます。  
            6. `X{❰&[a¦b]&[c&d]ˆA¦B❱}, O{❰&[a¦b]ˆA¦B❱}`  
               //パス条件は１つのトークンブロックに１つまでです。  
            7. `{❰&a&b&[a¦b]ˆA¦B❱}`  
               //セレクトフラグ変数とパス条件を繋げた例です。必ずセレクトフラグ変数、パス条件の並びです。  
            8. `{{&a@❰A❱} ⇒ {❰&a❰A❱¦❰&Null❱❱}}, {{&a&b&[a¦b]@ˆA} ⇒ {❰&a&b&[a¦b]❰A❱¦❰&Null❱❱}}`  
               //option演算子の左側に記述するとoptionステージを評価したときoptionのトークンに付きます。  
               1. `{{&a%❰A❱} ⇒ {❰&a❰A❱¦❰&Null❱❱}}, {{&a&b&[a¦b]%ˆA} ⇒ {❰&a&b&[a¦b]❰A❱¦❰&Null❱❱}}`  
               //default演算子も同じです。  
            9. `{{&a!@❰A❱} ⇒ {❰❰A❱¦&a❰&Null❱❱}}, {{&a&b&[a¦b]!@ˆA} ⇒ {❰❰A❱¦&a&b&[a¦b]❰&Null❱❱}}`  
               //`"!"`をoption演算子の左側に記述するとoptionステージを評価したときoptionのヌルトークンに付きます。  
               1. `{{&a!%❰A❱} ⇒ {❰❰A❱¦&a❰&Null❱❱}}, {{&a&b&[a¦b]!%ˆA} ⇒ {❰❰A❱¦&a&b&[a¦b]❰&Null❱❱}}`  
               //`"!"`をdefault演算子も同じです。  
            10. `{{&[a]=@❰A❱} ⇒ {❰&[a]❰A❱¦&[!a]❰&Null❱❱}}`  
               //`"="`をoption演算子の左側に`条件のみ`記述すると条件が真の時トークン、偽の時ヌルトークン、の選択のみパスします。  
               1. `{{&[a]=%❰A❱} ⇒ {❰&[a]❰A❱¦&[!a]❰&Null❱❱}}`  
               //`"="`をdefault演算子も同じです。  
               
        - フラグ設定条件  
            `{❰❰&aˆA¦B❱❰&bˆC¦D❱❰&[c]ˆ❰&[d]ˆE¦F❱¦G❱❱ ❰&[a&b] => c,d❱}`は、  
            `{{{❰&aˆA¦B❱} ⇒ {❰&aˆA❱}}, {{❰&bˆC¦D❱} ⇒ {❰&bˆC❱}}}`の時、  
            `{❰&[c]ˆ❰&[d]ˆE¦F❱¦G❱} ⇒ {❰&[c]ˆ❰&[d]ˆE❱¦G❱} ⇒ {❰&[c]ˆ❰E❱❱} ⇒ {❰E❱}`の選択のみをパスする。  
            そしてその時、最終的に`{❰A❱ ❰C❱ ❰E❱}`  
            //トークンブロックの外部に`❰&[a&b] => c,d❱`とすることで、`=>`の左側が真になった時、右側も真にします。  
            //`=>`の左に現れる変数(c,d)は必ず`新しく定義されるセレクトフラグ変数`であり、  
            //xorブロックの引数または別のフラグ設定条件の`セレクトフラグ変数を上書きしません`。  
            `{❰&[a&b] => c,d❱} ⇒ {}`  
            //フラグ設定条件は評価すると空になります。  

        - スキップステージ(とリンクステージ)よる操作は同時に一度しか実行しません。  
            `{❰❰&0ˆA¦B❱❰&a&[0]ˆC¦D❱❰&[a]ˆE¦F❱❱}`は、  
            `{{{❰&0ˆA¦B❱} ⇒ {❰&0ˆA❱}}`の時、  
            `{{{❰&a&[0]ˆC¦D❱} ⇒ {❰C❱}}, {{❰&[a]ˆE¦F❱} ⇒ {{❰&[a]ˆE❱}または{❰F❱}}}}`の選択のみパスする。  
            そしてその時、最終的に`{❰A❱❰C❱{❰E❱または❰F❱}}`  
            //`[説明]`で説明したようにスキップステージによる操作(スキップまたはパスする)の工程は２つ(本当は３つ)あります。  
            1. セレクトフラグ変数はxorブロックの選択を記憶します。(`&0`は`&0ˆA`が選択されたので真(&0=True))  
            1.5. (フラグ設定条件)
            1. そのセレクトフラグ変数をもとにパス条件で現在の選択をパスまたはスキップをする。
                (`&0==True`なので`&[0]`を満たし`C`の選択のみをパスする)  
            スキップステージはそれ以外の工程にパスまたはスキップと言う形で処理を受け渡すので、(一度しか実行しない)  
            `&a&[0]ˆC`がパスされても`&a==True`にならず`{❰&[a]ˆE¦F❱} ⇒ {❰&[a]ˆE❱のみ}`になりません。(連鎖しない)  

- lineステージ  
    //"_"はスペース、"\\n"は改行コード  
    [表現] `$recursion=❰\❰❰{~}❰∫ˆtokenXorNull¦{~}❰_¦\\n❱¦∫ˆrecursion❱❱\❱❱ ❰/;"_"はスペース"\\n"は改行コードとする`  
            `$tokenXorNull=❰\❰❰∫ˆLToken¦\&Null❱\❱❱`  
    [例]  `{❰_❰ab❱_❰&Null❱_\\n_cd__❱} ⇒ {❰_ab_\\n_cd__❱} ⇒ {_ab_\\n_cd__}`  
    [説明] トークンブロックのネストの内側からトークンブロックを除去していき、  
            ヌルトークンを解決して除去し、一番外側のトークンブロックまで除去して、  
            １つの文を完成させます。  
    - [詳細]  
        `{❰A❱} ⇒ {A}`  
        //トークンブロックを除去します。  
        `{❰❰A❱❰B❱❱} ⇒ {❰AB❱} ⇒ {AB}`  
        //トークンブロックのネストは内側から除去されます。 
        - ❰&Null❱の解決  
            `{❰&Null❱} ⇒ {}`  
            //ヌルトークンはヌルトークンごと除去します。  
            `{❰_\\n_\\n_❰&Null❱_\\n_\\n_❱} ⇒ {❰❱} ⇒ {}`  
            //内側のヌルトークンは隣り合うトークンが空白や改行の連続の場合それも含めて除去します。  
            `{❰_\\n_\\n_❰&Null❱_\\n_abc_def❱} ⇒ {❰abc_def❱} ⇒ {abc_def}`  
            `{❰_\\n_\\n_❰&Null❱_\\n_❰abc❱_❰def❱❱} ⇒ {❰abc_def❱} ⇒ {abc_def}`  
            `{❰abc_def_\\n_\\n_❰&Null❱_\\n_❱} ⇒ {❰abc_def❱} ⇒ {abc_def}`  
            `{❰❰abc❱_❰def❱_\\n_\\n_❰&Null❱_\\n_❱} ⇒ {❰abc_def❱} ⇒ {abc_def}`  
            //ヌルトークンと隣り合う空白や改行が、それ以外(abc_def)より、`先頭か末尾`の場合、
            //ヌルトークンと隣り合う空白や改行のみ除去します。  
            `{❰abc_\\n_\\n_❰&Null❱_\\n_def❱} ⇒ {❰abc_\\n_def❱} ⇒ {abc_\\n_def}`  
            `{❰❰abc❱_\\n_\\n_❰&Null❱_\\n_❰def❱❱} ⇒ {❰abc_\\n_def❱} ⇒ {abc_\\n_def}`  
            //ヌルトークンと隣り合う空白や改行が、それ以外との、`中間`の場合(abcとdefの中間)、  
            //ヌルトークンと隣り合う空白や改行のうち、ヌルトークンと`前の`空白や改行を除去します。  
        - 複雑な例  
            `{❰_❰&Null❱_❰_ab_❰&Null❱_cd_❰_❰&Null❱_❱❰_ef_❱_gh_❱_❰&Null❱_ij❱}`  
            ⇒  
            `{❰_❰&Null❱_❰_ab_❰&Null❱_cd_❰❱❰_ef_❱_gh_❱_❰&Null❱_ij❱}`  
            ⇒  
            `{❰_❰&Null❱_❰_ab_cd__ef__gh_❱_❰&Null❱_ij❱}`  
            ⇒  
            `{❰_ab_cd__ef__gh__ij❱}`  
            ⇒  
            `{_ab_cd__ef__gh__ij}`  

- `xorとスキップと"∫∫"とlineステージによる構造と評価手順` <a id="tegyun"></a>  
    `$recursion=❰\❰{~}❰❰\❰{❰\¦❱,2~}❰∫∫ˆsVWN¦∫ˆrecursion❱\❱❱¦∫∫ˆsVWN¦∫ˆrecursion❱\❱❱`  
    `$sVWN=❰❰&s@ˆ∫ˆskip❱&[s]=@❰\❰❱❰&v@❰\∫❱❱&[v]=@❰\❰❱❰∫ˆtokenXorNull❱&[v]=@❰\❱❱&[s]=@❰\❱❱❱`  
    `$tokenXorNull=❰\❰❰∫ˆLToken¦\&Null❱\❱❱`  
    `$skip=❰{~}❰\&&0@❰#idˆ∫ˆLToken❱&1@❰-❱&0@❰#idˆ∫ˆLIndex❱❱@❰\&\[❰∫ˆcondition❱\]❱❱ ❰/:$condition=❰#セレクトフラグ変数との論理演算#❱`  
        (❰❱の数は必要以上に多くなるが基本的な構造はあってると思う。。)  
    xorステージの直前までステージが進むと上記のような構造になります。つまり、  
    `❰❰A❱❰B❱❰C❱..❱`というlineの構造と`❰A¦B¦C¦..❱`というxorの構造が、入れ子になった構造になります。  
    例えば`{❰❰∫ˆa¦∫ˆb❱❰∫ˆc¦❰❰∫ˆd❱❰∫ˆe❱❱❱❱} $a=ˆ$b=ˆ$c=ˆ$d=ˆ$e=❰∫ˆLExpress❱`という構造は、  
    `❰❰∫ˆd❱❰∫ˆe❱❱`がline、プログラミングでいう多次元配列やクラスなどのデータ構造、数学でいう直積。  
    `❰∫ˆa¦∫ˆb❱`がxor、プログラミングでいう変数(bool==❰True¦False❱, int==❰..¦-2¦-1¦0¦1¦2¦..❱)、数学でいう直和。  
    それが入れ子になっています。  
    構造をが分かったところで、xorブロックとスキップと`"∫∫"`とtokenIndexとlineステージによる評価の手順は、(`xor->スキップ->"∫∫"代入->"∫∫"->tokenIndex->line`)  
    1. 全てのxorブロックの全ての選択のパターンを網羅するように更新して確定させて、  
        １つの形にします。`("{} ⇒ {{}または{}..}"ではなく"{} ⇒ {}"の形にする)`  
    1.5. 差集合してまだxorがあれば1.に戻る。  
    2. スキップステージで望まてれいない`1.`の`xorブロックの選択`の(違法な)パターンは`1.`に戻り、そのパターンをスキップします。  
        望まれた`1.`の`xorブロックの選択`の(合法な)パターンは`3.`に進み、そのパターンをパスします。  
    3. variableステージの`"∫"代入`で`言語表現の内部でトークンブロックがマーク`され、そのトークンブロックを同期変数(例:{`$val=`の`∫∫val`})へ代入し、  
        同期変数演算子(例:{`∫∫❰val❱`})の引数(val)と同じ名前の変数(∫∫val)を見つけ、その代入されたものを出現させます。  
    4. tokenIndexステージで❰token≈❱のようなトークンの最後に"≈"が付いた同じトークンブロックが複数あった場合、一番最初に出現したトークンから番号を0から振っていく。  
    5. lineステージはトークンブロックとヌルトークンを解決し１つの文にします。  
    6. `1.`から`5.`を繰り返して全ての文を完成させます。  
    というふうに`全てのxorを網羅(xor(ブロック))`しその`パターンを選別(スキップ)`し、  
    `同期変数演算子を評価("∫∫"代入->"∫∫")`をし`❰token≈❱の"≈"に番号を振り(tokenIndex)`全ての`文を完成(line)`させます。  


- tokenIndexステージ ボツかも  
    [表現]`{❰∫❰LToken❱\≈❱}`  
    [例]{❰arg≈❱, ❰arg≈❱, ❰arg≈❱,..} ⇒ {❰arg0❱, ❰arg1❱, ❰arg2❱,..}  
    [説明] lineステージの前で❰token≈❱のようなトークンの最後に"≈"が付いた同じトークンブロックが複数あった場合、  
            一番最初に出現したトークンから番号を0から振っていく。  
    - [詳細]  
        ステージの評価順序  
        ` 非評価hide->"≈"変数定義->合成->"∫"ブロックステージ->"∫"代入->"∫"->tag->not->fox->xor変換系->xor->スキップ->"∫∫"代入->"∫∫"->tokenIndex->line->評価hide`   
        lineステージの前まで来るとトークンブロックの種類が`❰❰&Null❱¦❰∫❰LToken❱\≈❱¦❰∫❰LToken❱❱❱`しかないので番号を振れる。  
- hideステージ (評価hideステージ、非評価hideステージ)ボツかもtagにまとめる  
    [表現] (評価hideブロック)`{❰/:❰∫ˆLExpress❱\\n}, {❰/:❰∫ˆLExpress❱:/❱}`  //"\\n"は改行コード  
           (非評価hideブロック)`{❰/;❰∫ˆLToken❱\\n}, {❰/;❰∫ˆLToken❱;/❱}` //これ要る?
    [例] `{❰/:❰∫ˆLExpress❱:/❱} ⇒ {}, {❰/:❰∫ˆLExpress❱\\n} ⇒ {}`  
    [説明] `❰/:`から`:/❱`または`❰/:`から`\\n`までを`評価hideブロック`と言い、`評価する`が対象言語から見えなくなる。  
            `❰/;`から`;/❱`または`❰/;`から`\\n`までを`非評価hideブロック`と言い、`評価せず`対象言語からも見えなくなる。  
            `❰/:`から`:/❱`, `❰/;`から`;/❱`は`トークンブロックの様に使えません`。  
    - [詳細]  
        X:`{❰token❰/;abcd;/❱❱}(トークンブロックの内部に出現しない)`, X:`{@❰/:abcd:/❱}(トークンブロックの様に使えない)`, O:`{❰/:@❰abcd❱:/❱}`  
        //評価,非評価hideブロックはトークンブロックのようには使えず、`トークンブロックを含む`ことはありますが、`トークンブロックの内部には出現せず`独立します。  
        `{❰/:$Number=#lit❰#自然数#❱\\n} ⇒ {} (⇒ {❰0¦1¦2¦..❱} にならない)`  
        //上記のように変数の定義はして欲しいが対象言語に`❰0¦1¦2¦..❱`が現れなくする。  
        `(説明){❰/;#tagNameのAは～..\\n} ⇒ {}`  
        //タグの説明を消せる。説明の中に`∫ˆLExpress`が現れても評価されない。  
        - 仕組み  
            ステージの評価順序は、  
            ` 非評価hide->"≈"変数定義->合成->"∫"ブロックステージ->"∫"代入->"∫"->tag->not->fox->xor変換系->xor->スキップ->"∫∫"代入->"∫∫"->tokenIndex->line->評価hide`  
            と言う順で評価されます。  
            - 非評価hideステージは、  
                一番最初に評価され真っ先に`{❰/;...\\n} ⇒ {}`と評価され、初めから何もなかったかのようになります。  
            - 評価hideステージは、  
                一番最後に評価され`{❰/:∫ˆLExpress\\n} ⇒ {}`の`∫ˆLExpress`はトークンブロックの評価として最後の`lineステージ`まで評価されます。  
                なので、トークンブロックの内部に出現しません。  
- tagステージ ボツかも コメントの意味でも使う? ＃コメント..\\n そしてhideを消す //`｢コメントtag｣``｢ ⇔ //, ｢abc｣ ⇔ /*abc*/`これを評価されないものとして使う? <a id="tag"></a>  
    [表現] `\#@❰∫ˆLToken❱@❰❰1~❱¦\~❱❱\❰❰∫ˆLExpress❱\❱` (# -> ＃(全角でいいかな))=====================================================================================   
    [例] `(使用){#tagName❰A❱} ⇒ {❰A❱}  (説明){#tagNameのAは～..}`  
    [説明] `#`の部分を`タグ演算子`と言い、トークンブロックにタグを付けてそのトークンブロックを外部で説明できる。  
    - [詳細]  
        (使用)`{#バグ→❰Func();❱}`  
        //外部に説明を書かないでタグだけでコメントのように使う使い方もある。  
        (使用)`{{#N1❰A❱}, {#N2❰B❱}, {#N3❰C❱}, {#N4❰D❱}}`  (説明){#N2~3は～..}  
        //タグの名前の末尾に番号を書いて、説明時に`2~3`というふうに複数のタグを同時に指せる。  
        (使用)`{{#N~❰A❱}, {#N~❰B❱}, {#N~❰C❱}, {#N~❰D❱}}`  (説明){#N~は～..}  
        //名前の同じタグが複数ある場合、タグの名前の末尾に`~`を書いて、説明時にそのタグ名が複数あることを知らせる。  
        (説明)`{❰/;#tagNameのAは～..\\n} ⇒ {} (\\nは改行コード)`  
        //hideステージと組み合わせることで説明の文を消せる。  

        - いくつか組み込みでtagを定義している。  
            `identifier: #id❰A❱ //Aはユーザー定義の識別子。`  
            `variable: #val❰A❱ //Aは変数`  
            `type: #type❰A❱ //Aは型`  
            `literal: #lit❰A❱ //Aはリテラル`  

