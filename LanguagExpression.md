<!-- markdownlint-disable MD041 -->
<!-- markdownlint-disable MD007 -->
# 言語表現(Language Expression)  

- 評価図式(`{..} => {..}`という表現について)  
    `＠❰..:❱{..} => {..}`という表現は、`{..}`内(または`❰..❱`)になんらかの`評価する対象`があり`=>`の`前`が`評価前`を表し、`後`が`評価後`を表す。  
    [例] `+:{1+2} => {3}`というのは、評価する対象`+`があり、評価前は`1+2`で評価後は`3`である。  
- `[表現]`について  
    `[表現]`は`変数ブロックとFoxブロックが評価された直後の状態を表す`とし、その項で説明している`メタ文字`の`使われ方を表現`している。正確には`正しくないのも多い`ので`雰囲気程度`に考えて欲しい。  
    `∫LToken∫`は`ヌル(Ø)以外のメタ文字`を`含まない`文字列。`∫LExpress∫`は`言語表現(メタ文字)`を使って`構成`された`任意の式`である。`∫LExpress∫`を単に`式`または`ブロック`と呼ぶ場合がある。  

- 基礎  
    - Token(トークン)  
        [表現] `∫LToken∫`  
        [例] `{❰static❱}の{static}, {❰System❰.Object❱❱}の{System,.Object},`  
             `{❰ A B C ❱}の{ A B C }, {⟪肉¦魚⟫}の{肉,魚}, {⟪ans = ⟦1.0⟧ / ⟦2.0⟧⟫}の{ans = ,1.0, / ,2.0}がトークン`  
        [説明] トークンとは、`ほぼ任意の文字列`と`Null(ヌル)(Ø)`です。`トークンブロック(❰❱)`または`関数ブロック(⟪⟫)`内でのみ現れる必要がある。  
                ほぼ任意とは、この`言語表現(Language expression)`を構成する(エスケープされていない)構成文字(❰❱¦＄＝∫などの特殊文字)(`メタ文字`とも言う)が`含まれない`文字列。  
        - [詳細]  
            `トークン`とは言語表現によって組み替えたり複製されたりして加工される文字列の事。  
            `変数ブロック`や`Fox関数ブロック`内の任意の文字列は変換されるためだけの文字列なので`トークンではない`。  

        - Null(ヌル)(`Ø`)  
            [説明] ヌル％❰トークン❱(Ø(U+00D8))は、そこに`トークンが無い`事を示す。`ライン処理`で`解決`される。  

    - ブロック (`❰❱,⟪⟫,∫∫,○∫∫,【⇒∥┃∠〖⸨⸩〗】`)  
        - Token block(トークンブロック(`❰❱`))  
            [表現] `¥❰∫LExpress∫¥❱`  
            [例] `{❰token0❰token1❰token2❱❱❰token3❱❱}`  
            [説明] トークンブロック(`❰❱`(U+2770,U+2771))は、トークンを区切る役割を持つ。  
            - [詳細]  
                `{＠❰token❱}`の`"＠"`や`{❰token0❱∪❰token1❱}`の`"∪"`は`ブロック演算子`と言い`トークンブロック`に対して作用する。  

        - Function block(関数ブロック(`⟪⟫`(`¦,┃～,⟦：⟧,＃`)))  
            [表現] `{¥⟪『各関数ブロックの中身』¥⟫} (正確には正しくない表現)`  
            [例] `Xor:{⟪A¦B⟫}, Index:{⟪2～4⟫} => {⟪2¦3¦4⟫}, Permutation:{⟪⟦A⟧⟦B⟧⟫} => {⟪AB¦BA⟫}, Fox:{⟪＃五影＃⟫} => {⟪火影¦風影¦土影¦水影¦雷影⟫}`  
            [説明] 関数ブロック(`⟪⟫`(U+27EA,U+27EB))は、式または数値を引数に、新しい`Xorブロック`または`トークンブロック`を`生成して返します`。  
                   関数ブロックの種類は`Xor(¦)`,`Index(┃～)`,`Permutation(⟦：⟧)`,`Fox(＃)`があります。  

        - Variable block(変数ブロック(`∫∫,○∫∫`))  
            [表現] `⟪¥∫¦¥○¥∫⟫∫LToken∫¥∫`  
            [例] `{∫val∫} => {⟪A¦B⟫}, {○∫val∫} => {❰A❱}`  
            [説明] 変数ブロックは、`同期変数ブロック`(`○∫∫`)と`非同期変数ブロック`(`∫∫`)があり、評価するとその位置に代入された`式`を展開する。  
                　 詳しい詳細は後に書いてあります。  

        - Edit extract block(抽出編集ブロック(`【⇒∥┃∠〖⸨⸩〗】`))  
            [表現] `＄OP＝❰＃"⸨⸩"へのブロック演算系と変数など操作＃❱`  
                   `¥【∫LExpress∫｡⟦¥┃┃1～⟧❰｡｡｡｡＠⟪⇒∫LExpress∫∥¦⇒∫抽出編集∫∥⟫＄抽出編集＝❰｡｡｡⟦～⟧❰¥∠∫LExpress∫❱⏎`
                        `❰｡｡∠∫LExpress∫∫OP∫｡¥⸨⟪＃抽出式または抽出トークン＃⟫¥⸩｡∫OP∫∫LExpress∫｡｡❱｡｡｡❱｡｡｡｡❱¥】`  
            [例] `{【❰A❰B❱❱∠✖⸨B⸩】} => {❰A❰✖❰B❱❱❱}, {＄val＝❰A⟪B¦C⟫❱【∫val∫∠✖⸨B⸩】} => {❰A⟪✖❰B❱¦C⟫❱}`  
                 `{＄val0＝❰B∫val1∫❱ ＄val1＝❰B⟪D¦B⟫❱【❰A∫val0∫❱∠∫val0∫∠∫val1∫∠⟪D¦B⟫∠✖⸨B⸩】} => {❰A❰B❰B⟪D¦✖❰B❱⟫❱❱❱}`  
                 `{【❰⟪A¦B¦C⟫⟪D¦E⟫❱⇒❰⟪A¦B⟫⟪D¦E⟫❱∠⸨⟪D¦E⟫⸩⊃❰D❱】} => {⟪CD¦CE¦AD¦BD⟫}`  
            [説明] 抽出編集ブロック(`【⇒∥┃∠〖⸨⸩〗】`(U+3010,U+21D2,U+2225,U+2503,U+2220,U+3016,U+2E28,U+2E29,U+3017,U+3011))は、  
                   `式`の`部分`を`抽出`し`編集`してしまう、`式木の部分木`に`変更を加える`やばいブロックである。すぐには理解できないと思う。  
            - [詳細]  
                下の抽出編集ブロックの`一番左`は`抽出される元になる式`(`❰A⟪B¦｡CD｡E⟫❱`)これを`抽出元`と呼ぶ。  
                次に`∠`は、`抽出編集ブロック内のみ`で使える記号で`抽出子`と呼び、左項の`式の部分`を右項に表し`抽出`を表しています。  
                抽出の仕方は2種類あり、左から1番目の`抽出子`は`式から式`を抽出(`⟪B¦｡CD｡E⟫`(`抽出式`と呼ぶ))し、  
                2番目の`抽出子`は`式からトークンの連続部分文字列`を抽出(`CD`(`抽出トークン`と呼ぶ))しています。  
                そして最後に抽出したものを`⸨⸩`で囲みそこに`ブロック演算系`や`変数`など色々な操作を加え、それが`抽出元に反映`され、そしてそれが`返ります`。  
                `{【❰A⟪B¦｡CD｡E⟫❱∠⟪B¦｡CD｡E⟫∠G⟪✖⸨CD⸩¦F⟫H】} => {❰A⟪B¦｡❰G⟪✖❰CD❱¦F⟫H❱｡E⟫❱}`  

                `抽出元`が`変数ブロック`であっても`変数の定義元を参照`し`抽出`することができます。  
                `{＄val＝❰A⟪B¦C⟫❱【∫val∫∠✖⸨B⸩】} => {【❰A⟪B¦C⟫❱∠✖⸨B⸩】} => {❰A⟪✖❰B❱¦C⟫❱}`  

                `抽出トークン`は、`トークンの文字列の連続した範囲(連続部分文字列)`を`抽出`できます。`❰ABCD❱`の場合、`連続した範囲の全ての集合`は`{ABCD,ABC,AB,A,BCD,BC,B,CD,C,D}`になります。  
                `{【❰ABCD❱∠✖⸨BC⸩】} => {❰A✖❰BC❱D❱}`  

                `抽出式`は、`抽出子`を連続して並べる事で、`式から式を抽出`し、`抽出した式をさらに抽出`する事で`抽出対象を絞り込む`ことができます。(式木を頂点から下るイメージ)  
                `{＄val0＝❰B⟪D¦B⟫❱【❰A❰B∫val0∫❱❱∠❰B∫val0∫❱∠∫val0∫∠⟪D¦B⟫∠✖⸨B⸩】} => {❰A❰B❰B⟪D¦✖❰B❱⟫❱❱❱}`  
                `抽出元`から`一段ずつ抽出しなくても`一気に`複数段とんで抽出`する事ができます。  
                `{＄val0＝❰B⟪D¦B⟫❱【❰A❰B∫val0∫❱❱∠⟪D¦B⟫∠✖⸨B⸩】} => {❰A❰B❰B⟪D¦✖❰B❱⟫❱❱❱}`  
                `抽出対象の絞り込み`をしないと、`抽出元`の`式木に現れる全ての対象`から`抽出`されてしまいます。  
                `{＄val0＝❰B⟪D¦B⟫❱【❰A❰B∫val0∫❱❱∠✖⸨B⸩】} => {❰A❰✖❰B❱❰✖❰B❱⟪D¦✖❰B❱⟫❱❱❱}`  

                - 抽出式の代入  
                    `抽出式の代入`は`抽出元`と`同期`します。  
                    `{【❰A＄val0＝⟪B¦C⟫❱∠＄val1＝⸨⟪B¦C⟫⸩】} => {{○∫val0∫}⇔{○∫val1∫}}`『`val0`と`val1`は`同期`している。  

                - 連続抽出編集(`┃`)  
                    `抽出子`による操作を`┃で区切る`ことで、`抽出編集ブロック`を`ネスト`したものに変換できる。  
                    `{【❰ABCD❱∠✖⸨B⸩┃∠✖⸨D⸩】} => {【【❰ABCD❱∠✖⸨B⸩】∠✖⸨D⸩】} => {【❰A✖❰B❱CD❱∠✖⸨D⸩】} => {❰A✖❰B❱C✖❰D❱❱}`  

                - `変数の定義と代入`の`変数による抽出`
                    変数の定義と代入(`＄val＝❰B❱`)を変数(`∫val∫`)で抽出する事ができ、`変数の定義と代入`(`＄val＝❰B❱`)を`∫val∫`とみなし`編集対象`にする事ができる。
                    `{【⟪A¦＄val＝❰B❱⟫∠✖⸨∫val∫⸩】} => {⟪A¦✖❰∫val∫❱⟫} => {⟪A¦✖❰B❱⟫}`

                - 部分木の出現(`〖〗`)
                    抽出した部分を`〖〗`で囲む事でその`抽出した部分のみ`を`出現`させます。
                    `{【⟪A¦B⟫∠〖B〗】} => {❰B❱}`
                    部分木の出現(`〖〗`)は、`変数の定義と代入`と`変数の使用(同期)`に展開されます。
                    `{【⟪A¦B⟫∠〖B〗】} => {『【⟪A¦B⟫∠＄val＝⸨B⸩】』○∫val∫} => {❰B❱}`

                - 条件子(`⇒`)  
                    `⇒`の事を`条件子`と言い、`⇒`の`左項`を`編集元`、`右項`を`条件`と言います。  
                    条件子(`⇒`)は、包含(`⊃`)と似ていて、包含の[説明]の`ほぼ引き用`より、  
                    `左項の⟪トークン¦Xor⟫ブロック`が`右項の⟪トークン¦Xor⟫ブロック`の`部分集合`になっているか検証し、  
                    なっていれば`右項`をそのまま返し、なっていなければ`エラー`(`Ø`ではない)を返します。  
                    つまり、`部分集合`になっていれば処理に`成功`するが、なっていれば`失敗してエラー`となります。  
                    なので、`必ず`、`⇒`の`右項`は`左項`の`部分集合`になっていなければなりません。  
                    そして、この`条件子`を使った`抽出編集ブロック`の処理とは、  
                    `編集元`がある特定の`Xorの選択(条件)`になった場合、その`条件`の時だけ`編集元`の`構成(式木)`を`変更`している`様に見える`。様にします。。  
                    つまり、`編集元`で、`あるXorの選択`で`コレが選択`された`場合`は、`ある他のXorの選択`を`コレにして欲しい！`って時などに使えます。  
                    `条件子`を使った`抽出編集ブロック`の使い方は、  
                    `編集元`に`条件`によって、`挙動を変えたい式`を入れます。次に、`条件`にその`条件の式`を入れます。  
                    そして、`条件`を`抽出元`と思い、それを`編集する文`を`then子(∥)`の右項に書きます。  
                    そして、この`条件子`を使った`抽出編集ブロック`を`評価`すると、`編集元`を`ある条件の時`に`挙動を変える式`が生成されます。  
                    `{【❰⟪A¦B¦C⟫⟪D¦E⟫❱⇒❰⟪A¦B⟫⟪D¦E⟫❱∥∠⸨⟪D¦E⟫⸩⊃❰D❱】} => {❰｡❰⟪A¦B¦C⟫⟪D¦E⟫❱∸❰⟪A¦B⟫⟪D¦E⟫❱｡❱∪【❰⟪A¦B⟫⟪D¦E⟫❱∠⸨⟪D¦E⟫⸩⊃❰D❱】} =>`  
                    `{❰｡⟪AD¦AE¦BD¦BE¦CD¦CE⟫∸⟪AD¦AE¦BD¦BE⟫｡❱∪❰⟪A¦B⟫❰⟪D¦E⟫❱⊃❰D❱❱} => {❰⟪CD¦CE⟫❱∪❰⟪A¦B⟫❰D❱❱} => {⟪CD¦CE¦AD¦BD⟫}`  

                    - 原理  
                        `条件子`を使った`抽出編集ブロック`の仕組みは、  
                        まず、`編集元`から`条件`を引いた`差集合(∸)`をとり、`編集元`から`条件の選択`が`現れない式の集合`を作ります。  
                        これが、`編集元`から`条件の選択`に`ならなかった場合`の`全ての選択の式の集合`になります。  
                        次に、`編集元の選択の部分`になる`条件`を、仮に何も`編集をしない`で、`さっきの差集合`に`和集合(∪)`で足すと、  
                        `{❰∫編集元∫∸∫条件∫❱∪∫条件∫} => {∫編集元∫}`  
                        と、なり`条件`と`条件以外`に`分けた`のを`足しわわせる`と元に戻り`編集元`は何も`編集していない`のと同じになります。  
                        そこで、`条件`を`編集`してから`足し合わせる`と、`条件の選択の場合の時`だけ`挙動が変わる式`ができます。  
                        `{【∫編集元∫⇒∫条件∫∥∠『∫条件∫を抽出元として、その抽出と編集』】} => {❰∫編集元∫∸∫条件∫❱∪【∫条件∫∠『∫条件∫を抽出元として、その抽出と編集』】}`  

                    - 条件子(`⇒`)の右項で`編集元を抽出元`とした抽出編集
                        `【∫編集元∫⇒∠『抽出編集』∥..】`とする事で、`【∫編集元∫⇒【∫編集元∫∠『抽出編集』】∥..】`の様に変換します。
                        `{【＠⟪A¦B⟫⇒∠✖⸨B⸩∥∠N⸨A⸩】} => {【＠⟪A¦B⟫⇒【＠⟪A¦B⟫∠✖⸨B⸩】∥∠N⸨A⸩】}`
                        `{【∫編集元∫⇒∠『抽出編集』∥∠『条件の抽出編集』】} => {【∫編集元∫⇒【∫編集元∫∠『抽出編集』】∥∠『条件の抽出編集』】}『【∫編集元∫∠『抽出編集』】が条件`

                    - 条件の時(`⇒`)の`条件時連続抽出編集`(`∥`)
                        条件の時に`複数箇所変更`したい場合、左から二番目以降のthen子(`条件時連続抽出編集`(`∥`))の出現を`連続抽出編集`(`┃`)に変えて`条件の連続抽出編集`をします。
                        `{【∫編集元∫⇒∫条件∫∥∠『条件の抽出編集』∥∠『『条件の抽出編集』の抽出編集』】} =>`
                            `{❰∫編集元∫∸∫条件∫❱∪【∫条件∫∠『条件の抽出編集』┃∠『『条件の抽出編集』の抽出編集』】}`
                        `{【＠⟪⟪A¦B⟫¦C⟫⇒∠⟪A¦B⟫∠✖⸨B⸩∥∠N⸨A⸩∥∠M⸨N❰A❱⸩∥∠L⸨C⸩】} => {【＠⟪⟪A¦B⟫¦C⟫⇒【＠⟪⟪A¦B⟫¦C⟫∠⟪A¦B⟫∠✖⸨B⸩】∥∠N⸨A⸩∥∠M⸨N❰A❱⸩∥∠L⸨C⸩】}`
                        `{❰【＠⟪⟪A¦B⟫¦C⟫∸＄条件＝【＠⟪⟪A¦B⟫¦C⟫∠⟪A¦B⟫∠✖⸨B⸩】❱∪【∫条件∫∠N⸨A⸩┃∠M⸨N❰A❱⸩┃∠L⸨C⸩】}`

    - Block operator(ブロック演算子(`＄＝,✖,＠,％,⟦┃～⟧,⊃,∸,⚺,∪,∩,≡`))  
        [表現] `＄EscapedReplicateOp＝❰¥⟦｡｡｡❰｡｡＠∫LExpress『区切り文字』∫＠❰¥┃❱＠⟪～⟫¥～＠⟪～⟫｡｡❱｡∪｡❰＠∫LExpress『区切り文字』∫¥┃⟪～⟫¥┃❱｡｡｡¥⟧❱`  
               `＄EscapedUnaryOp＝⟪¥＄∫LToken∫¥＝¦¥✖¦¥＠¦¥％¦∫EscapedReplicateOp∫⟫`  
               `＄EscapedBinaryOp＝⟪¥⊃¦¥∪¦¥∸¦¥⚺¦¥∩¦¥≡⟫`  
               `{∫EscapedUnaryOp∫｡∫LExpress∫}, {∫LExpress∫｡∫EscapedBinaryOp∫｡∫LExpress∫}`  
        [例] `{＠❰A❱} => {⟪A¦Ø⟫}, {✖⟪A¦B⟫} => {Ø}, {⟪A¦B¦C⟫⊃⟪A¦B⟫} => {⟪A¦B⟫}, {⟪A¦B¦C⟫∩⟪B¦C¦D⟫} => {⟪B¦C⟫}`  
        [説明] ブロック演算子には、`ブロック単項演算子`と`ブロック2項演算子`があります。  
               ブロック演算子は、`ブロック`に作用し、新しい`Xorブロック`または`トークンブロック`を`生成して返します`。  
               ブロック単項演算子は`代入演算子(＄＝)`,`破棄(✖)`,`オプション(＠)`,`デフォルト(％)`,`レプリケート(⟦┃～⟧)`があります。  
               ブロック2項演算子は`包含(⊃)`,`差集合(∸)`,`排他集合(⚺)`,`和集合(∪)`,`積集合(∩)`,`イコール(≡)`があります。  
               `ブロック単項演算子`は`左から作用`します。  

    - ブロック単項演算子の合成則  
        [表現] `⟦2～⟧∫EscapedUnaryOp∫｡∫LExpress∫`  
        [例] `{⟦～⟧＠❰A❱} ⇔ {⟦～⟧❰＠❰A❱❱} = {⟦～⟧❰⟪A¦Ø⟫❱} => {⟪Ø｡¦｡⟪A¦Ø⟫｡¦｡⟪A¦Ø⟫⟪A¦Ø⟫｡¦｡⟪A¦Ø⟫⟪A¦Ø⟫⟪A¦Ø⟫｡¦｡..⟫}`  
        [説明] `ブロック単項演算子`が`トークンブロックの左側`に`連続して並んでいる`とき`トークンブロック`で`区切って作用`させるのと同じになります(`右結合`)。  

    - 関数ブロックとブロック演算子の評価順序と結合規則  
        評価順序は、  
            [マクロ] => [`代入演算子(＄＝)(非同期の代入)`] => [`抽出編集(この中でXorの手前までやる?)`] => [`Xor(¦)以外のブロック`] => [`代入演算子(＄＝)以外のブロック単項演算子`] =>
            [`Xor結合`] => [`包含(⊃)`] => [`差集合(∸)`] => [`排他集合(⚺)`] => [`和集合(∪)`] => [`積集合(∩)`] => [`イコール(≡)`] => [`Xor(¦)`] => [`XorSync(○¦)`] =>  
            [`代入演算子(＄＝)(同期の代入)`] => [`ライン`]  
        となります。  
        - [例]  
            『`非同期の代入`を`＄HiDouki＝`で表し、`同期の代入`を`＄Douki＝`で表している  
            `＄HiDouki＝:{＄HiDouki＝＠⟪⟦A⟧⟦B⟧⟫⊃⟪AB¦Ø⟫} => ⟦：⟧:{＄Douki＝＠⟪⟦A⟧⟦B⟧⟫⊃⟪AB¦Ø⟫} => ＠:{＄Douki＝＠⟪AB¦BA⟫⊃⟪AB¦Ø⟫} =>`  
            `⊃:{＄Douki＝⟪AB¦BA¦Ø⟫⊃⟪AB¦Ø⟫} => ¦:{＄Douki＝⟪AB¦Ø⟫} => ＄Douki＝:{＄Douki＝{❰AB❱}または{Ø}} => line:{{❰AB❱}または{Ø}} =>`  
            `{{AB}または{}}`  

        結合規則は、`ブロック単項演算子`は`右結合`、`ブロック2項演算子`は`左結合`です。  

        評価順序を変えたい場合はトークンブロック(`❰❱`)で囲むことにより変えることができます(数学の`()`と同じ様に)。  
        `{✖❰A❱∪❰B❱} => {Ø∪❰B❱} => {⟪Ø¦❰B❱⟫} => {{Ø}または{❰B❱}}`, `{✖❰❰A❱∪❰B❱❱} => {✖⟪❰A❱¦❰B❱⟫} => {Ø}`  

    - 補助機能  
        - Comment(コメント(`『』`))  
            (`\n`は改行コード)  
            [表現] `{¥『⟪＃任意の文字列＃⟫¥』}, {¥『⟪＃任意の文字列＃⟫\n}`
            [例] `{∮LAny∮    『コメント』abc} => {∮LAny∮    abc}, {∮LAny∮    『コメント   \n} => {∮LAny∮    \n}`  
            [説明] コメント(`『』`(U+300E,U+300F))はC言語と同じで`//`は`『`と同じで、`/**/`は`『』`と同じ。  

        - Normal token(ノーマルトークン(`｢｣`)) (追記:これがFoxでもいいかも..←の追記:Macroのために両方いるかも)  
            [表現] `{｢∫LToken∫｣}`  
            [例] `{｢なまえ｣} => {❰∫LToken∫⊃❰＃なまえ＃❱❱}, {｢URL｣}, {｢変数名｣}`  
            [説明] ノーマルトークン(｢｣(U+FF62,U+FF63))は、`｢..｣`を`❰∫LToken∫⇒❰＃..＃❱❱`に変換します。`その位置`に`∫LMeta∫`を含まない`適切な普通の文字列`を表せられます。  

        - Escape(エスケープ(`¥`))  
            [表現] `{¥¥⟪＃メタ文字＃⟫}`  
            [例] `{¥＠}, {¥○¥∫val¥∫}`  
            [説明] エスケープ％❰演算子❱(`¥`(U+00A5))はC言語のエスケープ文字`\`と同じで`メタ文字`を`メタ文字ではない文字`にする。  

        - Space character(スペースキャラクタ(`｡`))  
            [表現] `⟪＃任意の文字列＃⟫¥｡⟪＃任意の文字列＃⟫`  
            [例] `{ldc⟪❰｡｡❰.i4❱＠⟪｡❰.⟪0~8⟫❱¦.m1¦.s｡⟫｡｡❱¦.i8¦.r4¦.r8⟫} => {ldc⟪❰❰.i4❱＠⟪❰.⟪0~8⟫❱¦.m1¦.s⟫❱¦.i8¦.r4¦.r8⟫}`  
                 `{＄Method＝⟪∫Normal_method∫｡¦｡∫Instance∫｡¦｡∫Static∫｡¦｡∫part_method∫｡¦｡∫Interface_method∫｡¦｡∫expr_method∫｡¦｡∫Tructor∫⊃⟪∫cctor∫¦∫ctor∫¦∫Finalize∫⟫｡¦⏎`  
                 `｡∫Prodexer∫⊃⟪∫Property∫¦∫Indexer∫⟫｡¦｡∫Iterator∫｡¦｡∫Extension∫｡¦｡∫Operator∫⟫} =>`  
                 `{＄Method＝⟪∫Normal_method∫¦∫Instance∫¦∫Static∫¦∫part_method∫¦∫Interface_method∫¦∫expr_method∫¦∫Tructor∫⊃⟪∫cctor∫¦∫ctor∫¦∫Finalize∫⟫¦⏎`  
                 `∫Prodexer∫⊃⟪∫Property∫¦∫Indexer∫⟫¦∫Iterator∫¦∫Extension∫¦∫Operator∫⟫}`  
            [説明] スペースキャラクタ(`｡`(U+FF61))は、`{｡} => {}`となり、ただ消えるだけで何もしません。スペースを`｡`で作って分かりやすさのために使います。  
                   通常のスペース`{ }`は、`{ } => { }`となり`{ }`は消えません。  
                   つまり、`{ }`は`{⟪ A ¦ B ⟫} => {⟪ A ¦ B ⟫} => {{ A }または{ B }}`ですが、`{｡}`は`{⟪｡A｡¦｡B｡⟫} => {⟪A¦B⟫} => {{A}または{B}}`となります。  

        - Remove line break(改行削除(`⏎`))  
            ("\_"はスペース、"\n"は改行コードとする。)  
            [表現] `∫LExpress∫¥⏎\n⟦～⟧❰_❱∫LExpress∫`  
            [例] `{❰A❱⏎\n________❰B❱} => {❰A❱❰B❱}`  
            [説明] 改行削除(`⏎`(U+23CE))は、改行(`⏎`)の次の改行(\n)から最後のスペース(_)までを削除する。  

        - Macro(マクロ(`＃＝≪●≫∮∮`))  
            [表現] (定義と代入)`¥＃○∫LToken∫¥＝¥≪⟪＃∫LExpress∫内のメタ文字に"¥●"が付いているかもしれない∫LExpress∫＃⟫¥≫`  
                   (変数の使用)`¥∮○∫LToken∫¥∮`  
            [例] `＃REPLICATE_OP＝≪⟦｡｡｡●❰｡｡●＠●❰∫LExpress『区切り文字』∫❱●＠●❰┃❱●＠●❰⟪～⟫❱～●＠●❰⟪～⟫❱｡｡❱｡●∪｡●❰●＠●❰∫LExpress『区切り文字』∫❱┃⟪～⟫┃❱｡｡｡⟧≫`  
            [説明] マクロ(`＃＝≪●≫∮∮`(U+FF03,U+FF1D,U+226A,U+25CF,U+226B,U+222E))は、`≪≫`内に書かれた`文字列`を`マクロ変数(MACRO)`に代入し、そのまま`マクロ変数の位置(∮MACRO∮)`に展開する。  
                   `{＃MACRO＝≪B≫❰A ∮MACRO∮ C❱} => {❰A B C❱} (❰A ❰B❱ C❱とならない)("＃MACRO＝≪B≫"は消えます)`  
            - [詳細]
                マクロは、`メタ文字`も`そのまま展開`します。  
                `{＃MACRO＝≪∪≫ ❰⟪A¦B⟫∮MACRO∮⟪B¦C⟫❱} => {❰⟪A¦B⟫∪⟪B¦C⟫❱}`  
                マクロは、`●`が付いた`メタ文字`を`評価`してから`マクロ(≪≫)以外`の場所に展開します。  
                `{＃MACRO＝≪●⟪∪¦∩⟫≫ {●⟪∪¦∩⟫} => {{∪}または{∩}} => {{❰⟪A¦B⟫∮MACRO∮⟪B¦C⟫❱} => {{❰⟪A¦B⟫∪⟪B¦C⟫❱}または{❰⟪A¦B⟫∩⟪B¦C⟫❱}}}`  
                `マクロからマクロへの展開`は`まだ評価せず`そのまま展開されます。  
                `{＃MACRO1＝≪●⟪∪¦∩⟫≫ ＃MACRO0＝≪●⟪∸¦∮MACRO1∮⟫≫} => {＃MACRO0＝≪●⟪∸¦●⟪∪¦∩⟫⟫≫}`  
                - 以下のようにすることで同時に代入することができる
                    `＃A＝＃B＝＃C＝≪∮LAny∮≫`
                - いくつか組み込みでマクロ変数を定義している。(`L`から始まる)
                    `＃LAny＝⟪＃言語表現の任意の表現＃⟫`

- Variable(変数(`＄＝`,`∫∫`,`○∫∫`))  
    [表現] (定義と代入)`¥＄○∫LToken∫¥＝∫LExpress∫`  
           (変数の使用)`⟪¥∫¦¥○¥∫⟫○∫LToken∫¥∫`  
    [例] (定義と代入)`{＄val＝⟪A¦B⟫} => {⟪A¦B⟫}`, (変数の使用)`{∫val∫} => {⟪A¦B⟫}`  
    [説明]  `代入％❰演算子❱`(`＄＝`(U+FF04,U+FF1D))は、変数に`式`を代入できる。  
            `非同期変数％❰ブロック❱`(`∫∫`(U+222B))と`同期変数％❰ブロック❱`(`○∫∫`(U+25CB))(まとめて`変数％❰ブロック❱`)は、それが使われた位置に代入された`式`を展開できる。
    - [詳細]  
        (定義と代入)`{＄val＝⟪A¦B⟫} => {⟪A¦B⟫}`  
        `val`は定義された変数名でそれに`⟪A¦B⟫`を代入している。`＄val＝`の部分は評価すると消えるだけで右側の`⟪A¦B⟫`になんの影響も与えない。  
        (変数の使用)`{∫val∫} => {⟪A¦B⟫}`  
        `∫val∫`の様に変数名を`∫`で囲むとその位置に代入された`⟪A¦B⟫`を展開する。  
        - `非同期変数ブロック(∫∫)`と`同期変数ブロック(○∫∫)`の違い。  
            とりあえず`val`を`＄val＝⟪A¦B⟫`の様に代入する。  
            このとき、`∫val∫`と書くと、その位置に`⟪A¦B⟫`が展開される。  
            そして、`○∫val∫`と書くと、大元の`⟪A¦B⟫`が`❰A❱`と決定されると`○∫val∫`の展開も`❰A❱`となる。同様に`❰B❱`と決定すると展開も`❰B❱`となる。  
            つまり、`❰∫val∫_∫val∫❱`と書くと`❰A_B❱`となるパターンがあり`∫val∫`と`∫val∫`の結果が違う事がありえるが、  
            `❰○∫val∫_○∫val∫❱`の場合は一つの大元の`⟪A¦B⟫`の決定により`❰A_A❱`か`❰B_B❱`しかありえない。  
        - `○∫∫`の`同期変数ブロック`は展開が`Ø`になる事がある。  
            とりあえず、`val`を`⟪＄val＝❰A❱¦❰B❱⟫`と言う状況で代入する。  
            このとき、`⟪＄val＝❰A❱¦❰B❱⟫`が`❰B❱`に決定して、`＄val＝❰A❱`が選択されなかった場合は、  
            `○∫val∫`は`Ø`になります。`∫val∫`の場合は`❰A❱`になります。  
        - 以下のようにすることで同時に代入することができる
            `＄A＝＄B＝＄C＝∫LExpress∫`
        - いくつか組み込みで変数を定義している。(`L`から始まる)  
            `＄LMeta＝⟪¥Ø¦¥❰¦¥❱¦¥⟪¦¥⟫¦¥⟦¦¥⟧¦¥【¦¥⇒¦¥∠¦¥⸨¦¥⸩¦¥】¦¥○¦¥∫¦¥∮¦¥『¦¥』¦¥≪¦¥●¦¥≫¦¥¦¦¥┃¦¥：¦¥＄¦¥＃¦¥＝¦¥✖¦¥＠¦¥％¦¥～¦¥⊃¦¥∸¦¥⚺¦¥∪¦¥∩¦¥≡¦¥¥¦¥｡¦¥⏎¦¥｢¦¥｣¦¥∥¦¥〖¦¥〗⟫`『メタ文字  
            `＄LChar＝❰⟪U+┃～0x10FFFF⟫∸⟪∫LMeta∫⟫❱`『Unicodeからメタ文字を抜いた任意の文字 (追記:メタ文字は文字として扱わないから抜かないかも知れない←の追記:言語表現のメタ文字と交じるからダメ)  
            `＄LToken＝❰❰Ø❱∪⟦1～⟧∫LChar∫❱`『ヌルかメタ文字を含んでいない任意の文字列(空集合は含まない)(原子論理式のようなもの)  
            『LExpress: メタ文字による操作を含むかもしれない文字列(空集合は含まない)(論理式のようなもの)(下の式は、正確には正しくない表現)  
            `＄LExpress＝❰⟦1～⟧⟪｡∫LExpress∫¦∫LToken∫¦∮BINARY_EXPRESS∮¦∮SERIAL_UNARY_OP∮∫LExpress∫¦∮VARIABLE∮¦∮XOR_EXPRESS∮¦∮INDEX_EXPRESS∮¦∮PERMUTATION_EXPRESS∮¦∮FOX_EXPRESS∮｡⟫❱`  
                `＃BINARY_EXPRESS＝≪●⟦∮BINARY_OP∮┃2～⟧●❰∫LExpress∫❱≫`  
                    `＃BINARY_OP＝≪●⟪⊃¦∪¦∸¦⚺¦∩¦≡⟫≫`  
                `＃SERIAL_UNARY_OP＝≪●⟦～⟧●❰∮UNARY_OP∮❱≫`  
                    `＃UNARY_OP＝≪●⟪＄∫LToken∫＝¦✖¦＠¦％¦∮REPLICATE_OP∮⟫≫`  
                    `＃REPLICATE_OP＝≪⟦｡｡｡●❰｡｡●＠●❰∫LExpress『区切り文字』∫❱●＠●❰┃❱●＠●❰⟪～⟫❱～●＠●❰⟪～⟫❱｡｡❱｡●∪｡●❰●＠●❰∫LExpress『区切り文字』∫❱┃⟪～⟫┃❱｡｡｡⟧≫`  
                `＃VARIABLE＝≪●＠●❰○❱∫LToken∫≫`  
                `＃XOR_EXPRESS＝≪⟪●⟦¦┃2～⟧●❰∫LExpress∫❱⟫≫`  
                `＃INDEX_EXPRESS＝≪⟪●＠●❰⟪0b¦0o¦0x¦U+⟫❱●＠●❰┃❱∫natNum∫●＠●⟪～¦<¦>¦<=¦>=⟫∫natNum∫●＠●❰┃❱●＠●❰⟪＃生成された数字(i)に演算する式＃⟫❱⟫≫`  
                    `＄natNum＝＠⟪＃自然数(＠⟪0b¦0o¦0x¦U+⟫で表せれる)＃⟫`  
                `＃PERMUTATION_EXPRESS＝≪⟪●⟦1～⟧●⟪｡｡∫LExpress∫｡¦｡⟦∫LExpress∫⟧｡¦｡⟦∫LToken∫：∫LExpress∫⟧｡｡⟫⟫≫`  
                `＃FOX_EXPRESS＝≪⟪＃∫LToken∫＃⟫≫`  

            `＄LAny＝⟪＃対象言語でその位置に出現可能な全てのトークン＃⟫`  
            `＄LReturn＝⟪＃それぞれの環境の改行＃⟫`  
            `＄LIndent＝⟪＃それぞれの環境の行を揃えたり見やすくするためのインデント＃⟫`  
            `＄LRetInd＝❰∫LReturn∫∫LIndent∫❱`  

- ブロック演算系  
    - Destruction(破棄(`✖`))  
        [表現] `¥✖∫LExpress∫`  
        [例] `{✖❰A❱} => {Ø}`  
        [説明] 廃棄％❰演算子❱(`✖`(U+2716))は`ブロック`を`破棄`します。  
        - [詳細]  
            `{✖∫LExpress∫} => {Ø}`  
            `✖`は`ブロック`に作用すると`Ø`になります。  

    - Xor構成系  
        - Xor(エックスオア(`¦`))  
            [表現] `¥⟪⟦¥¦┃2～⟧∫LExpress∫¥⟫`  
            [例] `{⟪A¦B⟫} => {{❰A❱}または{❰B❱}}`『`⟪A¦B⟫`という`Xorブロック`から、`❰A❱`というトークンブロックを返す または `❰B❱`というトークンブロックを返します。  
            [説明] Xor％❰ブロック❱(`¦`(U+00A6))は、`与えられた式`から`一つ選び`トークンブロックを生成して返します。  
            - [詳細]  
                このXorブロックは言語表現(Language expression)の中で`一番重要で中心的な処理`である。  
                `与えられた式`から`一つ選び`ますが、`どう選ぶかは定義しません`。  
                ただ、`⟪A¦B⟫`という文から`❰A❱`が選ばれる`可能性`もあるし、`❰B❱`が選ばれる`可能性`もある。と考えてください。  

        - Option(オプション(`＠`))  
            [表現] `¥＠∫LExpress∫`  
            [例] `{＠❰A❱} => {⟪Ø¦A⟫}, {＠⟪A¦B⟫} => {⟪Ø¦A¦B⟫}`  
            [説明] オプション％❰演算子❱(`＠`(U+FF20))は、ブロックに`Ø`が選択される可能性を`Xor`で足します。  

        - Default(デフォルト(`％`))  
            [表現] `¥％∫LExpress∫`  
            [例] `{％❰A❱} => {⟪Ø¦A⟫}, {％⟪A¦B⟫} => {⟪Ø¦A¦B⟫}`  
            [説明] デフォルト％❰演算子❱(％(U+FF05))は、Optionと全く同じ処理をします。  
            - [詳細]  
                `オプション`と`デフォルト`の`違い`は、メタ的な事柄によるものになります。  
                この言語表現(Language expression)は、大抵の場合、対象となる`モデル`(大体はプログラミング言語かな)が存在すると思います。  
                その中で、`あるトークン`が`明記していなくても、明記したのと変わらない事を示す`ために`デフォルト`が使われます。  
                - [考え方]  
                    [具体例] `私は％❰｡｡⟪％❰財布から❱¦口から⟫⟪100円¦400円⟫を出して｡｡❱買った。`, `class C{％❰private❱ int n;}`  
                    この様に書かなくてもわかる事やプログラミング言語的に決められている事に対して効果があります。  
                    `＠⟪％❰A❱¦B⟫`の様に`Xorブロック内`で使われた場合、`Ø`であったとしてもモデルの中では`❰A❱`であることを示す。  

        - Index(インデックス(`┃～`))  
            [表現] `¥⟪＠⟪0b¦0o¦0x¦U+⟫＠❰¥┃❱∫natNum∫＠⟪¥～¦<¦>¦<=¦>=⟫∫natNum∫＠❰¥┃❱＠⟪＃生成された数字(i)に演算する式＃⟫¥⟫  ＄natNum＝＠⟪＃自然数(＠⟪0b¦0o¦0x¦U+⟫で表せれる)＃⟫`  
            [例] `{⟪1～3⟫ => ⟪1¦2¦3⟫}, {⟪～2⟫} => {⟪0¦1¦2⟫}, {⟪2～⟫} => {⟪2¦3¦4¦..⟫}, {⟪～⟫} => {⟪0¦1¦2¦..⟫}`  
                 `{⟪0x┃0b11111110～0b11111111⟫} => {⟪0xFE¦0xFF⟫}, {⟪2～4┃2^i⟫} => {⟪4¦8¦16⟫}, {⟪┃4┃⟫} => {❰4❱}, {⟪0b┃0x10┃i*2⟫} =>{❰0b100000❱}`  
            [説明] インデックス％❰ブロック❱(`┃～`(U+FF5E,U+2503))は、自然数を0個～2個を引数に取り、その`範囲`を`Xorで繋げたもの`をXorブロックかトークンブロックで返します。  
            - [詳細]  
                開始の自然数を省略すると`0～指定の数`になります。  
                `{⟪～2⟫} => {⟪0～2⟫} => {⟪0¦1¦2⟫}`  
                終了の自然数を省略すると`指定の数～無限`になります。  
                `{⟪2～⟫} => {⟪2¦3¦4¦..⟫}`  
                両方の自然数を省略すると`0～無限`になります。  
                `{⟪～⟫}  => {⟪0¦1¦2¦..⟫}`  
                両方の自然数を同じにするとその自然数になり`トークンブロック`で返ります。  
                `{⟪2～2⟫} => {❰2❱}`  
                引数に使う進数と文字(Unicode)と返り値に使う進数と文字(Unicode)を指定できます。  
                `{⟪0x┃0b11111110～0b11111111⟫} => {⟪0xFE¦0xFF⟫} {⟪U+┃U+A～U+B⟫} => {⟪A¦B¦C⟫}`  
                生成された値(i)に演算(2^i)する事でその値を返せます。  
                `{⟪2～4┃2^i⟫} => {⟪4¦8¦16⟫}`  
                C言語のfor文と同じように範囲とカウントを指定できる。初期値は不等式の左項になる。  
                `{⟪2<=9┃i+=2⟫} => {⟪2¦4¦6¦8⟫}` `{⟪U+┃U+あ<=U+お┃i+=2⟫} => {⟪あ¦い¦う¦え¦お⟫}`  
                数字に範囲がない場合、一つの数字で表せられます。  
                `{⟪┃4┃⟫} <=> {⟪4～4⟫} => {❰4❱}`  

        - Replicate(レプリケート(`⟦┃～⟧`))  
            [表現] `¥⟦｡｡｡❰｡｡＠∫LExpress『区切り文字』∫＠❰¥┃❱＠⟪～⟫¥～＠⟪～⟫｡｡❱｡∪｡❰＠∫LExpress『区切り文字』∫¥┃⟪～⟫¥┃❱｡｡｡¥⟧∫LExpress∫ (正確には少し正しくない表現)`  
            [例] `{⟦,┃1～3⟧❰A❱} => {⟪A¦A,A¦A,A,A⟫}`  
            [説明] レプリケート％❰演算子❱(`⟦┃～⟧`(U+27E6,U+2503,U+FF5E,U+27E7))は、指定回数分、式を複製し、複製と複製の間を`区切り文字`で区切ります。そして、  
                   それを、指定回数の範囲分複製し、それを`Xor`で繋げます。  
            - [詳細]  
                `,`は区切り文字となり、1～3は1回,2回,3回の複製のパターン全てを`Xor`で繋げる。  
                `{⟦,┃1～3⟧❰A❱} => {⟪A¦A,A¦A,A,A⟫}`  
                区切り文字を省略して無くすことができる。  
                `{⟦2～4⟧❰A❱} => {⟪AA¦AAA¦AAAA⟫}`  
                ～4として開始の回数を省略すると0～4の意味となり0回から複製が開始される  
                `{⟦～4⟧❰A❱} => {⟪Ø¦A¦AA¦AAA¦AAAA⟫}`  
                2～として終了の回数を省略すると2～無限の意味となり複製が無限に続く  
                `{⟦2～⟧❰A❱} => {⟪AA¦AAA¦..⟫}`  
                ～とすると0～無限の意味となり0回から複製が無限に続く  
                `{⟦～⟧❰A❱} => {⟪Ø¦A¦AA¦..⟫}`  
                複製が無限の時に区切り文字が指定されても無限に続く最後は`A`で終わる  
                `{⟦,┃～⟧❰A❱} => {⟪Ø¦A¦A,A¦..,A⟫}`  
                指定回数の範囲が無い場合、`┃`で囲むことで数字を1個にできる。そして返り値がトークンブロックになる。  
                `{⟦,┃2～2⟧❰A❱} <=> {⟦,┃2┃⟧❰A❱} => {❰A,A❱}`, `{⟦2～2⟧❰A❱} <=> {⟦┃2┃⟧❰A❱} => {❰AA❱}`  

        - Permutation(置換(`⟦：⟧`))  
            [表現] `¥⟪⟦1～⟧⟪｡｡∫LExpress∫｡¦｡¥⟦∫LExpress∫¥⟧｡¦｡¥⟦∫LToken∫¥：∫LExpress∫¥⟧｡｡⟫¥⟫`『`⟦..⟧`が一つ以上出現すること  
            [例] `⟪⟦1⟧ + ⟦2⟧ * ⟦3⟧⟫ => ⟪1 + 2 * 3¦1 + 3 * 2¦2 + 1 * 3¦2 + 3 * 1¦3 + 1 * 2¦3 + 2 * 1⟫`  
            [説明] 置換(`⟦：⟧`(U+27E6,U+FF1A,U+27E7))は、複数の`⟦∫LExpress∫⟧`の並び替えた全ての結果を`Xor`で繋ぐ。(`[例]`の場合は3!=6個の並び替え)  
            - [詳細]  
                `⟦∫LToken∫：∫LExpress∫⟧`とする事で、同じ`∫LToken∫`同士で並び替えする事ができる(この場合は3!*2!=12個の並び替え)  
                `{⟪⟦1⟧ ⟦op：+⟧ ⟦2⟧ ⟦op：*⟧ ⟦3⟧⟫} => {⟪1 + 2 * 3¦1 + 3 * 2¦2 + 1 * 3¦2 + 3 * 1¦3 + 1 * 2¦3 + 2 * 1¦⏎`  
                                                   `1 * 2 + 3¦1 * 3 + 2¦2 * 1 + 3¦2 * 3 + 1¦3 * 1 + 2¦3 * 2 + 1⟫}`  

        - Fox(フォックス(`＃`))  
            [表現] `¥⟪¥＃∫LToken∫¥＃¥⟫`  
            [例]  `{⟪＃π＃⟫} => {❰3.1415926..❱}, {⟪＃GAFA＃⟫} => {⟪google¦amazon¦facebook¦apple⟫}, {⟪＃ウニの数え方＃⟫} => {⟪⟪1～⟫⟪壺¦個¦腹¦匹⟫⟫} => {Xorブロック}`  
            [説明] フォックス％❰ブロック❱(`＃`(U+FF03))は、引数の文字列から分かる集合を`Xor構成系`で表現し`Xorブロック`または`トークンブロック`で返す。~~(ｲﾝﾁｷ臭いブロック関数である)~~  

    - XorSync(エックスオアシンクロナイズ(`○¦`,`●¦`))
        [表現] `¥○¥¦＄Sync＝∫LToken∫⟪＃Xor構成系＃⟫｡｡∫LAny∫｡｡¥○¥¦○∫Sync∫⟪＃Xor構成系＃⟫`
        [例] `{○¦AB⟪A0¦A1¦A2⟫ xxxx ○¦AB⟪B0¦B1¦B2⟫} => {⟪A0 xxxx B0¦A1 xxxx B1¦A2 xxxx B2⟫}, {○¦At＠❰A❱ xxxx ○¦At⟦,┃2┃⟧❰R❱} => {⟪ xxxx R¦A xxxx R,R⟫}`
        [説明] エックスオアシンクロナイズ(`○¦`(U+25CB,U+00A6))は、Xor構成系に直に付き、同じキー(`∫Sync∫`)をもつ`XorSync(○¦)`と同期する (Xor構成系直付きなのは複雑になりそうだから)
        - [詳細]
            ⟪Xor¦XorSync⟫の中にXorSyncが入った場合、XorSyncが選ばれた時だけ同期する
            `{⟪A¦○¦Inner⟪I0¦I1⟫⟫_○¦Inner⟪N0¦N1⟫} => {⟪A_N0¦A_N1¦I0_N0¦I1_N1⟫}`
            3つ以上同期することもある
            `{○¦Some⟪A0¦A1⟫_○¦Some⟪B0¦B1⟫_○¦Some⟪C0¦C1⟫} => {⟪A0_B0_C0¦A1_B1_C1⟫}`
            同じキーのXorSyncの要素数が違い、多い要素数のXorSyncの連番の大きい要素が選択された場合、少ない要素数のXorSyncは最後の要素が選択される
            `{○¦Length⟪A0¦AOther⟫_○¦Length⟪B0¦B1¦BOther⟫_○¦Length⟪C0¦C1¦C2¦COther⟫} => {⟪A0_B0_C0¦AOther_B1_C1¦AOther_BOther_C2¦AOther_BOther_COther⟫}`
            XorSyncが非同期変数,抽出変数,レプリケート,Foxなどで複製された場合、`○¦`は複製間で別々のID(`_N`)を振り、`●¦`は複製間で別々のIDを振らない。つまり`●¦`の場合は複製間でも同期します
            `{＄AVal＝○¦Async⟪A¦B⟫_∫AVal∫_∫AVal∫} => {○¦Async⟪A¦B⟫_○¦Async_1⟪A¦B⟫_○¦Async_2⟪A¦B⟫}`
            `{＄SVal＝●¦Sync⟪A¦B⟫_∫SVal∫_∫SVal∫} => {●¦Sync⟪A¦B⟫_●¦Sync⟪A¦B⟫_●¦Sync⟪A¦B⟫}`
            `○¦`と`●¦`で同じキーを付けることはできません
            `✖{○¦Same⟪A¦B⟫_●¦Same⟪C¦D⟫}`

    - Xor集合演算系
        - XorSyncの集合演算
            キーが違うまたは⟪Xor¦XorSync⟫ブロック内のXorSyncは単純にトークンとして⟪比較¦演算⟫される
            `＃SET_OP＝≪●⟪⊃¦≡¦∪¦∩¦∸¦⚺⟫≫ {○¦K0⟪A0¦B0⟫∮SET_OP∮○¦K1⟪A1¦B1⟫} => {❰¥○¥¦K0¥⟪A0¥¦B0¥⟫❱∮SET_OP∮❰¥○¥¦K1¥⟪A1¥¦B1¥⟫❱}`
            キーが同じかつ⟪Xor¦XorSync⟫ブロック内では無いXorSyncは⟪比較¦演算⟫できる
            `{❰○¦K⟪A¦B⟫❱⚺❰○¦K⟪B¦○¦K⟪C¦D⟫⟫❱} => {❰○¦K⟪A¦B⟫❱⚺❰○¦K⟪B¦❰¥○¥¦K¥⟪C¥¦D¥⟫❱⟫❱} => {❰○¦K⟪A¦○¦K⟪C¦D⟫⟫❱}`
        - Xor集合比較演算系  
            - Inclusion(包含(`⊃`))  
                [表現] `∫LExpress∫¥⊃∫LExpress∫`  
                [例] `{⟪A¦B¦C⟫⊃⟪A¦B⟫} => {⟪A¦B⟫}, {⟪A¦B⟫⊃⟪A¦B¦C⟫} => {Ø}`  
                [説明] 包含(`⊃`(U+2283))は、`式のXorの連なり`において、`左項の⟪トークン¦Xor⟫ブロック`が`右項の⟪トークン¦Xor⟫ブロック`の`部分集合`になっているか検証し、  
                       なっていれば`右項`をそのまま返し、なっていなければ`Ø`を返します。  
                - [詳細]  
                    `⟪A¦B¦C⟫`は`⟪A¦B⟫`の`部分集合`なので`右項(⟪A¦B⟫)`が返ります。  
                    `{⟪A¦B¦C⟫⊃⟪A¦B⟫} => {⟪A¦B⟫}`  

            - Equal(イコール(`≡`))  
                [表現] `∫LExpress∫¥≡∫LExpress∫`  
                [例] `{⟪A¦B⟫≡⟪A¦B⟫} => {⟪A¦B⟫}, {⟪A¦B¦C⟫≡⟪A¦B⟫} => {Ø}`  
                [説明] イコール(`≡`(U+2261))は、`式のXorの連なり`において、`左項の⟪トークン¦Xor⟫ブロック`と`右項の⟪トークン¦Xor⟫ブロック`が`等しい集合`になっているか検証し、  
                       なっていれば`その集合のXorの連なり`をそのまま返し、なっていなければ`Ø`を返します。  

        - Union(和集合(`∪`))  
            [表現] `∫LExpress∫¥∪∫LExpress∫`  
            [例] `{⟪A¦B⟫∪⟪B¦C⟫} => {⟪A¦B¦C⟫}`  
            [説明] 和集合(`∪`(U+222A))は、`式のXorの連なり`において、`左項の⟪トークン¦Xor⟫ブロック`と`右項の⟪トークン¦Xor⟫ブロック`の`和集合`を取り、  
                   `その集合のXorの連なり`を返します。  
            - [詳細]  
                `⟪トークン¦Xor⟫ブロック`を`和集合で繋げた`ものと、`Xorで繋げたもの`は、`同値`になります。  
                `{{⟪A¦B⟫∪⟪B¦C⟫∪❰D❱} => {⟪A¦B¦C¦D⟫}} ⇔ {{⟪⟪A¦B⟫｡¦｡⟪B¦C⟫｡¦｡❰D❱⟫} => {⟪A¦B¦C¦D⟫}}`  

        - Meet(積集合(`∩`))  
            [表現] `∫LExpress∫¥∩∫LExpress∫`  
            [例] `{⟪A¦B⟫∩⟪B¦C⟫} => {❰B❱}`  
            [説明] 積集合(`∩`(U+2229))は、`式のXorの連なり`において、`左項の⟪トークン¦Xor⟫ブロック`と`右項の⟪トークン¦Xor⟫ブロック`の`積集合`を取り、  
                   `その集合のXorの連なり`を返します。  

        - Difference(差集合(`∸`))  
            [表現] `∫LExpress∫¥∸∫LExpress∫`  
            [例] `{⟪A¦B⟫∸⟪B¦C⟫} => {❰A❱}`  
            [説明] 差集合(`∸`(U+2238))は、`式のXorの連なり`において、`左項の⟪トークン¦Xor⟫ブロック`と`右項の⟪トークン¦Xor⟫ブロック`の`差集合`を取り、  
                   `その集合のXorの連なり`を返します。  

        - Exclusive(排他集合(`⚺`))  
            [表現] `∫LExpress∫¥⚺∫LExpress∫`  
            [例] `{⟪A¦B⟫⚺⟪B¦C⟫} => {⟪A¦C⟫}`  
            [説明] 排他集合(`⚺`(U+26BA))は、`式のXorの連なり`において、`左項の⟪トークン¦Xor⟫ブロック`と`右項の⟪トークン¦Xor⟫ブロック`の`排他集合`を取り、  
                   `その集合のXorの連なり`を返します。  

- Xor結合 (XorSync(`○¦`)と同期代入(`○∫∫`)はトークンとして処理される(XorSyncの中のXorは普通に処理される)) (追記:式木の底から再帰的に[Xor結合] => [Xor集合演算]かも)  
    [表現] `＄recursion＝❰¥❰｡｡｡∫LToken∫∪⟦～⟧⟪｡｡¥⟪｡⟦¥¦┃2～⟧⟪∫LToken∫¦∫recursion∫⟫｡¥⟫｡¦｡∫recursion∫｡｡⟫｡｡｡¥❱❱`  
    [例] `{❰⟪A¦B⟫C❱} => {⟪AC¦BC⟫}, {❰⟪A¦B⟫⟪C¦D⟫❱} => {⟪AC¦AD¦BC¦BD⟫}, {⟪A¦⟪B¦C⟫¦D⟫} => {⟪A¦B¦C¦D⟫}`  
    [説明]  `Xor結合`は`トークブロック内`にある`Xor集合演算子`をまたがない`複数`の`Xorブロック`を`一つ`の`Xorブロック`にまとめます。  
    - [詳細]  
        まとめ方は`式の構造`によって`3種類`あり次の順で実行します。  
        1つ目は`Xorブロック`が`ネスト`しているパターン  
        2つ目は`Xorブロック`が`トークンブロック上`に`横に並んでいる`パターン  
        3つ目は`要素が重複`しているパターン  
        この`3種類のまとめ方`を`式木`の`一番底`から`再帰的に適用`し`一つのXorブロック`にまとめます。  

        1. `ネスト`しているパターン  
            `ネスト`している場合は、`内側`の`Xorブロックのブロック(⟪⟫)`を外します。  
            `{⟪A¦_⟪B¦C⟫_¦D⟫} => {⟪A¦_B_¦_C_¦D⟫}`  

        2. `トークンブロック上`に`横に並んでいる`パターン  
            `横に並んでいる`場合は、`Xorの選択`として`ありえる組み合わせ`の`全てのパターンを網羅`しそれを`一つのXor`で表します。  
            具体的には、`横に並んでいるXor`を一つのXorにつき一つずつ選ぶ`組み合わせ`になります。  
            `{❰⟪A¦B⟫_⟪C¦D⟫❱} => {⟪A_C¦A_D¦B_C¦B_D⟫}`『この場合2 * 2 = 4通り  

        3. `要素が重複`しているパターン
            `要素が重複`した場合は`一つにまとめます`。  
            `{⟪A¦B¦B⟫} => {⟪A¦B⟫}`  

- line(ライン)  
    ("\_"はスペース、"\n"は改行コードとする。)  
    [表現] `＄recursion＝❰¥❰｡｡｡∫LToken∫∸⟪_¦\n¦Ø⟫∪❰⟦～⟧⟪｡｡¥Ø｡¦｡⟦～⟧⟪_¦\n⟫｡¦｡∫recursion∫｡｡⟫❱｡｡｡¥❱❱`  
    [例]  `{❰_❰A❱_Ø_\n_B__❱} => {❰_A_Ø_\n_B__❱} => {❰_A_\n_B__❱} => {_A_\n_B__}`  
    [説明] ラインは、`トークンブロック`(`❰❱`)と`ヌル`(`Ø`)を除去して`一つの文`にまとめます。  
    - [詳細]  
        `トークンブロック`を`除去`します。  
        `{❰A❱} => {A}`  
        - `ヌル(Ø)`の`解決`  
            `ヌル`単体か、`ヌルの前後に隣接している改行かスペースの連なり`があり`先頭と末尾に改行かスペース以外の文字`がある場合`以外`の場合、  
                `ヌル`と`隣接している改行とスペースの連なり`を`除去`します。  
            `{Ø} => {}`, `{❰_\n_\nØ_\n❱} => {❰❱} => {}`, `{❰A_\n_\nØ_\n❱} => {❰A❱} => {A}`, `{❰_\n_\nØ_\nB❱} => {❰B❱} => {B}`  
            `ヌル`の`前後に隣接している改行かスペースの連なり`があり`先頭と末尾に改行かスペース以外の文字`がある場合、`ヌル`と`前方の隣接している改行とスペースの連なりのみ`を`除去`します。  
            `{❰A_\n_\nØ_\nB❱} => {❰A_\nB❱} => {A_\nB}`  

        この`トークンブロック`(`❰❱`)と`ヌル`(`Ø`)の除去を`式木`の`一番底`から`再帰的に適用`し`一つの文`にまとめます。  

        - 複雑な例  
            `{❰_Ø_❰_A_Ø_B_❰_Ø_❱❰_C_❱_D_❱_Ø_E❱}`  
            =>  
            `{❰_Ø_❰_A_Ø_B_❰❱❰_C_❱_D_❱_Ø_E❱}`  
            =>  
            `{❰_Ø_❰_A_B__C__D_❱_Ø_E❱}`  
            =>  
            `{❰_A_B__C__D__E❱}`  
            =>  
            `{_A_B__C__D__E}`  
