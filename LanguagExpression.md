`❰\u{2770}❱\u{2771}ˆ\u{2C6}¦\u{A6}≈\u{2248}∫\u{222B}＃\u{FF03}＄\u{FF04}＠\u{FF20}％\u{FF05}＆\u{FF06}⇒\u{21D2}⟪\u{27EA}⟫\u{27EB}`  
`❰❱ˆ¦≈∫＃＄＠％＆⇒⟪⟫！⏎✖｡` //！⏎✖｡追加  [Tab] [Alt] []<=括弧記号考える  
✖⏎//改行とスペース禁止  
❰小括弧❱❰｡中括弧｡❱❰｡｡大括弧｡｡❱ ｡¦｡  ｡はスペース替わりにも使える
拡張BNF…  \\n
基礎([token](#token), [token block](#tokenb)) -> [xorステージ](#xors) -> [xor変換系](#xorc) -> [合成ステージ](#gousei) -> [tagステージ](#tag) -> [variableステージ](#var) -> [`xorとスキップと"∫∫"とlineステージによる構造と評価手順`](#tegyun)  
↑をさらっと読んだほうが分かりやすいかも  


- `{..} => {..}`という表現について  
    `＠❰..:❱{..} => {..}`という表現は、`{..}`内(または`❰..❱`)になんらかの`評価する対象`があり`=>`の`前`が`評価前`を表し、`後`が`評価後`を表す。  
    [例] `+:{1+2} => {3}`というのは、評価する対象`+`があり、評価前は`1+2`で評価後は`3`である。  
- `[表現]`について  
    `[表現]`は`変数ブロックとFoxブロックが評価された直後の状態を表す`とし、その項で説明している`メタ文字`の`使われ方を表現`している。  
- `∫LExpress∫`は`言語表現`を使って`構成`された`任意の式`である。`∫LExpress∫`を単に`式`または`ブロック`と呼ぶ場合がある。  

# 言語表現(LanguageExpression)  

- 基礎  
    - Token(トークン) <a id="token"></a>  
        [表現] `∫LToken∫`  
        [例] `{❰static❱}の{static}, {❰System❰.Object❱❱}の{System,.Object},`  
             `{❰ A B C ❱}の{ A B C }, {⟪肉¦魚⟫}の{肉,魚}, {⟪ans = ⟦1.0⟧ / ⟦2.0⟧⟫}の{ans = ,1.0, / ,2.0}がトークン`  
        [説明] トークンとは、`ほぼ任意の文字列`と`Null(ヌル)(Ø)`です。`トークンブロック(❰❱)`または`関数ブロック(⟪⟫)`内でのみ現れる必要がある。  
                ほぼ任意とは、この言語表現(LanguageExpression)を構成する(エスケープされていない)構成文字(❰❱¦＄＝∫などの特殊文字)(メタ文字とも言う)が含まれない文字列。  
        - [詳細]  
            `トークン`とは言語表現によって組み替えたり複製されたりして加工される文字列の事。  
            `変数ブロック`や`Fox関数ブロック`内の任意の文字列は変換されるためだけの文字列なのでトークンではない。  

        - Null(ヌル)(`Ø`)  
            [説明] ヌル％❰トークン❱(Ø(U+00D8))は、そこに`トークンが無い`事を示す。`ライン処理`で`解決`される。  

    - ブロック (`❰❱,⟪⟫,∫∫,○∫∫,【∠⸨⸩】`)  
        - Token block(トークンブロック(`❰❱`)) <a id="tokenb"></a>  
            [表現] `{¥❰∫LExpress∫¥❱}`  
            [例] `{❰token0❰token1❰token2❱❱❰token3❱❱}`  
            [説明] トークンブロック(`❰❱`(U+2770,U+2771))は、トークンを区切る役割を持つ。  
            - [詳細]  
                `{＠❰token❱}`の`"＠"`や`{❰token0❱∪❰token1❱}`の`"∪"`は`ブロック演算子`と言い`トークンブロック`に対して作用する。  

        - Function block(関数ブロック(`⟪⟫`(`¦,～,⟦：⟧,＃`)))  
            [表現] `{¥⟪｢各関数ブロックの中身｣¥⟫} (正確には正しくない表現)`  
            [例] `Xor: {⟪A¦B⟫}, Index: {⟪2～4⟫} => {⟪2¦3¦4⟫}, Permutation: {⟪⟦A⟧⟦B⟧⟫} => {⟪AB¦BA⟫}, Fox: {⟪＃五影＃⟫} => {⟪火影¦風影¦土影¦水影¦雷影⟫}`  
            [説明] 関数ブロック(`⟪⟫`(U+27EA,U+27EB))は、トークンまたは数値を引数に、新しい`Xorブロック`または`トークンブロック`を`生成して返します`。  
                   関数ブロックの種類は`Xor(¦)`,`Index(～)`,`Permutation(⟦：⟧)`,`Fox(＃)`があります。  

        - Variable block(変数ブロック(`∫∫,○∫∫`))  
            [表現] `⟪¥∫¦¥○¥∫⟫∫LToken∫¥∫`  
            [例] `{∫val∫} => {⟪A¦B⟫}, {○∫val∫} => {❰A❱}`  
            [説明] 変数ブロックは、`同期変数ブロック`(`○∫∫`)と`非同期変数ブロック`(`∫∫`)があり、評価するとその位置に代入された`式`を展開する。  
        
        - Edit extract block(抽出編集ブロック(`【⇒∠⸨⸩】`))  
            [表現] `＃OP：｢"⸨⸩"へのブロック演算系と変数など操作｣`  `(正確には正しくない表現)`  
                   `¥【∫LExpress∫｡⟦¥┃┃～⟧❰｡｡｡＠❰⇒∫LExpress∫❱｡⟦～⟧❰¥∠∫LExpress∫❱｡❰｡｡∠∫LExpress∫＃OP＃｡¥⸨⟪＃抽出式または抽出トークン＃⟫¥⸩｡＃OP＃∫LExpress∫｡｡❱｡｡｡❱¥】`  
            [例] `{【❰A❰B❱❱∠✖⸨B⸩】} => {❰A❰✖❰B❱❱❱}, {＄val＝❰A⟪B¦C⟫❱【∫val∫∠✖⸨B⸩】} => {❰A⟪✖❰B❱¦C⟫❱}`  
                 `{＄val0＝❰B∫val1∫❱ ＄val1＝❰B⟪D¦B⟫❱【❰A∫val0∫❱∠∫val0∫∠∫val1∫∠⟪D¦B⟫∠✖⸨B⸩】} => {❰A❰B❰B⟪D¦✖❰B❱⟫❱❱❱}`  
                 `{【❰⟪A¦B¦C⟫⟪D¦E⟫❱⇒❰⟪A¦B⟫⟪D¦E⟫❱∠⸨⟪D¦E⟫⸩⊃❰D❱】} => {⟪CD¦CE¦AD¦BD⟫}`  
            [説明] 抽出編集ブロック(`【⇒∠⸨⸩】`(U+3010,U+21D2,U+2220,U+2E28,U+2E29,U+3011))は、  
                   `式`の`部分`を`抽出`し`編集`してしまう、`式木の部分木`に`変更を加える`やばいブロックである。  
            - [詳細]  
                下の抽出編集ブロックの`一番左`は`抽出される元になる式`(`❰A⟪B¦C⟫❱`)これを`抽出元`と呼ぶ。  
                次に`∠`は、`抽出編集ブロック内のみ`で使える記号で`抽出子`と呼び、左項の`式の部分`を右項に表し`抽出`を表しています。  
                抽出の仕方は2種類あり、左から1番目の`抽出子`は`式から式`を抽出(`⟪B¦｡CD｡E⟫`(`抽出式`と呼ぶ))し、  
                2番目の`抽出子`は`式からトークンの連続部分文字列`を抽出(`CD`(`抽出トークン`と呼ぶ))しています。  
                そして最後に抽出したものを`⸨⸩`で囲みそこに`ブロック演算系`や`変数`など色々な操作を加え、それが`抽出元に反映`され、そしてそれが`返ります`。  
                `{【❰A⟪B¦｡CD｡E⟫❱∠⟪B¦｡CD｡E⟫∠G⟪✖⸨CD⸩¦F⟫H】} => {❰A⟪B¦｡❰G⟪✖❰CD❱¦F⟫H❱｡E⟫❱}`  

                `抽出元`が`変数ブロック`であっても`変数の定義元を参照`し`抽出`することができます。  
                `{＄val＝❰A⟪B¦C⟫❱【∫val∫∠✖⸨B⸩】} => {【❰A⟪B¦C⟫❱∠✖⸨B⸩】} => {❰A⟪✖❰B❱¦C⟫❱}, `  

                `抽出トークン`は、`連続した範囲(連続部分文字列)`を`抽出`できます。`❰ABCD❱`の場合、`連続した範囲の全ての集合`は`{ABCD,ABC,AB,A,BCD,BC,B,CD,C,D}`になります。  
                `{【❰ABCD❱∠✖⸨BC⸩】} => {❰A✖❰BC❱D❱}`  

                `抽出式`は、`抽出子`を連続して並べる事で、`式から式を抽出`し、`抽出した式をさらに抽出`する事で`抽出対象を絞り込む`ことができます。(式木を頂点から下るイメージ)  
                `{＄val0＝❰B⟪D¦B⟫❱【❰A❰B∫val0∫❱❱∠❰B∫val0∫❱∠∫val0∫∠⟪D¦B⟫∠✖⸨B⸩】} => {❰A❰B❰B⟪D¦✖❰B❱⟫❱❱❱}`  
                `抽出元`から`一段ずつ抽出しなくても`一気に`複数段とんで抽出`する事ができます。  
                `{＄val0＝❰B⟪D¦B⟫❱【❰A❰B∫val0∫❱❱∠⟪D¦B⟫∠✖⸨B⸩】} => {❰A❰B❰B⟪D¦✖❰B❱⟫❱❱❱}`  
                `抽出対象の絞り込み`をしないと、`抽出元`の`式木に現れる全ての対象`から`抽出`されてしまいます。  
                `{＄val0＝❰B⟪D¦B⟫❱【❰A❰B∫val0∫❱❱∠✖⸨B⸩】} => {❰A❰✖❰B❱❰✖❰B❱⟪D¦✖❰B❱⟫❱❱❱}`  

                - 抽出式の代入  
                    `抽出式の代入`は`抽出元`と`同期`します。  
                    `{【❰A＄val0＝⟪B¦C⟫❱∠＄val1＝⸨⟪B¦C⟫⸩】} => {{○∫val0∫}⇔{○∫val1∫}}` ｢`val0`と`val1`は`同期`している。  

                - `┃`の`連続抽出編集`  
                    `抽出子`による操作を`┃で区切る`ことで、`抽出編集ブロック`を`ネスト`したものに変換できる。  
                    `{【❰ABCD❱∠✖⸨B⸩┃∠✖⸨D⸩】} => {【【❰ABCD❱∠✖⸨B⸩】∠✖⸨D⸩】} => {【❰A✖❰B❱CD❱∠✖⸨D⸩】} => {❰A✖❰B❱C✖❰D❱❱}`  
                
                - 条件子(`⇒`)  
                    `⇒`の事を`条件子`と言い、`⇒`の`左項`を`編集元`、`右項`を`条件`と言います。  
                    条件子(`⇒`)は、包含(`⊃`)と似ていて、包含の[説明]の`ほぼ引き用`より、  
                    `左項の⟪トークン¦Xor⟫ブロック`が`右項の⟪トークン¦Xor⟫ブロック`の`部分集合`になっているか検証し、  
                    なっていれば`右項`をそのまま返し、なっていなければ`エラー`(`Ø`ではない)を返します。  
                    つまり、`部分集合`になっていれば処理に`成功`するが、なっていれば`失敗してエラー`となります。  
                    なので、`必ず`、`⇒`の`右項`は`左項`の`部分集合`になっていなければなりません。  
                    そして、この`条件子`を使った`抽出編集ブロック`の処理とは、  
                    `編集元`がある特定の`Xorの選択(条件)`になった場合、その`条件`の時だけ`編集元`の`構成(式木)`を`変更`している`様に見える`。様にします。。  
                    つまり、`編集元`で、`あるXorの選択`で`コレが選択`された`場合`は、`ある他のXorの選択`を`コレにして欲しい！`って時に使えます。  
                    `条件子`を使った`抽出編集ブロック`の使い方は、  
                    `編集元`に`条件`によって、`挙動を変えたい式`を入れます。次に、`条件`にその`条件の式`を入れます。  
                    そして、`条件`を`抽出元`と思い、それを`編集する文`を`抽出子(∠)`の右項に書きます。  
                    そして、この`条件子`を使った`抽出編集ブロック`を`評価`すると、`編集元`を`ある条件の時`に`挙動を変える式`が生成されます。  
                    `{【❰⟪A¦B¦C⟫⟪D¦E⟫❱⇒❰⟪A¦B⟫⟪D¦E⟫❱∠⸨⟪D¦E⟫⸩⊃❰D❱】} => {❰｡❰⟪A¦B¦C⟫⟪D¦E⟫❱∸❰⟪A¦B⟫⟪D¦E⟫❱｡❱∪【❰⟪A¦B⟫⟪D¦E⟫❱∠⸨⟪D¦E⟫⸩⊃❰D❱】} =>`  
                    `{❰｡⟪AD¦AE¦BD¦BE¦CD¦CE⟫∸⟪AD¦AE¦BD¦BE⟫｡❱∪❰⟪A¦B⟫❰⟪D¦E⟫❱⊃❰D❱❱} => {❰⟪CD¦CE⟫❱∪❰⟪A¦B⟫❰D❱❱} => {⟪CD¦CE¦AD¦BD⟫}`  

                    - 原理  
                        `条件子`を使った`抽出編集ブロック`の仕組みは、  
                        まず、`編集元`から`条件`を引いた`差集合(∸)`をとり、`編集元`から`条件の選択`が`現れない式の集合`を作ります。  
                        これが、`編集元`から`条件の選択`に`ならなかった場合`の`全ての選択の式の集合`になります。  
                        次に、`編集元の選択の部分`になる`条件`を、仮に何も`編集をしない`で、`さっきの差集合`に`和集合(∪)`で足すと、  
                        `{❰∫編集元∫∸∫条件∫❱∪∫条件∫} => {∫編集元∫}`  
                        と、なり`条件`と`条件以外`に`分けた`のを`足しわわせる`と元に戻り`編集元`は何も`編集していない`のと同じになります。  
                        そこで、`条件`を`編集`してから`足し合わせる`と、`条件の選択の場合の時`だけ`挙動が変わる式`ができます。  
                        `{【∫編集元∫⇒∫条件∫｢∠ ∫条件∫を抽出元として、その抽出と編集｣】} => {❰∫編集元∫∸∫条件∫❱∪【∫条件∫｢∠ ∫条件∫を抽出元として、その抽出と編集｣】}`  

    - Block operator(ブロック演算子(`＄＝,✖,＠,％,⟦┃～⟧,⊃,∪,∸,⚺,≡`))  
        [表現] `＄EscapedReplicateOp＝❰¥⟦｡｡｡❰｡｡＠∫LExpress｢区切り文字｣∫＠❰¥┃❱＠⟪～⟫¥～＠⟪～⟫｡｡❱｡∪｡❰¥┃⟪～⟫¥┃❱｡｡｡¥⟧❱`  
               `＄EscapedUnaryOp＝⟪¥＄∫LToken∫¥＝¦¥✖¦¥＠¦¥％¦∫EscapedReplicateOp∫⟫`  
               `＄EscapedBinaryOp＝⟪¥⊃¦¥∪¦¥∸¦¥⚺¦¥∩¦¥≡⟫`  
               `{∫EscapedUnaryOp∫｡∫LExpress∫}, {∫LExpress∫｡∫EscapedBinaryOp∫｡∫LExpress∫}`  
        [例] `{＠❰A❱} => {⟪A¦Ø⟫}, {✖⟪A¦B⟫} => {Ø}, {⟪A¦B¦C⟫⊃⟪A¦B⟫} => {⟪A¦B⟫}, {⟪A¦B¦C⟫∩⟪B¦C¦D⟫} => {⟪B¦C⟫}`  
        [説明] ブロック演算子には、`ブロック単項演算子`と`ブロック2項演算子`があります。  
               ブロック演算子は、`ブロック`に作用し、新しい`Xorブロック`または`トークンブロック`を`生成して返します`。  
               ブロック単項演算子は`代入演算子(＄＝)`,`破棄(✖)`,`オプション(＠)`,`デフォルト(％)`,`量化(⟦┃～⟧)`があります。  
               ブロック2項演算子は`インプ(⊃)`,`和(∪)`,`差(∸)`,`排他(⚺)`,`積(∩)`,`イコール(≡)`があります。  
               `ブロック単項演算子`は`左から作用`します。  

    - ブロック単項演算子の合成則 <a id="gousei"></a>  
        [表現] `⟦2～⟧∫EscapedUnaryOp∫｡∫LExpress∫`  
        [例] `{⟦～⟧＠❰A❱} ⇔ {⟦～⟧❰＠❰A❱❱}`  
        [説明] `ブロック単項演算子`が`トークンブロックの左側`に`連続して並んでいる`とき`トークンブロック`で`区切って作用`させるのと同じになります(`右結合`)。  

    - 関数ブロックとブロック演算子の評価順序と結合規則  
        評価順序は、  
            [`代入演算子(＄＝)(非同期の代入)`] => [`Xor(¦)以外のブロック`] => [`代入演算子(＄＝)以外のブロック単項演算子`] => [`Xor結合`] =>  
            [`包含(⊃)`] => [`差集合(∸)`] => [`排他集合(⚺)`] => [`和集合(∪)`] => [`積集合(∩)`] => [`イコール(≡)`] => [`Xor(¦)`] =>  
            [`代入演算子(＄＝)(同期の代入)`] => [`ライン`]  
        となります。  
        -[例]  
            ｢`非同期の代入`を`＄HiDouki＝`で表し、`同期の代入`を`＄Douki＝`で表している  
            `＄HiDouki＝:{＄HiDouki＝＠⟪⟦A⟧⟦B⟧⟫⊃⟪AB¦Ø⟫} => ⟦：⟧:{＄Douki＝＠⟪⟦A⟧⟦B⟧⟫⊃⟪AB¦Ø⟫} => ＠:{＄Douki＝＠⟪AB¦BA⟫⊃⟪AB¦Ø⟫} =>`  
            `⊃:{＄Douki＝⟪AB¦BA¦Ø⟫⊃⟪AB¦Ø⟫} => ¦:{＄Douki＝⟪AB¦Ø⟫} => ＄Douki＝:{＄Douki＝{❰AB❱}または{Ø}} => line:{{❰AB❱}または{Ø}} =>`  
            `{{AB}または{}}`  
        
        結合規則は、`ブロック単項演算子`は`右結合`、`ブロック2項演算子`は`左結合`です。  

        評価順序を変えたい場合はトークンブロック(`❰❱`)で囲むことにより変えることができます(数学の`()`と同じ様に)。  
        `{✖❰A❱∪❰B❱} => {Ø∪❰B❱} => {⟪Ø¦❰B❱⟫} => {❰B❱}`, `{✖❰❰A❱∪❰B❱❱} => {✖⟪❰A❱¦❰B❱⟫} => {Ø}`  

    - 補助機能  
        - Comment(コメント(`｢｣`))  
            [表現]`{¥｢⟪＃任意の文字列＃⟫¥｣},{¥｢⟪＃任意の文字列＃⟫}`   
            [例] `{｢コメント｣} => {}, {｢コメント   \n} => {}` (`\n`は改行コード)  
            [説明] コメント(`｢｣`(U+FF62,U+FF63))はC言語と同じで`//`は`｢`と同じで、`/**/`は`｢｣`と同じ。  

        - Escape(エスケープ(`¥`))  
            [表現] `{¥¥⟪＃メタ文字＃⟫}`  
            [例] `{¥＠}, {¥○¥∫val¥∫}`  
            [説明] エスケープ％❰演算子❱(`¥`(U+00A5))はC言語のエスケープ文字`\`と同じで`メタ文字`を`メタ文字ではない文字`にする。  

        - macro(マクロ(`＃＝≪●≫∮∮`))  
        [表現] (定義と代入)`¥＃○∫LToken∫¥＝¥≪⟪＃∫LExpress∫内のメタ文字に"¥●"が付いているかもしれない∫LExpress∫＃⟫≫`  
               (変数の使用)`¥∮○∫LToken∫¥∮`  
        [例] `＃REPLICATE_OP＝≪⟦｡｡｡●❰｡｡●＠●❰∫LExpress｢区切り文字｣∫❱●＠●❰┃❱●＠●❰⟪～⟫❱～●＠●❰⟪～⟫❱｡｡❱｡●∪｡●❰┃⟪～⟫┃❱｡｡｡⟧≫`  
        [説明] マクロ(`＃＝≪●≫`(U+FF03,U+FF1D,U+226A,U+25CF,U+226B,U+222E))は、`≪≫`内に書かれた`文字列`を`マクロ変数(MACRO)`に代入しをそのまま`マクロ変数の位置(∮MACRO∮)`に展開する。
               `{＃MACRO＝≪B≫ ❰A ∮MACRO∮ C❱} => {❰A B C❱} (❰A ❰B❱ C❱とならない)`  
        - [詳細]
            マクロは、`メタ文字`も`そのまま展開`します。  
            `{＃MACRO＝≪∪≫ ❰⟪A¦B⟫∮MACRO∮⟪B¦C⟫❱} => {❰⟪A¦B⟫∪⟪B¦C⟫❱}`  
            マクロは、`●`が付いた`メタ文字`を`評価`してから`マクロ(≪≫)以外`の場所に展開します。  
            `{＃MACRO＝≪●⟪∪¦∩⟫≫ {●⟪∪¦∩⟫} => {{∪}または{∩}} => {{❰⟪A¦B⟫∮MACRO∮⟪B¦C⟫❱} => {{❰⟪A¦B⟫∪⟪B¦C⟫❱}または{❰⟪A¦B⟫∩⟪B¦C⟫❱}}}`  
            `マクロからマクロへの展開`は`まだ評価せず`そのまま展開されます。  
            `{＃MACRO1＝≪●⟪∪¦∩⟫≫ ＃MACRO0＝≪●⟪∸¦∮MACRO1∮⟫≫} => {＃MACRO0＝≪●⟪∸¦●⟪∪¦∩⟫≫}`  

        - Space character(スペースキャラクタ(`｡`))  
            [表現] `⟪＃任意の文字列＃⟫¥｡⟪＃任意の文字列＃⟫`  
            [例] `{ldc⟪❰｡｡❰.i4❱＠⟪｡❰.⟪0~8⟫❱¦.m1¦.s｡⟫｡｡❱¦.i8¦.r4¦.r8⟫} => {ldc⟪❰❰.i4❱＠⟪❰.⟪0~8⟫❱¦.m1¦.s⟫❱¦.i8¦.r4¦.r8⟫}`  
                 `{＄Method＝⟪∫Normal_method∫｡¦｡∫Instance∫｡¦｡∫Static∫｡¦｡∫part_method∫｡¦｡∫Interface_method∫｡¦｡∫expr_method∫｡¦｡∫Tructor∫⊃⟪∫cctor∫¦∫ctor∫¦∫Finalize∫⟫｡¦⏎`  
                 `｡∫Prodexer∫⊃⟪∫Property∫¦∫Indexer∫⟫｡¦｡∫Iterator∫｡¦｡∫Extension∫｡¦｡∫Operator∫⟫} =>`  
                 `{＄Method＝⟪∫Normal_method∫¦∫Instance∫¦∫Static∫¦∫part_method∫¦∫Interface_method∫¦∫expr_method∫¦∫Tructor∫⊃⟪∫cctor∫¦∫ctor∫¦∫Finalize∫⟫¦⏎`  
                 `∫Prodexer∫⊃⟪∫Property∫¦∫Indexer∫⟫¦∫Iterator∫¦∫Extension∫¦∫Operator∫⟫}`  
            [説明] スペースキャラクタ(`｡`(U+FF61))は、`{｡} => {}`となり、ただ消えるだけで何もしません。スペースを`｡`で作って分かりやすさのために使います。  
                  通常のスペース` `は、`{ } => { }`となり` `は消えません。  
                  つまり、` `は`{⟪ A ¦ B ⟫} => {⟪ A ¦ B ⟫} => { A }`ですが、`｡`は`{⟪｡A｡¦｡B｡⟫} => {⟪A¦B⟫} => {A}`となります。  

        - 改行(`⏎`)  
            a  

- variable(変数(`＄＝`,`∫∫`,`○∫∫`)) <a id="var"></a>  
    [表現] (定義と代入)`¥＄○∫LToken∫¥＝∫LExpress∫`  
          (変数の使用)`⟪¥∫¦¥○¥∫⟫○∫LToken∫¥∫`  
    [例] (定義と代入)`{＄val＝⟪A¦B⟫} => {⟪A¦B⟫}`, (変数の使用)`{∫val∫} => {⟪A¦B⟫}`  
    [説明]  `代入％❰演算子❱`(`＄＝`(U+FF04,U+FF1D))は、変数に`式`を代入できる。  
            `同期変数％❰ブロック❱`(`○∫∫`(U+222B))と`非同期変数％❰ブロック❱`(`∫∫`)(まとめて`変数％❰ブロック❱`)は、それが使われた位置に代入された`式`を展開できる。 
    - [詳細]
        (定義と代入)`{＄val＝⟪A¦B⟫} => {⟪A¦B⟫}`
        `val`は定義された変数名でそれに`⟪A¦B⟫`を代入している。`＄val＝`の部分は評価すると消えるだけで右側の`⟪A¦B⟫`になんの影響も与えない。  
        (変数の使用)`{∫val∫} => {⟪A¦B⟫}`
        `∫val∫`の様に変数名を`∫`で囲むとその位置に代入された`⟪A¦B⟫`を展開する。
        - `○∫∫`の`同期変数ブロック`と`∫∫``非同期変数ブロック`の違い  
            とりあえず`val`を`＄val＝⟪A¦B⟫`の様に代入する。  
            このとき、`∫val∫`と書くと、その位置に`⟪A¦B⟫`が展開される。  
            そして、`○∫val∫`と書くと、大元の`⟪A¦B⟫`が`❰A❱`と決定されると`○∫val∫`の展開も`❰A❱`となる。同様に`❰B❱`と決定すると展開も`❰B❱`となる。  
            つまり、`❰∫val∫_∫val∫❱`と書くと`❰A_B❱`となるパターンがあり`∫val∫`と`∫val∫`の結果が違う事がありえるが、  
            `❰○∫val∫_○∫val∫❱`の場合は一つの大元の`⟪A¦B⟫`の決定により`❰A_A❱`か`❰B_B❱`しかありえない。  
        - `○∫∫`の`同期変数ブロック`は展開が`❰&Null❱`になる事がある。  
            とりあえず、`val`を`⟪＄val＝❰A❱¦❰B❱⟫`と言う状況で代入する。  
            このとき、`⟪＄val＝❰A❱¦❰B❱⟫`が`❰B❱`に決定して、`＄val＝❰A❱`が選択されなかった場合は、
            `○∫val∫`は`❰&Null❱`になります。`∫val∫`の場合は`❰A❱`になります。
        - いくつか組み込みで変数を定義している。(Lから始まる)  
            `＄LToken＝❰Ø❱∪❰＃メタ文字を含んでいない任意の文字列(空集合は含まない)＃❱`(原子論理式のようなもの) ⟪＃⟦～⟧❰U+⟪0x┃～⟫❱を文字コード化したもの＃⟫  
            LExpress: ブロック演算子による操作を含むかもしれない文字列(空集合は含まない)(論理式のようなもの)
            `＄LExpress＝❰⟦～⟧⟪｡∫LToken∫¦∮BINARY_EXPRESS∮¦∮SERIAL_UNARY_OP∮∫LExpress∫¦∮XOR_EXPRESS∮¦∮INDEX_EXPRESS∮¦∮PERMUTATION_EXPRESS∮¦∮FOX_EXPRESS∮｡⟫❱`  
                `＃BINARY_OP＝≪●⟪⊃¦∪¦∸¦⚺¦∩¦≡⟫≫`  
                `＃BINARY_EXPRESS＝≪●⟦∮BINARY_OP∮┃2～⟧●❰∫LExpress∫❱≫`  
                `＃REPLICATE_OP＝≪⟦｡｡｡●❰｡｡●＠●❰∫LExpress｢区切り文字｣∫❱●＠●❰┃❱●＠●❰⟪～⟫❱～●＠●❰⟪～⟫❱｡｡❱｡●∪｡●❰┃⟪～⟫┃❱｡｡｡⟧≫`  
                `＃UNARY_OP＝≪●⟪＄∫LToken∫＝¦✖¦＠¦％¦∮REPLICATE_OP∮⟫≫`  
                `＃SERIAL_UNARY_OP＝≪●⟦～⟧●❰∮UNARY_OP∮❱≫`
                `＃XOR_EXPRESS＝≪⟪●⟦¦┃2～⟧●❰∫LExpress∫❱⟫≫`  
                `＃INDEX_EXPRESS＝≪⟪＠⟪＃自然数＃⟫～＠⟪＃自然数＃⟫⟫≫`  
                `＃PERMUTATION_EXPRESS＝≪⟪●⟦1～⟧●⟪｡｡∫LExpress∫｡¦｡⟦∫LExpress∫⟧｡¦｡⟦∫LToken∫：∫LExpress∫⟧｡｡⟫⟫≫`  
                `＃FOX_EXPRESS＝≪⟪＃∫LToken∫＃⟫≫`  

            `＄LAny＝❰＃対象言語でその位置に出現可能な全てのトークン＃❱`  

- ブロック演算系  
    - Destruction(破棄(`✖`))  
        [表現] `¥✖∫LExpress∫`  
        [例] `{✖❰A❱} => {Ø}`  
        [説明] 廃棄％❰演算子❱(`✖`(U+2716))は`ブロック`を`破棄`します。  
        - [詳細]  
            `{✖∫LExpress∫} ⊃ {Ø}`  
            `✖`は`ブロック`に作用すると`Ø`になります。  

    - Xor構成系 <a id="xorc"></a>  
        - Xor(エックスオア(`¦`)) <a id="xors"></a>  `{⟪A¦B¦B⟫} => {⟪A¦B⟫}`
            [表現] `¥⟪⟦¥¦┃2～⟧∫LExpress∫¥⟫`  
            [例] `{⟪A¦B⟫} => {{❰A❱}または{❰B❱}}`｢`⟪A¦B⟫`という`Xorブロック`から、`❰A❱`というトークンブロックを返す または `❰B❱`というトークンブロックを返します。  
            [説明] Xor％❰ブロック❱(`¦`(U+00A6))は、`与えられたトークン`から`一つ選び`トークンブロックを生成して返します。  
            - [詳細]  
                このXorブロックは言語表現(LanguageExpression)の中で`一番重要で中心的な処理`である。  
                `与えられたトークン`から`一つ選び`ますが、`どう選ぶかは定義しません`。  
                ただ、`⟪A¦B⟫`という文から`❰A❱`が選ばれる`可能性`もあるし、`❰B❱`が選ばれる`可能性`もある。と考えてください。  

        - Option(オプション(`＠`))  
            [表現] `¥＠∫LExpress∫`  
            [例] `{＠❰A❱} => {⟪A¦❰&Null❱⟫}, {＠⟪A¦B⟫} => {⟪A¦B¦❰&Null❱⟫}`  
            [説明] オプション％❰演算子❱(`＠`(U+FF20))は、ブロックに`❰&Null❱`が選択される可能性を`Xor`で足します。  

        - Default(デフォルト(`％`))  
            [表現] `¥％∫LExpress∫`  
            [例] `{％❰A❱} => {⟪A¦❰&Null❱⟫}, {％⟪A¦B⟫} => {⟪A¦B¦❰&Null❱⟫}`  
            [説明] デフォルト％❰演算子❱(％(U+FF05))は、Optionと全く同じ処理をします。  
            - [詳細]  
                `オプション`と`デフォルト`の`違い`は、メタ的な事柄によるものになります。  
                この言語表現(LanguageExpression)は、大抵の場合、対象となる`モデル`(大体はプログラミング言語かな)が存在すると思います。  
                その中で、`あるトークン`が`明記していなくても、明記したのと変わらない事を示す`ために`デフォルト`が使われます。  
                - [考え方]  
                    [具体例] `私は％❰｡｡⟪％❰財布から❱¦口から⟫⟪100円¦400円⟫を出して｡｡❱買った。`, `class C{％❰private❱ int n;}`  
                    この様に書かなくてもわかる事やプログラミング言語的に決められている事に対して効果があります。  
                    `＠⟪％❰A❱¦B⟫`の様に`Xorブロック内`で使われた場合、`❰&Null❱`であったとしてもモデルの中では`❰A❱`であることを示す。  

        - Index(インデックス(`～`)) ⟪0x┃～0xFF┃2^i⟫,⟪┃2┃⟫,Operator(⟪2～4┃i*2⟫,⟪2～4┃2^i⟫)  
            [表現] `¥⟪＠⟪＃自然数＃⟫¥～＠⟪＃自然数＃⟫¥⟫`  
            [例] `{⟪1～3⟫ => ⟪1¦2¦3⟫}, {⟪～2⟫} => {⟪0¦1¦2⟫}, {⟪2～⟫} => {⟪2¦3¦4¦..⟫}, {⟪～⟫} => {⟪0¦1¦2¦..⟫}`  
            [説明] インデックス％❰ブロック❱(`～`(U+FF5E))は、自然数を0個～2個を引数に取り、その`範囲`を`Xorで繋げたもの`をXorブロックかトークンブロックで返します。  
            - [詳細]  
                開始の自然数を省略すると`0～2`になります。  
                `{⟪～2⟫} => {⟪0～2⟫} => {⟪0¦1¦2⟫}`  
                終了の自然数を省略すると`2～無限`になります。  
                `{⟪2～⟫} => {⟪2¦3¦4¦..⟫}`  
                両方の自然数を省略すると`0～無限`になります。  
                `{⟪～⟫}  => {⟪0¦1¦2¦..⟫}`  
                両方の自然数を同じにするとその自然数になり`トークンブロック`で返ります。  
                `{⟪2～2⟫} => {❰2❱}`  

        - Replicate(レプリケート(`⟦┃～⟧`))  
            [表現] `¥⟦｡｡｡❰｡｡＠∫LExpress｢区切り文字｣∫＠❰¥┃❱＠⟪～⟫¥～＠⟪～⟫｡｡❱｡∪｡❰¥┃⟪～⟫¥┃❱｡｡｡¥⟧∫LExpress∫ (正確には少し正しくない表現)`  
            [例] `{⟦,┃1～3⟧❰A❱} => {⟪A¦A,A¦A,A,A⟫}`  
            [説明] レプリケート％❰演算子❱(`⟦┃～⟧`(U+27E6,U+2503,U+FF5E,U+27E7))は、指定回数分、式を複製し、複製と複製の間を`区切り文字`で区切ります。そして、  
                   それを、指定回数の範囲分複製し、それを`Xor`で繋げます。  
            - [詳細]  
                `,`は区切り文字となり、1～3は1回,2回,3回の複製のパターン全てを`Xor`で繋げる。  
                `{⟦,┃1～3⟧❰A❱} => {⟪A¦A,A¦A,A,A⟫}`  
                区切り文字を省略して無くすことができる。  
                `{⟦2～4⟧❰A❱} => {⟪AA¦AAA¦AAAA⟫}`  
                ～4として開始の回数を省略すると0～4の意味となり0回から複製が開始される  
                `{⟦～4⟧❰A❱} => {⟪❰&Null❱¦A¦AA¦AAA¦AAAA⟫}`  
                2～として終了の回数を省略すると2～無限の意味となり複製が無限に続く  
                `{⟦2～⟧❰A❱} => {⟪AA¦AAA¦..⟫}`  
                ～とすると0～無限の意味となり0回から複製が無限に続く  
                `{⟦～⟧❰A❱} => {⟪❰&Null❱¦A¦AA¦..⟫}`  
                複製が無限の時に区切り文字が指定されても無限に続く最後は`A`で終わる  
                `{⟦,┃～⟧❰A❱} => {⟪❰&Null❱¦A¦A,A¦..,A⟫}`  
                指定回数の範囲が無い場合、`┃`で囲むことで数字を1個にできる。そして返り値がトークンブロックになる。  
                `{⟦,┃2～2⟧❰A❱} <=> {⟦,┃2┃⟧❰A❱} => {❰A,A❱}`, `{⟦┃2～2┃⟧❰A❱} <=> {⟦┃2┃⟧❰A❱} => {❰AA❱}`  
        
        - Permutation(置換(`⟦：⟧`))  
            [表現] `¥⟪⟦1～⟧⟪｡｡∫LExpress∫｡¦｡¥⟦∫LExpress∫¥⟧｡¦｡¥⟦∫LToken∫¥：∫LExpress∫¥⟧｡｡⟫¥⟫` ｢`⟦..⟧`が一つ以上出現すること  
            [例] `⟪⟦1⟧ + ⟦2⟧ * ⟦3⟧⟫ => ⟪1 + 2 * 3¦1 + 3 * 2¦2 + 1 * 3¦2 + 3 * 1¦3 + 1 * 2¦3 + 2 * 1⟫`  
            [説明] 置換(`⟦：⟧`(U+27E6,U+FF1A,U+27E7))は、複数の`⟦∫LExpress∫⟧`の並び替えた全ての結果を`Xor`で繋ぐ。(`[例]`の場合は3!=6個の並び替え)  
            - [詳細]  
                `⟦∫LToken∫：∫LExpress∫⟧`とする事で、同じ`∫LToken∫`同士で並び替えする事ができる(この場合は3!*2!=12個の並び替え)  
                `{⟪⟦1⟧ ⟦op：+⟧ ⟦2⟧ ⟦op：*⟧ ⟦3⟧⟫} => {⟪1 + 2 * 3¦1 + 3 * 2¦2 + 1 * 3¦2 + 3 * 1¦3 + 1 * 2¦3 + 2 * 1¦⏎`  
                                                   `1 * 2 + 3¦1 * 3 + 2¦2 * 1 + 3¦2 * 3 + 1¦3 * 1 + 2¦3 * 2 + 1⟫}`  

        - Fox(フォックス(`＃`))  
            [表現] `¥⟪¥＃∫LToken∫¥＃¥⟫`  
            [例]  `{⟪＃π＃⟫} => {❰3.1415926..❱}, {⟪＃GAFA＃⟫} => {⟪google¦amazon¦facebook¦apple⟫}, {⟪＃ウニの数え方＃⟫} => {⟪⟪1~⟫⟪壺¦個¦腹¦匹⟫⟫} => {Xorブロック}`  
            [説明] フォックス％❰ブロック❱(`＃`(U+FF03))は、引数の文字列から分かる集合を`Xor構成系`で表現し`Xorブロック`または`トークンブロック`で返す。~~(ｲﾝﾁｷ臭いブロック関数である)~~  

    - Xor集合演算系  
        - Xor集合比較演算系  
            - Inclusion(包含(`⊃`))  
                [表現] `∫LExpress∫¥⊃∫LExpress∫`  
                [例] `{⟪A¦B¦C⟫⊃⟪A¦B⟫} => {⟪A¦B⟫}, {⟪A¦B⟫⊃⟪A¦B¦C⟫} => {Ø}`  
                [説明] 包含(`⊃`(U+2283))は、`トークンのXorの連なり`において、`左項の⟪トークン¦Xor⟫ブロック`が`右項の⟪トークン¦Xor⟫ブロック`の`部分集合`になっているか検証し、  
                       なっていれば`右項`をそのまま返し、なっていなければ`Ø`を返します。  
                - [詳細]  
                    `⟪A¦B¦C⟫`は`⟪A¦B⟫`の`部分集合`なので`右項(⟪A¦B⟫)`が返ります。  
                    `{⟪A¦B¦C⟫⊃⟪A¦B⟫} => {⟪A¦B⟫}`  

            - Equal(イコール(`≡`))  
                [表現] `∫LExpress∫¥≡∫LExpress∫`  
                [例] `{⟪A¦B⟫≡⟪A¦B⟫} => {⟪A¦B⟫}, {⟪A¦B¦C⟫≡⟪A¦B⟫} => {Ø}`  
                [説明] イコール(`≡`(U+2261))は、`トークンのXorの連なり`において、`左項の⟪トークン¦Xor⟫ブロック`と`右項の⟪トークン¦Xor⟫ブロック`が`等しい集合`になっているか検証し、  
                       なっていれば`その集合のXorの連なり`をそのまま返し、なっていなければ`Ø`を返します。  

        - Union(和集合(`∪`))  
            [表現] `∫LExpress∫¥∪∫LExpress∫`  
            [例] `{⟪A¦B⟫∪⟪B¦C⟫} => {⟪A¦B¦C⟫}`  
            [説明] 和集合(`∪`(U+222A))は、`トークンのXorの連なり`において、`左項の⟪トークン¦Xor⟫ブロック`と`右項の⟪トークン¦Xor⟫ブロック`の`和集合`を取り、  
                   `その集合のXorの連なり`を返します。  
            - [詳細]  
                `⟪トークン¦Xor⟫ブロック`を`和集合で繋げた`ものと、`Xorで繋げたもの`は、`同値`になります。  
                `{{⟪A¦B⟫∪⟪B¦C⟫∪❰D❱} => {⟪A¦B¦C¦D⟫}} ⇔ {{⟪⟪A¦B⟫｡¦｡⟪B¦C⟫｡¦｡❰D❱⟫} => {⟪A¦B¦C¦D⟫}}`  

        - Meet(積集合(`∩`))  
            [表現] `∫LExpress∫¥∩∫LExpress∫`  
            [例] `{⟪A¦B⟫∩⟪B¦C⟫} => {❰B❱}`  
            [説明] 積集合(`∩`(U+2229))は、`トークンのXorの連なり`において、`左項の⟪トークン¦Xor⟫ブロック`と`右項の⟪トークン¦Xor⟫ブロック`の`積集合`を取り、  
                   `その集合のXorの連なり`を返します。  

        - Difference(差集合(`∸`))  
            [表現] `∫LExpress∫¥∸∫LExpress∫`  
            [例] `{⟪A¦B⟫∸⟪B¦C⟫} => {❰A❱}`  
            [説明] 差集合(`∸`(U+2238))は、`トークンのXorの連なり`において、`左項の⟪トークン¦Xor⟫ブロック`と`右項の⟪トークン¦Xor⟫ブロック`の`差集合`を取り、  
                   `その集合のXorの連なり`を返します。  

        - Exclusive(排他集合(`⚺`))  
            [表現] `∫LExpress∫¥⚺∫LExpress∫`  
            [例] `{⟪A¦B⟫⚺⟪B¦C⟫} => {⟪A¦C⟫}`  
            [説明] 排他集合(`⚺`(U+26BA))は、`トークンのXorの連なり`において、`左項の⟪トークン¦Xor⟫ブロック`と`右項の⟪トークン¦Xor⟫ブロック`の`排他集合`を取り、  
                   `その集合のXorの連なり`を返します。  

- Xor結合  
    [表現] `＄recursion＝❰¥❰｡｡｡⟦～⟧⟪｡｡∫LToken∫｡¦｡¥⟪｡⟦¥¦┃2～⟧⟪∫LToken∫¦∫recursion∫⟫｡¥⟫｡¦｡∫recursion∫｡｡⟫｡｡｡¥❱❱`  
    [例] `{❰⟪A¦B⟫C❱} => {⟪AC¦BC⟫}, {❰⟪A¦B⟫⟪C¦D⟫❱} => {⟪AC¦AD¦BC¦BD⟫}, {⟪A¦⟪B¦C⟫¦D⟫} => {⟪A¦B¦C¦D⟫}`  
    [説明]  `Xor結合`は`トークブロック内`にある`複数`の`Xorブロック`を`一つ`の`Xorブロック`にまとめます。  
    - [詳細]  
        まとめ方は`式の構造`によって`2種類`あります。  
        一つは`Xorブロック`が`トークンブロック上`に`横に並んでいる`パターンと、  
        もう一つは、`Xorブロック`が`ネスト`しているパターンです。  
        この`2種類のまとめ方`を`式木`の`一番底`から`再帰的に適用`し`一つのXorブロック`にまとめます。  

        - `トークンブロック上`に`横に並んでいる`パターン  
            `横に並んでいる`場合は、`Xorの選択`として`ありえる組み合わせ`の`全てのパターンを網羅`しそれを`一つのXor`で表します。  
            具体的には、`横に並んでいるXor`を一つのXorにつき一つずつ選ぶ`組み合わせ`になります。  
            `{❰⟪A¦B⟫⟪C¦D⟫❱} => {⟪AC¦AD¦BC¦BD⟫}` ｢この場合2 * 2 = 4通り  

        - `ネスト`しているパターン  
            `ネスト`している場合は、単に`内側`の`Xorブロックのブロック(⟪⟫)`を外します。  
            `{⟪A¦⟪B¦C⟫¦D⟫} => {⟪A¦B¦C¦D⟫}` ｢もしくは、`{⟪A¦D⟫∪⟪B¦C⟫} => {⟪A¦B¦C¦D⟫}`と考える事もできます。  

- line(ライン)  
    "_"はスペース、"\n"は改行コードとする。  
    [表現] `＄recursion＝❰¥❰❰⟦～⟧⟪｡｡∫LToken∫∸⟪_¦\n¦Ø⟫｡¦｡¥Ø｡¦｡⟦～⟧⟪_¦\n⟫｡¦｡∫recursion∫｡｡⟫❱¥❱❱`  
    [例]  `{❰_❰A❱_❰&Null❱_\n_B__❱} => {❰_A_\n_B__❱} => {_A_\n_B__}`  
    [説明] ラインは、`トークンブロック`(`❰❱`)と`ヌル`(`Ø`)を除去して一つの文にします。  
    - [詳細]  
        `トークンブロック`を`除去`します。  
        `{❰A❱} => {A}`  
        - `ヌル(Ø)`の`解決`  
            `ヌル`単体か、`ヌルの前後に隣接している改行かスペースの連なり`があり`先頭と末尾に改行かスペース以外の文字`がある場合以外の場合、  
                `ヌル`と`隣接している改行とスペースの連なり`を`除去`します。  
            `{Ø} => {}`, `{❰_\n_\nØ_\n❱} => {❰❱} => {}`, `{❰A_\n_\nØ_\n❱} => {❰A❱} => {A}`, `{❰_\n_\nØ_\nB❱} => {❰B❱} => {B}`  
            `ヌル`の`前後に隣接している改行かスペースの連なり`があり`先頭と末尾に改行かスペース以外の文字`がある場合、`ヌル`と`前方の隣接している改行とスペースの連なりのみ`を`除去`します。  
            `{❰A_\n_\nØ_\nB❱} => {❰A_\nB❱} => {A_\nB}`  

        - 複雑な例  
            `{❰_Ø_❰_A_Ø_B_❰_Ø_❱❰_C_❱_D_❱_Ø_E❱}`  
            =>  
            `{❰_Ø_❰_A_Ø_B_❰❱❰_C_❱_D_❱_Ø_E❱}`  
            =>  
            `{❰_Ø_❰_A_B__C__D_❱_Ø_E❱}`  
            =>  
            `{❰_A_B__C__D__E❱}`  
            =>  
            `{_A_B__C__D__E}`  
