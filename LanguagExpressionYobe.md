\# -> ⌗

# 言語表現(LanguageExpression)  

基礎([token](#token), [token block](#tokenb)) -> [xorステージ](#xors) -> [xor変換系](#xorc) -> [合成ステージ](#gousei) -> [tagステージ](#tag) -> [variableステージ](#var) -> [`xorとスキップと"∫∫"とlineステージによる構造と評価手順`](#tegyun)  
↑をさらっと読んだほうが分かりやすいかも  

- 基礎  
    - token(トークン) <a id="token"></a>  
        [表現] `\❰❰∫ˆLToken❱\❱`  
        [例] `{❰static❱}, {❰System.❱}, {❰1234❱}, {❰お腹すいた❱}, {❰ｇｔｈｙじゅきぉ；❱}, {❰ˆ_ˆ;❱}`  
        [説明] トークンブロック`(❰❱)`内にあるほぼ任意の文字、文字列。  
                ほぼ任意とは、ステージによる操作を含まないので`∫ˆLExpress`でなく`∫ˆLToken`です。  
        - [詳細]  
            //`"_"`はスペース  
            `{xxx_❰_token0__#tag❰token1{~}ˆ@❰_token2❱❰token3_¦token4_❱❱❰_token5__❱❱__xx_x}`  
            //このうちのトークンにあたる部分は、  
            `{{_token0__}, {token1}, {_token2}, {token3_}, {token4_}, {_token5__}}`  
            //です。つまり、`一番外側のトークンブロック内`の`言語表現のメタ文字(言語表現で説明された記号や文字)以外の文字`はスペースを含めてトークンです。  
            //`一番外側のトークンブロックの外`にある、`xxx_`と`__xx_x`はトークンではありません。  

            プログラム言語のキーワード、リテラルなどをtoken化(❰❱で囲む)すると便利。  
            論理学で言う原子論理式のような存在。  
    - tokenIndexステージ  
        [表現]`{❰∫❰LToken❱\≈❱}`  
        [例]{❰arg≈❱, ❰arg≈❱, ❰arg≈❱,..} ⇒ {❰arg0❱, ❰arg1❱, ❰arg2❱,..}  
        [説明] lineステージの前で❰token≈❱のようなトークンの最後に"≈"が付いた同じトークンブロックが複数あった場合、  
                一番最初に出現したトークンから番号を0から振っていく。  
        - [詳細]  
            ステージの評価順序  
            ` 非評価hide->"≈"変数定義->合成->"∫"ブロックステージ->"∫"代入->"∫"->tag->not->fox->xor変換系->xor->スキップ->"∫∫"代入->"∫∫"->tokenIndex->line->評価hide`   
            lineステージの前まで来るとトークンブロックの種類が`❰❰&Null❱¦❰∫❰LToken❱\≈❱¦❰∫❰LToken❱❱❱`しかないので番号を振れる。  

    - token block(トークンブロック) <a id="tokenb"></a>  
        [表現] `{\❰❰∫ˆLExpress❱\❱}`  
        [例] `{xxx_❰_token0__#tag❰token1{~}ˆ@❰_token2❱❰token3_¦token4_❱❱❰_token5__❱❱__xx_x}`  
        [説明] トークンブロックは`"❰❱"`(U+2770,U+2771)の事。上の`token(トークン)`の説明のようにトークンを区別し、トークンを`操作(ステージ)`するために使用する。  
        - [詳細]  
            `{{1~2}❰a❱} ⇒ {{❰a❱}または{❰a❱❰a❱}}`  
            //言語表現の殆どの操作(ステージ)はトークンブロックに対して作用する。  
            `{{1~2}❰❰a❱¦❰i❱❱} ⇒ {{❰a❱}または{❰i❱}または{❰a❱❰a❱}または{❰a❱❰i❱}または{❰i❱❰a❱}または{❰i❱❰i❱}}`  
            `{❰❰a❱¦❰{1~2}❰i❱❱❱} ⇒ {{❰a❱}または{❰i❱}または{❰i❱❰i❱}}`   
            //`"❰❱"`は数学の`"()"`と同じ意味で、演算子の`結合性を解決`する。  
            - 意味のないトークンブロックのネスト  
                `❰/:$n=❰2以上の∫∫ˆNnum❱`  
                `{{∫∫❰n❱~∫∫❰n❱}❰\❰❱∫❰LExpress❱{∫∫❰n❱~∫∫❰n❱}❰\❱❱} == {❰∫ˆLExpress❱}`  
                (例1):`{❰❰A❱❱} == {❰A❱}`
                (例2):`{❰❰❰❰❰A❱❱❱❱❱} == {❰A❱}`  
                //数学の`"()"`と同じで例1の様に内側と外側のトークンブロックの間に何もない場合は、  
                //その２つのトークンブロックは１つのトークンブロックと同じ意味になります。(式木的に意味ない)  

- hideステージ (評価hideステージ、非評価hideステージ)  
    [表現] (評価hideブロック)`{❰/:❰∫ˆLExpress❱\\n}, {❰/:❰∫ˆLExpress❱:/❱}`  //"\\n"は改行コード  
           (非評価hideブロック)`{❰/;❰∫ˆLToken❱\\n}, {❰/;❰∫ˆLToken❱;/❱}`  
    [例] `{❰/:❰∫ˆLExpress❱:/❱} ⇒ {}, {❰/:❰∫ˆLExpress❱\\n} ⇒ {}`  
    [説明] `❰/:`から`:/❱`または`❰/:`から`\\n`までを`評価hideブロック`と言い、`評価する`が対象言語から見えなくなる。  
            `❰/;`から`;/❱`または`❰/;`から`\\n`までを`非評価hideブロック`と言い、`評価せず`対象言語からも見えなくなる。  
            `❰/:`から`:/❱`, `❰/;`から`;/❱`は`トークンブロックの様に使えません`。  
    - [詳細]  
        X:`{❰token❰/;abcd;/❱❱}(トークンブロックの内部に出現しない)`, X:`{@❰/:abcd:/❱}(トークンブロックの様に使えない)`, O:`{❰/:@❰abcd❱:/❱}`  
        //評価,非評価hideブロックはトークンブロックのようには使えず、`トークンブロックを含む`ことはありますが、`トークンブロックの内部には出現せず`独立します。  
        `{❰/:$Number=#lit❰#自然数#❱\\n} ⇒ {} (⇒ {❰0¦1¦2¦..❱} にならない)`  
        //上記のように変数の定義はして欲しいが対象言語に`❰0¦1¦2¦..❱`が現れなくする。  
        `(説明){❰/;#tagNameのAは～..\\n} ⇒ {}`  
        //タグの説明を消せる。説明の中に`∫ˆLExpress`が現れても評価されない。  
        - 仕組み  
            ステージの評価順序は、  
            ` 非評価hide->"≈"変数定義->合成->"∫"ブロックステージ->"∫"代入->"∫"->tag->not->fox->xor変換系->xor->スキップ->"∫∫"代入->"∫∫"->tokenIndex->line->評価hide`  
            と言う順で評価されます。  
            - 非評価hideステージは、  
                一番最初に評価され真っ先に`{❰/;...\\n} ⇒ {}`と評価され、初めから何もなかったかのようになります。  
            - 評価hideステージは、  
                一番最後に評価され`{❰/:∫ˆLExpress\\n} ⇒ {}`の`∫ˆLExpress`はトークンブロックの評価として最後の`lineステージ`まで評価されます。  
                なので、トークンブロックの内部に出現しません。  

- 合成ステージ <a id="gousei"></a>  
    [表現] `{{~}❰∫ˆLOperator❰\ˆ❱❱❰∫ˆLToken¦\❰❰∫ˆLExpress❱\❱¦❰∫ˆLOperator\❰❰∫ˆLExpress❱\❱❱❱}`  
    [例] `{❰#tagˆ@ˆA❱} ⇒ {❰#tag❰@❰A❱❱❱}`  
    [説明] `"ˆ"`(U+02C6)を`合成子`と言い、右側が`トークン`の時`トークンブロック内のみ`使用可能。  
           `ˆ`の`左側`は常に`ステージ内演算子`で、`右側`は、`トークン`または`トークンブロック`または`ステージ内演算子`です。  
           `ˆ`が連続して使用されている場合は`右から評価`されます(`右結合`)。  
           関数合成、トークンブロックの省略記法のようなもの。  
    - [詳細]  
        `{❰@ˆA❱} ⇒ {❰@❰A❱❱}`  
        //ステージ内演算子とトークンの間に`ˆ`を入れることで、トークンをトークンブロックで囲んでステージ内演算子を適用します。  
        `{❰#tagˆ@❰A❱❱} ⇒ {❰#tag❰@❰A❱❱❱}`  
        //ステージ内演算子とステージ内演算子の間も同じ様にトークンブロックで囲まれる。  
        `{❰#tagˆ@ˆA❱} ⇒ {❰#tag❰@❰A❱❱❱}` 
        //繋げた例。  
        `{❰#ˆA¦&0ˆ$v=ˆB¦&[use]ˆC¦{2~2}ˆD❱} ⇒ {❰#❰A❱¦&0❰$v=❰B❱❱¦&[use]❰C❱¦{2~2}❰D❱❱} ⇒ {❰❰A❱¦❰B❱¦❰C❱¦❰❰D❱¦❰D❱❱❱}`  
        //xorの引数のトークンに`ˆ`を使う例。  
        `X:{@ˆA}, O:{❰@ˆA❱}`  
        //`ˆ`の右側が`トークン`の時`ˆ`は`トークンブロック内のみ`使用可能です。  
        `O:{@ˆ❰A❱}, O:{@ˆ#tagˆ❰A❱}`  
        //`ˆ`の右側が`トークンブロックまたはステージ内演算子である`時`ˆ`は`トークンブロック外でも`使用可能です。 
        `{❰@ˆ A   ❰B❱❱} ⇒ {❰@❰ A   ❱❰B❱❱}`, `{❰@ˆ❰A❱@❰B❱❱} ⇒ {❰@❰❰A❱❱@❰B❱❱}`, `{@ˆ#tag❰A❱@❰B❱} ⇒ {@❰#tag❰A❱❱@❰B❱}`  
        //`ˆ`によるトークンブロックで囲む範囲は、`ˆ`のすぐ右側の`トークン`または`トークンブロック`または`ステージ内演算子からトークンブロック`です。  

- variableステージ (`"∫"代入ステージ、"∫"ステージ、"∫∫"代入ステージ、"∫∫"ステージ`) <a id="var"></a>  
    [表現] (定義)`\$#id❰∫ˆLToken❱@❰≈❱\=\❰❰∫ˆLExpress❱\❱`,  
          (使用)`❰\∫¦\∫∫❱❰\❰#id❰∫ˆLToken❱\❱❱`  
    [例] (定義)`{$val=❰A❱} ⇒ {❰A❱}`, (使用)`{❰∫∫ˆval❱} ⇒ {❰∫∫❰val❱❱} ⇒ {❰❰A❱❱} == {❰A❱}`  
    [説明]  `$val=`を`代入演算子`と言い、変数`∫∫val`(`∫∫❰val❱`では無い)に`❰A❱`を代入する  
            `∫∫`を`同期変数演算子`,`∫`を`非同期変数演算子`と言い`∫∫❰val❱`と書くと、  
            トークン`val`と同じ代入演算子(`$val=`)のトークンを探しその代入された`∫∫val`を返す。  
            再代入不可。一度代入したら読み取り専用です。(const,readonly,finalのようなもの)  
            このステージの評価順序は、  
            ` 非評価hide->"≈"変数定義->合成->"∫"ブロックステージ->"∫"代入->"∫"->tag->not->fox->xor変換系->xor->スキップ->"∫∫"代入->"∫∫"->tokenIndex->line->評価hide`  
            と、言うふうに`合成ステージの後`と`tokenIndexの前`の2箇所で評価され`$val`が`∫val`と`∫∫val`に代入されます。  
            
    - [詳細]
        - (定義)`{$val=❰∫ˆLExpress❱} ⇒ {❰∫❰LExpress❱❱}`  
            //定義は`$val=❰∫ˆLExpress❱`で`"∫"代入`の場合は`非同期変数`の`∫val`に`❰∫❰LExpress❱❱(合成ステージの評価結果)`が代入される。  
                (`"∫∫"代入`の場合は`同期変数`の`∫∫val`に`❰∫ˆLExpress❱`の`tokenIndexの前`までの評価結果が代入される)   
            //評価すると`"∫"代入`で`$val=`の部分は無くなります。(`"∫∫"代入`の為に`言語表現の内部でトークンブロックがマーク`される)  
            (使用)`{∫∫❰val❱} ⇒ {❰∫ˆLExpress❱}` (実際は"∫"の時点で∫ˆLExpressが評価されれいる)  
            //`トークンブロック`に`∫∫`を付ける。  
            `∫∫❰val❱`は`∫∫val`が定義されているか探し、見つけたらそれを返します。見つからなかったら`❰&Null❱`になります。(`未定義のトークン`)  
            - "≈"変数定義//たぶんけす  
                (使用)`∫val∫ ∫val1∫ ∫val2∫..∫valn∫`  
                (定義)`{$val≈=❰∫ˆLExpress❱} ⇒ {$val=❰#1/1❰∫ˆLExpress❱❱$val1=❰#1/n❰∫ˆLExpress❱❱$val2=❰#1/n❰∫ˆLExpress❱❱..$valn=❰#1/n❰∫ˆLExpress❱❱}`  
                //`$val≈=`とやると使用した分だけ`$val`,`$val1`,`$val2`,..,`$valn`と定義されていく(合成ステージ前で)  
                //`#1/1`とは`❰∫ˆLExpress❱`内の全てのxorの選択を網羅する。  
                //`#1/n`とは`❰∫ˆLExpress❱`内の`1/n`のxorの選択を`val1`から`valn`まで被らない(衝突しない)ように分割してから選択を網羅する。  
                //その分割のされ方も網羅される。  
            - "∫"ブロックステージ   
                (使用)`{∫val∫} ⇒ {∫❰val❱}`, `{∫∫val∫} ⇒ {∫∫❰val❱}`  
                //トークンを`∫token∫`で囲むと`∫❰token❱`、トークンを`∫∫token∫`で囲むと`∫∫❰token❱`になる。  
                //合成ステージの後で変換される。それまで`∫val∫`は`トークンブロック扱い`。  
        (定義)`$a=ˆ$b=❰∫ˆLExpress❱ ⇒ $a=❰$b=❰∫ˆLExpress❱❱ ⇒ $a=❰❰∫ˆLExpress❱❱ == $a=❰∫ˆLExpress❱ ⇒ ❰∫ˆLExpress❱`  
        //`$a=ˆ$b=`と繋げることで合成ステージにより、`$a=❰$b=❰∫ˆLExpress❱❱`と評価される。  
        (使用)`{#1❰∫∫ˆundefinedVariable❱} ⇒ {❰&Null❱} ❰/:#1は定義されていない。`  
        //`未定義のトークン`を使用した場合`❰&Null❱`になります。  

        - いくつか組み込みで変数を定義している。(Lから始まる)  
            `$LToken=❰#ステージによる操作を含んでいない文字列(空集合は含まない)#❱ ❰/:原子論理式のようなもの`  
            `$LExpress=❰#ステージによる操作を含むかもしれない文字列(空集合は含まない)#❱ ❰/:論理式のようなもの`  
            `$LOperator=❰#全てのステージ内演算子#❱ ❰/:論理演算子のようなもの`  
            `$LIndex=#lit❰#自然数#❱`    
            `$LAny=❰#対象言語でその位置に出現可能な全てのトークン#❱`  
    - `"∫∫"`同期変数演算子と`"∫"`非同期変数演算子の違い  
        (`変数定義`と代入、xor`選択`)`{$val=❰A¦B❱} ⇒ {❰A¦B❱} ⇒ {❰A❱}`  
        //`{❰A¦B❱} ⇒ {{❰A❱}または{❰B❱}}`だがxorブロックにより`{❰A❱}`が選択されたとする。(xorブロックを参照)
        - `変数定義`と`選択`が上記の場合、`∫∫`と`∫`の違いは、  
            (使用)`{❰∫∫ˆval❱} ⇒ {❰❰A❱❱} == {❰A❱}`  
            //`❰∫∫ˆval❱`は代入元のxor選択の評価結果がそのまま入り代入元と同じ結果になる。  
            (使用)`{❰∫ˆval❱} ⇒ {❰❰A¦B❱❱} == {❰A¦B❱}`  
            //`❰∫ˆval❱`は代入元のxor選択の評価結果がそのまま入らず、代入元のトークンブロックそのものが入る。 
            - `"∫"`は`合成ステージの後`、`"∫∫"`は`tokenIndexの前`に評価される。  
                各ステージには評価される順序があり、  
               ` 非評価hide->"≈"変数定義->合成->"∫"ブロックステージ->"∫"代入->"∫"->tag->not->fox->xor変換系->xor->スキップ->"∫∫"代入->"∫∫"->tokenIndex->line->評価hide`  
                という順序で評価されて行きます。  
                - `∫`(非同期変数演算子)は`合成->"∫"代入->"∫"`というふうに、  
                    `"∫"`を評価する為の必要最低限のステージを評価し`"∫演算子"`を評価します。  
                    (合成)`{❰∫ˆval❱} ⇒ {❰∫❰val❱❱}` -> (`"∫"代入`)`{$val=❰A¦B❱}(∫val=❰A¦B❱)` -> (`"∫"`)`{❰∫❰val❱❱} ⇒ {❰❰A¦B❱❱} == {❰A¦B❱}`  
                    なので、`合成ステージのみ評価`し`"∫"へ代入`して`"∫"`で出現しているだけで、  
                    殆ど言語表現の構造に変化の無い状態で出現します。  
                    したがって、`"∫"`で出現したトークンブロックと`代入元`のトークンブロックが別々のxorブロックとして評価されるので、  
                    `∫`は`代入元`と`同時に`評価結果が`同じにならない`事があります。  
                - `∫∫`(同期変数演算子)は最後の、言語表現から文として出力する`tokenIndexの前`の段階で`"∫∫"代入`をし`"∫∫"`で出現します。  
                    `∫`とは逆で言語表現をlineステージと評価hide以外評価して構造を変化させた後に`"∫∫"代入`で代入`(∫∫val=❰A¦B❱)`され`"∫∫"`で出現します。  
                    したがって、xorブロックによる`選択の結果が代入`されるので、  
                    `∫∫`は`代入元`と`いつでも同じ`になります。  
                    - しかし、代入元が`{❰❰$val=❰A¦B❱❱¦C❱} ⇒ {❰C❱}`になってxorブロックの選択によって`$val=`が消えた場合や、  (❰A¦B❱が消えた場合？)  
                        `{not❰$val=❰A❱❱} ⇒ {❰&Null❱}`というふうに、何らかの原因によって`代入元の定義が消えた場合`は、(多分それら以外は無いと思う)  
                        `未定義のトークン`として`❰&Null❱`が入ります。(`{❰∫∫ˆval❱} ⇒ {❰&Null❱}`)  
        - `∫`(非同期変数演算子)の詳細  
            (定義) `{$val=❰❰&1&[c]ˆA¦&gˆB❱❰&0ˆC¦&gˆ∫∫ˆD❱❱}`  
            (使用) `{❰∫ˆval❱} ⇒ {❰❰❰&1&[c]❰A❱¦&g❰B❱❱❰&0❰C❱¦&g❰∫∫ˆD❱❱❱❱}`  
            //`∫`はあくまで`合成ステージの評価後`の`定義元の構造をコピー`するだけです。  
            //なので、`∫∫ˆD`は`tokenIndexの前までの評価結果`が入り、`&[c]`も外から真理値を受け取り、`&g`は外へ真理値を伝播可能で、  
            //`&1`と`&0`は定義元とは別の識別子となりこのトークンブロック内のみでリンクステージが働きます。  

- tagステージ <a id="tag"></a>  
    [表現] `\#@❰∫ˆLToken❱@❰❰1~❱¦\~❱❱\❰❰∫ˆLExpress❱\❱`    
    [例] `(使用){#tagName❰A❱} ⇒ {❰A❱}  (説明){#tagNameのAは～..}`  
    [説明] `#`の部分を`タグ演算子`と言い、トークンブロックにタグを付けてそのトークンブロックを外部で説明できる。  
    - [詳細]  
        (使用)`{#バグ→❰Func();❱}`  
        //外部に説明を書かないでタグだけでコメントのように使う使い方もある。  
        (使用)`{{#N1❰A❱}, {#N2❰B❱}, {#N3❰C❱}, {#N4❰D❱}}`  (説明){#N2~3は～..}  
        //タグの名前の末尾に番号を書いて、説明時に`2~3`というふうに複数のタグを同時に指せる。  
        (使用)`{{#N~❰A❱}, {#N~❰B❱}, {#N~❰C❱}, {#N~❰D❱}}`  (説明){#N~は～..}  
        //名前の同じタグが複数ある場合、タグの名前の末尾に`~`を書いて、説明時にそのタグ名が複数あることを知らせる。  
        (説明)`{❰/;#tagNameのAは～..\\n} ⇒ {} (\\nは改行コード)`  
        //hideステージと組み合わせることで説明の文を消せる。  

        - いくつか組み込みでtagを定義している。  
            `identifier: #id❰A❱ //Aはユーザー定義の識別子。`  
            `variable: #val❰A❱ //Aは変数`  
            `type: #type❰A❱ //Aは型`  
            `literal: #lit❰A❱ //Aはリテラル`  

- notステージ  
    [表現] `\not\❰❰∫ˆLExpress❱\❱`  
    [例] `{not❰A❱} ⇒ {❰&Null❱}`  
    [説明] `not`を`not演算子`と言い、`❰A❱`はその位置に出現しない  
    - [詳細]  
        `{not❰∫ˆLExpress❱} ⇒ {❰&Null❱}`  
        //実際の評価は`not`が付いたトークンブロックは全て`❰&Null❱`に変換されます。  

- foxステージ  
    [表現] `\❰\#❰∫ˆLToken❱\#\❱`   
    [例]  `{❰#π#❱} ⇒ {❰3.141592653589793238462643383279502884197169399375105820974944592307..❱}`  
    [説明] `❰#`から`#❱`を`foxブロック`と言い、  
            明確な意味がある、文字列で表現可能な言葉を`❰#`と`#❱`囲むと、それに対するxor変換系以下のステージによる操作を返す。
            ~~(ｲﾝﾁｷ臭いステージである)~~  
    - [詳細]  
        `{❰#GAFA#❱} ⇒ {❰google¦amazon¦facebook¦apple❱}`  
        `{❰#ウニの数え方#❱} ⇒ {❰❰1~❱❰壺¦個¦腹¦匹❱❱}`  
        //あいまいになるほど他人との共通の認識を持つことは難しい。  
        //自分のみ理解していればいいのであれば何でもいいと思う。  

- xor変換系 <a id="xorc"></a>  

    - optionステージ  
        [表現] `\@\❰❰∫ˆLExpress❱\❱`  
        [例] `{@❰A❱} ⇒ {❰❰A❱¦❰&Null❱❱}`  
        [説明] `@`を`option演算子`と言い、`❰A❱`はその位置に出現可能である事を意味します。  
        - [詳細]  
            `{@❰A❱} ⇒ {❰❰A❱¦❰&Null❱❱}`  `{@❰A¦B❱} ⇒ {❰❰A¦B❱¦❰&Null❱❱}`  
            //実際の評価は引数を囲う様に`❰❰∫ˆLExpress❱¦❰&Null❱❱`を加えます。  

    - defaultステージ  
        [表現] `\%\❰❰∫ˆLExpress❱\❱`  
        [例] `{%❰A❱} ⇒ {❰❰A❱¦❰&Null❱❱}`  
        [説明] `%`を`default演算子`と言い、optionと挙動は同じだが、対象言語の仕組みで  
        `❰A❱`を明記しなくても対象言語の内部で`❰A❱`が有効になる事を示す。  
        [具体例] `私は%❰交互に足を踏み出す事で❱歩いた。`  
        [C#の例] `class cls{%❰private❱ int n;}`  
        - [詳細]  
            `{%❰A❱} ⇒ {❰❰A❱¦❰&Null❱❱}`  
            //明記しなかった場合`❰&Null❱`になるが言語の内部では`❰A❱`が記述されている事とを示す。  
            `{❰%ˆA¦B¦C❱} ⇒ {❰❰❰A❱¦❰&Null❱❱¦B¦C❱}`  
            //xorの連なりに`%`を付ける。  
            上記の２つの用途以外で使用すると対象言語の内部で矛盾が起きるので注意。  

    - indexステージ  
        [表現] `\❰@❰∫ˆn0❱\~@❰∫ˆn1❱\❱ $n0=ˆ$n1=❰∫∫ˆLIndex❱`   
        [例] `❰1~3❱ ⇒ ❰1¦2¦3❱`  
        [説明] "[表現]"の様な形を`indexブロック`と言い、0~∞のまでの添字を生成する。  
        - [詳細]  
            `❰~2❱ ⇒ ❰0~2❱ ⇒ ❰0¦1¦2❱`  
            //開始の数字を省略すると`0~`になります。  
            `❰2~❱ ⇒ ❰2~∞❱ ⇒ ❰2¦3¦4¦..❱`  
            //終了の数字を省略すると`~∞`になります。  
            `❰~❱ ⇒ ❰0~∞❱ ⇒ ❰0¦1¦2¦..❱`  
            //両方の数字を省略すると`0~∞`になります。  

    - 量化ステージ  
        [表現] `\{&0@❰\❰❰∫ˆDelimiter❱\❱❱&0@❰,❱@❰∫ˆn0❱\~@❰∫ˆn1❱\}\❰❰∫ˆLExpress❱\❱`    
                `❰/:$Delimiter=#lit❰#区切り文字⊂∫LToken#❱, $n0=ˆ$n1=❰∫∫ˆLIndex❱`  
        [例] `{{❰,❱,1~3}❰A❱} ⇒ {❰❰❰A❱❱¦❰❰A❱❰,❱❰A❱❱¦❰❰A❱❰,❱❰A❱❰,❱❰A❱❱❱}`  
        [説明] `{❰,❱,1~3}`の部分を`量化演算子`と言い、`❰A❱`を区切り文字`❰,❱`を挟んで`1~3`回繰り返す。  
                そして、各xorの間と評価結果の始まりから終わりまでをトークンブロックで囲う。  
        - [詳細]  
        `{{❰,❱,1~3}❰A❱} ⇒ {❰❰❰A❱❱¦❰❰A❱❰,❱❰A❱❱¦❰❰A❱❰,❱❰A❱❰,❱❰A❱❱❱}`  
        //❰,❱は区切り文字となり、1~3は1回,2回,3回の繰り返しのパターン全てをxorで繋げる。  
        `{{❰❰_¦,❱❰/❱❱,2~2}❰A❱} ⇒ {❰❰A❱❰❰_¦,❱❰/❱❱❰A❱❱}`  
        //区切り文字はトークンブロックなのでそのままトークンブロックが区切り文字として挿入される  
        `{{2~4}❰A❱} ⇒ {❰❰❰A❱❰A❱❱¦❰❰A❱❰A❱❰A❱❱¦❰❰A❱❰A❱❰A❱❰A❱❱❱}`  
        //区切り文字を省略して無くすことができる。  
        `{{~4}❰A❱} ⇒ {❰❰❰&Null❱❱¦❰❰A❱❱¦❰❰A❱❰A❱❱¦❰❰A❱❰A❱❰A❱❱¦❰❰A❱❰A❱❰A❱❰A❱❱❱}`  
        //~4として開始回数を省略すると0~4の意味となり0回から繰り返しが開始される  
        `{{2~}❰A❱} ⇒ {❰❰❰A❱❰A❱❱¦❰❰A❱❰A❱❰A❱❱¦..❱}`  
        //2~として終了回数を省略すると2~∞の意味となり繰り返しが無限に続く  
        `{{~}❰A❱} ⇒ {❰❰❰&Null❱❱¦❰❰A❱❱¦❰❰A❱❰A❱❱¦..❱}`  
        //~とすると0~∞の意味となり0回から繰り返しが無限に続く  
        `{{❰,❱,~}❰A❱} ⇒ {❰❰❰&Null❱❱¦❰❰A❱❱¦❰❰A❱❰,❱❰A❱❱¦..❰,❱❰A❱❱❱}`  
        //繰り返しが無限の時に区切り文字が指定されても無限に続く最後は❰A❱で終わる  
    
    - sequenceステージ  
        [表現] `\❰\¦#1:{1~}❰∫ˆLExpress¦\[∫ˆLExpress\]¦\[∫ˆLToken\¦∫ˆLExpress\]❱\¦\❱`  
                `❰/;#1"[∫ˆLExpress]"または"[∫ˆLToken¦∫ˆLExpress]"が１つ以上出現すること`  
        [例] `❰¦[1] + [2] * [3]¦❱ ⇒ ❰1 + 2 * 3¦1 + 3 * 2¦2 + 1 * 3¦2 + 3 * 1¦3 + 1 * 2¦3 + 2 * 1❱`  
        [説明] `❰¦`から`¦❱`をsequenceブロックと言い、複数の`[∫ˆLExpress]`の並び替えた全ての結果をxorする。(`[例]`の場合は3!=6個の並び替え)  
        - [詳細]  
            `❰¦[1] [op¦+] [2] [op¦*] [3]¦❱ ⇒ #1❰1 + 2 * 3¦1 + 3 * 2¦2 + 1 * 3¦2 + 3 * 1¦3 + 1 * 2¦3 + 2 * 1¦`  
                                               `1 * 2 + 3¦1 * 3 + 2¦2 * 1 + 3¦2 * 3 + 1¦3 * 1 + 2¦3 * 2 + 1❱`
                                               `❰/;実際は改行しない`  
            //`[∫ˆLToken¦∫ˆLExpress]`とする事で、同じ`∫ˆLToken`同士で並び替えする事ができる(この場合は3!*2!=12個の並び替え)  

- xorステージ <a id="xors"></a>  
    [表現] `\❰{❰\¦❱,2~}❰&tb@❰\❰❱❰∫ˆLExpress❱&[tb]=@❰\❱❱❱\❱`  
    [例] `{❰A¦❰B❱❱} ⇒ {{❰A❱}または{❰❰B❱❱}} == {{❰A❱}または{❰B❱}}`    
    [説明] "[表現]"の様な形を`xorブロック`、`"¦"`(U+00A6)を`xor`と言い、`❰A❱`か`❰B❱`どちらかが出現(選択)する  
    - [詳細]  
        `{❰❰A❱¦❰B❱❱} ⇒ {{❰A❱}または{❰B❱}}`  
        //どちらか出現するという意味だが、実際は出現しうるパターンを全て出力する。  
        //詳細は`xorとスキップと"∫∫"とlineステージによる構造と評価手順`を参照。  
        `{❰❰A❱¦❰B❱¦❰C❱¦..❱} ⇒ {{❰A❱}または{❰B❱}または{❰C❱},..}`  
        //xorは任意数、繋げることができる。  
        `X:{❰A❱¦❰B❱¦❰C❱❰D❱} O:{❰❰A❱¦❰B❱¦❰C❱❱❰D❱}`
        //xorは必ず作用しているトークンをトークンブロックで覆う。  
        `❰❰A❱¦B¦❰C❱¦D❱ ⇒ {{❰❰A❱❱}または{❰B❱}または{❰❰C❱❱}または{❰D❱}}　== {{❰A❱}または{❰B❱}または{❰C❱}または{❰D❱}}`  
        //`xorブロック内`ではトークンをトークンブロックで囲まなくていい。  
    - impステージ 
        [表現] `\❰#1❰∫ˆLExpress❱\❱⇒\❰#2❰∫ˆLExpress❱\❱ ❰/;ただし#2は#1のLExpress内の選択で出現しうるもの`  
        [例] `{❰A¦B¦C❱⇒❰A¦B❱} ⇒ {❰A¦B❱}`  
        [説明] `"⇒"(ならば)`の左側のトークンブロックが`xorの選択で出現しうる部分的なパターン`をxorで表現して、  
               右側にトークンブロックとして`抜き出し網羅される範囲を狭める`。  
        - [詳細]
            `{❰A¦B¦C❱⇒❰A¦B❱⇒❰A❱} ⇒ {❰A¦B❱⇒❰A❱} ⇒ {❰A❱}`  
            //`"⇒"`は左結合です。  
            `{❰A¦❰B¦C❱❱⇒❰B¦C❱⇒❰C❱} == {❰A¦❰B¦C❱❱⇒❰C❱}}`  
            //xorの入れ子に対しても抜き出せます。あと`"⇒"`は論理学の"⇒"と同じ推移律が成り立つようです。  
            `{❰❰A¦B❱⇒❰A❱ ❰C¦D❱❱} ⇒ {❰❰A❱ ❰C¦D❱❱}`  
            //もちろんトークンブロック内でも使えます。  
            `X:{❰❰A¦B❱⇒❰A❱ ❰C¦D❱❱⇒❰❰B❱ ❰C❱❱} ⇒ {❰❰A❱ ❰C¦D❱❱⇒❰❰B❱ ❰C❱❱}`  
            //`"⇒"`はトークンブロックの入れ子の中から評価され、抜き出せない状態になる事もあります。  
            `{$body=❰#身長❰小人¦大人❱, #胸❰絶壁¦小玉メロン❱, #体型❰干物¦❰普通¦熱盛❱❱❱}`  
            `{∫body∫⇒❰❰小人¦大人❱, ❰小玉メロン❱, ❰普通❱❱}`  
            //変数の内部を制約できます。  
            `{❰#あにまる#❱⇒❰#ほにゅうるい#❱⇒❰#れいちょうるい#❱⇒❰#にんげん#❱⇒❰#にほんじん#❱⇒❰#わい#❱}`  
            //xor変換系を通過しているのでfoxはxorで構成されています。  
            `{{~}❰あんぱん❱⇒❰❰あんぱん❱❰あんぱん❱❰あんぱん❱❰あんぱん❱❰あんぱん❱❰あんぱん❱❰あんぱん❱❰あんぱん❱❰あんぱん❱❰あんぱん❱❰あんぱん❱❰あんぱん❱❱}`  
            //あんぱん、抜き出せます。  
            `{❰¦[う][こ][ん]¦❱⇒❰うんこ❱}`  
            //はぁ…(呆れ)  
            `O:{∫Type∫⇒❰int❱} ⇒ {❰byte¦int¦char❱⇒❰int❱} ❰/:$Type=❰bool¦int¦char❱`  
            //非同期変数演算子は`xorステージの前で評価`されるので使えます。  
            `X:{∫∫Type∫⇒❰int❱}`  
            //同期変数演算子は`xorステージの後で評価`されるのでxorで構成されたトークンブロックを`表現できず評価できません`。  
            `{❰&aˆA¦B❱⇒❰&aˆA❱} {{❰&[a]C¦D❱} ⇒ {❰&[a]C❱}}の選択のみを通す`  
            //セレクトフラグ変数が付いているトークンを抜き出した場合、それが選択されたものとします。(&a=True)  
            //逆にそれを抜き出さなかった(`{❰&aˆA¦B❱⇒❰B❱}`)の場合、それが選択されなかったのもとします。(&a=False)  
- スキップステージ  
    [表現] (セレクトフラグ変数演算子)`\&&0@❰#idˆ∫ˆLToken❱&1@❰-❱&0@❰#idˆ∫ˆLIndex❱\❰❰∫ˆLExpress❱\❱`  
            (パス条件演算子)`\&\[❰∫ˆcondition❱\]\❰❰∫ˆLExpress❱\❱ ❰/:$condition=❰#セレクトフラグ変数との論理演算#❱ (パス条件参照)`  
            (セレクトフラグ変数とパス条件演算子)`{~}❰\&&0@❰#idˆ∫ˆLToken❱&1@❰-❱&0@❰#idˆ∫ˆLIndex❱❱@❰\&\[❰∫ˆcondition❱\]❱\❰❰∫ˆLExpress❱\❱`  
            (フラグ設定条件ブロック)`\❰\&\[❰∫ˆcondition❱\]{~}❰_¦\\n❱\=>{~}❰_¦\\n❱{❰,❱,1~}❰∫ˆLToken❱\❱ ❰/;"_"はスペース"\\n"は改行コードとする`  
            //フラグ設定条件で定義されるセレクトフラグ変数は再代入不可  
    [例] `{❰&aˆA¦B❱ ❰&bˆC¦D❱ ❰&[a&b]ˆE¦F❱}`は、  
        `{{{❰&aˆA¦B❱} ⇒ {❰&aˆA❱}}, {{❰&bˆC¦D❱} ⇒ {❰&bˆC❱}}}`の時、
        `{{❰&[a&b]ˆE¦F❱} ⇒ {❰&[a&b]ˆE❱}}`の選択のみを通す(パスする)  
        そしてその時、最終的に`{❰A❱ ❰C❱ ❰E❱}`  
        //スキップステージはxorブロックの結果を絞り込むかのように働きます。  
    [説明] スキップステージの評価手順。  
    1. `❰&aˆA¦B❱`のように`セレクトフラグ変数(&a)`を`xorブロックの引数に付け(&aˆA¦)`て`xorステージ後`で選択中かそうでないか記憶する。  
           詳しくは、`xorとスキップと"∫∫"とlineステージによる構造と評価手順`参照。  
    1.5. (フラグ設定条件)
    1. `❰&[a&b]ˆE¦F❱`のように`パス条件(&[a&b])`はセレクトフラグ変数を引数として取り(a,b)、  
        そのパス条件も`xorブロックの引数に付けて(&[a&b]ˆE¦)`、条件が真になる時、その引数の選択のみパスし、  
        それ以外はスキップする。条件が偽の時は全てパスする。  

    パス条件は条件が満たす時その引数が必ず選択されてほしい時に付ける。  
    - [詳細]  
        `xorとスキップと"∫∫"とlineステージによる構造と評価手順`の評価手順の`1.`のxorブロックで選択を確定させ、`2.`のスキップステージに移り、  
        望ましくない選択の(違法な)パターンを`パス条件`で検知して、`1.`のxorブロックに戻ることによってそのパターンを`スキップ`します。  
        望ましい選択の(合法な)パターンの場合は`3.`のvariableステージにそのパターンを渡します。  
        例えば`{❰&aˆA¦B❱ ❰&bˆC¦D❱ ❰&[a&b]ˆE¦F❱}`は、`A`と`C`が選択されたとき`F`が選択されるのは望ましくないので、  
        `{❰A❱,❰C❱,❰F❱}`の組み合わせのパターンはスキップされてvariableステージに渡されず`1.`のxorブロックに戻され`スキップ`されます。  
        `A`と`C`が選択されたとき`E`が選択されるのは望ましいのでvariableステージにそのパターンが渡され`パス`されます。  
        パスされるかスキップされるかは、`❰&[a&b]ˆE¦F❱`の場合は`[a&b]`の条件が真の時、`[a&b]`が付いているxorブロックの引数`E`が、  
        選択されているなら`パス`されていないなら`スキップ`になります。  
        `[a&b]`が偽の場合、その時に望まれていないパターンは無いので`E`と`F`どちらが選択されててもパスします。  
        つまり、パス条件が真なら、その引数を選択している時のみパスする。パス条件が偽なら、全ての引数の選択をパスする。  

        - パスかスキップか  
            `{❰A¦B¦C¦D❱}`  
            //この場合はパス条件がありません。つまり、ある選択の条件下で望まれるパターンがないので全ての選択のパターンをパスします。  
            `{❰&[False]ˆA¦&[False]ˆB¦&[False]ˆC¦&[False]ˆD❱}`  
            //`{❰A¦B¦C¦D❱}`の例はパス条件が真である引数が無い。つまり、ある選択の条件下で望まれるパターンがないので、  
            //全ての引数のパス条件が偽(False)であるのと同じになります。つまり、この全てのパス条件がFalseである例は全てパスします。  
            `{❰&[False]ˆA¦&[True]ˆB¦&[False]ˆC¦&[False]ˆD❱}`  
            //この例にはパス条件が真(True)である引数が１つあります。つまり、`B`以外の選択は望まれていません。  
            //なのでその引数(B)が選択されている時のみパスされ、それ以外の引数(A,C,D)が選択されている場合はスキップされます。  
            `{❰&[True]ˆA¦&[True]ˆB¦&[False]ˆC¦&[False]ˆD❱}`  
            //この例にはパス条件が真(True)である引数が２つあります。つまり、`A`または`B`以外の選択は望まれていません。  
            //なのでその２つの引数(A,B)のどちらかが選択されている時のみパスされ、それ以外の引数(C,D)が選択されている場合はスキップされます。  

            よってTrueがあるならそれのみパスして、全てがFalseなら全ての選択をパスします。  

        - パス条件  
            `{❰&[!(a&(b/(c¦(d&(True/(False¦use))))))]ˆA¦B❱} (論理演算子を全て使った例)`  
            セレクトフラグ変数をパス条件のフラグとして論理演算して真でその引数が選択されている時のみパスする。  
            セレクトフラグ変数の`&a`はパス条件の`[]`の中では`a`となります。  
            論理演算は`"["`と`"]"`の間に記述し論理演算子と優先順位は、  
            `{!==not, /==or, &==and, ¦==xor}.`の順で、  
            真理値は、`{True==真, False==偽, use==真}`で、  
            結合性の解決に`()`が使えます。  
            `use`は`True`のエイリアスと言うことにします。  
            `{❰&lˆA❱} ⇒ {❰A❱}`　`{❰&[a&b]ˆE❱} ⇒ {❰E❱}`  
            //全てのセレクトフラグ変数またはパス条件が付いた形式は最終的に無くなります。  
        
        - セレクトフラグ変数が複数定義されている場合はor演算されます。  
            `{❰&aˆA¦B❱ ❰&aˆC¦D❱ ❰&[a]ˆE¦F❱}`は、  
            `{{❰&aˆA¦B❱} ⇒ {❰&aˆA❱}}`の時、
            `{{{❰&aˆC¦D❱} ⇒ {{&aˆC}または{D}}}, {{❰&[a]ˆE¦F❱} ⇒ {❰&[a]ˆE❱}}}`の選択のみをパスする。  
            そしてその時、最終的に`{❰A❱ {❰C❱または❰D❱} ❰E❱}`  
            //`{{❰&aˆA¦B❱} ⇒ {❰&aˆA❱}}`なので、`&a==True`ですが、  
            //`❰&aˆC¦D❱`の`&a`は`Trueの場合`と`Falseの場合`があります。  
            //この場合、`上記の２つをor演算してTrue`にします。

        - リンクステージ  
            リンクステージはスキップステージの応用に`非常に近い`操作です。  
            リンクステージを有効にするにはセレクトフラグ変数を`&❰∫ˆLIndex❱`か`&❰∫ˆLToken❱-❰∫ˆLIndex❱`の形式にします。  

            `{❰❰&2ˆA¦B❱❰&1ˆC¦D❱❰&0ˆE¦F❱❱}`は、  
            `{{❰&2ˆA¦B❱} ⇒ {❰&2ˆA❱}}`の時、`{{❰&1ˆC¦D❱} ⇒ {❰&1ˆC❱}}, {{❰&0ˆE¦F❱} ⇒ {❰&0ˆE❱}}`の選択のみをパスする。  
            `{{❰&1ˆC¦D❱} ⇒ {❰&1ˆC❱}}`の時、`{{❰&0ˆE¦F❱} ⇒ {❰&0ˆE❱}}`の選択のみをパスする。  
            `{{❰&0ˆE¦F❱} ⇒ {❰&0ˆE❱}}`の時は何も起こらず、任意の選択をパスする。  
            //つまり、`数字が大きい`セレクトフラグ変数の引数が選択された時、  
            //`それより数字が同じか小さい`セレクトフラグ変数の引数の選択のみをパスする。  
            //リンクステージはスキップステージで言う、  
            `{❰❰&"2"&["2"/"3"/"4"/..]ˆA¦B❱❰&"1"&["1"/"2"/"3"/..]ˆC¦D❱❰&"0"&["0"/"1"/"2"/..]ˆE¦F❱❱}`であるかのように動作します。  

            `{❰&a-2ˆA¦B❱  ❰&a-1ˆC¦D❱  ❰&a-0ˆE¦F❱}`  
            //`&❰∫ˆLToken❱-❰∫ˆLIndex❱`の場合は`独立したトークンブロック間にも作用`し`同じ❰∫ˆLToken❱間`で上記と同じ動作をします。  

        - セレクトフラグ変数とパス条件の付け方と影響範囲  
            1. `X{❰{~}ˆ&aˆA¦B❱}, O{❰&aˆ{~}ˆA¦B❱} ({~}ˆ&aのようなセレクトフラグ変数の後ろに任意のステージを繋げることはできない)`  
               //`{❰{~}ˆ&aˆA¦B❱} ⇒ {❰{~}❰&a❰A❱❱¦B❱}`となり`&a❰A❱`が`{~}`の引数となってしまって直接`xorブロックの引数にならない`。  
            2. `{{❰&aˆA¦B❱},{❰C¦&aˆD❱}}(&aはAとD間に影響を与える)`  
               //`&`に`❰∫ˆtoken❱`が付く場合、variableステージの様に`独立したトークンブロック間にも影響を与えます。`  
            3. `{{❰&a-1ˆA¦B❱},{❰C¦&a-0ˆD❱}}`  
               //`&`に`❰∫ˆtoken❱`と`❰∫ˆLIndex❱`が付く場合、間に`-`を付けて区切ります。  
               //(トークンブロック間に影響を与えつつ、`同じ❰∫ˆLToken❱間`でリンクステージが働く)  
            4. `{{❰&0ˆA¦B❱},{❰C¦&0ˆD❱}}  (&0ˆAの&0と、&0ˆDの&0は、別の識別のセレクトフラグ変数)`  
               //`&`に`❰∫ˆLIndex❱`のみが付く場合、`独立したトークンブロック間に影響を与えず別々のセレクトフラグ変数`になります。
            5. `{❰&a&bˆA¦B❱} (&aと&bの間に"ˆ"を入れると1.の様にxorブロックの引数にならない)`  
               //１つのトークンに複数のセレクトフラグ変数を付けたい場合は`ˆ`を入れずに繋げます。  
            6. `X{❰&[a¦b]&[c&d]ˆA¦B❱}, O{❰&[a¦b]ˆA¦B❱}`  
               //パス条件は１つのトークンブロックに１つまでです。  
            7. `{❰&a&b&[a¦b]ˆA¦B❱}`  
               //セレクトフラグ変数とパス条件を繋げた例です。必ずセレクトフラグ変数、パス条件の並びです。  
            8. `{{&a@❰A❱} ⇒ {❰&a❰A❱¦❰&Null❱❱}}, {{&a&b&[a¦b]@ˆA} ⇒ {❰&a&b&[a¦b]❰A❱¦❰&Null❱❱}}`  
               //option演算子の左側に記述するとoptionステージを評価したときoptionのトークンに付きます。  
               1. `{{&a%❰A❱} ⇒ {❰&a❰A❱¦❰&Null❱❱}}, {{&a&b&[a¦b]%ˆA} ⇒ {❰&a&b&[a¦b]❰A❱¦❰&Null❱❱}}`  
               //default演算子も同じです。  
            9. `{{&a!@❰A❱} ⇒ {❰❰A❱¦&a❰&Null❱❱}}, {{&a&b&[a¦b]!@ˆA} ⇒ {❰❰A❱¦&a&b&[a¦b]❰&Null❱❱}}`  
               //`"!"`をoption演算子の左側に記述するとoptionステージを評価したときoptionのヌルトークンに付きます。  
               1. `{{&a!%❰A❱} ⇒ {❰❰A❱¦&a❰&Null❱❱}}, {{&a&b&[a¦b]!%ˆA} ⇒ {❰❰A❱¦&a&b&[a¦b]❰&Null❱❱}}`  
               //`"!"`をdefault演算子も同じです。  
            10. `{{&[a]=@❰A❱} ⇒ {❰&[a]❰A❱¦&[!a]❰&Null❱❱}}`  
               //`"="`をoption演算子の左側に`条件のみ`記述すると条件が真の時トークン、偽の時ヌルトークン、の選択のみパスします。  
               1. `{{&[a]=%❰A❱} ⇒ {❰&[a]❰A❱¦&[!a]❰&Null❱❱}}`  
               //`"="`をdefault演算子も同じです。  
               
        - フラグ設定条件  
            `{❰❰&aˆA¦B❱❰&bˆC¦D❱❰&[c]ˆ❰&[d]ˆE¦F❱¦G❱❱ ❰&[a&b] => c,d❱}`は、  
            `{{{❰&aˆA¦B❱} ⇒ {❰&aˆA❱}}, {{❰&bˆC¦D❱} ⇒ {❰&bˆC❱}}}`の時、  
            `{❰&[c]ˆ❰&[d]ˆE¦F❱¦G❱} ⇒ {❰&[c]ˆ❰&[d]ˆE❱¦G❱} ⇒ {❰&[c]ˆ❰E❱❱} ⇒ {❰E❱}`の選択のみをパスする。  
            そしてその時、最終的に`{❰A❱ ❰C❱ ❰E❱}`  
            //トークンブロックの外部に`❰&[a&b] => c,d❱`とすることで、`=>`の左側が真になった時、右側も真にします。  
            //`=>`の左に現れる変数(c,d)は必ず`新しく定義されるセレクトフラグ変数`であり、  
            //xorブロックの引数または別のフラグ設定条件の`セレクトフラグ変数を上書きしません`。  
            `{❰&[a&b] => c,d❱} ⇒ {}`  
            //フラグ設定条件は評価すると空になります。  

        - スキップステージ(とリンクステージ)よる操作は同時に一度しか実行しません。  
            `{❰❰&0ˆA¦B❱❰&a&[0]ˆC¦D❱❰&[a]ˆE¦F❱❱}`は、  
            `{{{❰&0ˆA¦B❱} ⇒ {❰&0ˆA❱}}`の時、  
            `{{{❰&a&[0]ˆC¦D❱} ⇒ {❰C❱}}, {{❰&[a]ˆE¦F❱} ⇒ {{❰&[a]ˆE❱}または{❰F❱}}}}`の選択のみパスする。  
            そしてその時、最終的に`{❰A❱❰C❱{❰E❱または❰F❱}}`  
            //`[説明]`で説明したようにスキップステージによる操作(スキップまたはパスする)の工程は２つ(本当は３つ)あります。  
            1. セレクトフラグ変数はxorブロックの選択を記憶します。(`&0`は`&0ˆA`が選択されたので真(&0=True))  
            1.5. (フラグ設定条件)
            1. そのセレクトフラグ変数をもとにパス条件で現在の選択をパスまたはスキップをする。
                (`&0==True`なので`&[0]`を満たし`C`の選択のみをパスする)  
            スキップステージはそれ以外の工程にパスまたはスキップと言う形で処理を受け渡すので、(一度しか実行しない)  
            `&a&[0]ˆC`がパスされても`&a==True`にならず`{❰&[a]ˆE¦F❱} ⇒ {❰&[a]ˆE❱のみ}`になりません。(連鎖しない)  

- lineステージ  
    //"_"はスペース、"\\n"は改行コード  
    [表現] `$recursion=❰\❰❰{~}❰∫ˆtokenXorNull¦{~}❰_¦\\n❱¦∫ˆrecursion❱❱\❱❱ ❰/;"_"はスペース"\\n"は改行コードとする`  
            `$tokenXorNull=❰\❰❰∫ˆLToken¦\&Null❱\❱❱`  
    [例]  `{❰_❰ab❱_❰&Null❱_\\n_cd__❱} ⇒ {❰_ab_\\n_cd__❱} ⇒ {_ab_\\n_cd__}`  
    [説明] トークンブロックのネストの内側からトークンブロックを除去していき、  
            ヌルトークンを解決して除去し、一番外側のトークンブロックまで除去して、  
            １つの文を完成させます。  
    - [詳細]  
        `{❰A❱} ⇒ {A}`  
        //トークンブロックを除去します。  
        `{❰❰A❱❰B❱❱} ⇒ {❰AB❱} ⇒ {AB}`  
        //トークンブロックのネストは内側から除去されます。 
        - ❰&Null❱の解決  
            `{❰&Null❱} ⇒ {}`  
            //ヌルトークンはヌルトークンごと除去します。  
            `{❰_\\n_\\n_❰&Null❱_\\n_\\n_❱} ⇒ {❰❱} ⇒ {}`  
            //内側のヌルトークンは隣り合うトークンが空白や改行の連続の場合それも含めて除去します。  
            `{❰_\\n_\\n_❰&Null❱_\\n_abc_def❱} ⇒ {❰abc_def❱} ⇒ {abc_def}`  
            `{❰_\\n_\\n_❰&Null❱_\\n_❰abc❱_❰def❱❱} ⇒ {❰abc_def❱} ⇒ {abc_def}`  
            `{❰abc_def_\\n_\\n_❰&Null❱_\\n_❱} ⇒ {❰abc_def❱} ⇒ {abc_def}`  
            `{❰❰abc❱_❰def❱_\\n_\\n_❰&Null❱_\\n_❱} ⇒ {❰abc_def❱} ⇒ {abc_def}`  
            //ヌルトークンと隣り合う空白や改行が、それ以外(abc_def)より、`先頭か末尾`の場合、
            //ヌルトークンと隣り合う空白や改行のみ除去します。  
            `{❰abc_\\n_\\n_❰&Null❱_\\n_def❱} ⇒ {❰abc_\\n_def❱} ⇒ {abc_\\n_def}`  
            `{❰❰abc❱_\\n_\\n_❰&Null❱_\\n_❰def❱❱} ⇒ {❰abc_\\n_def❱} ⇒ {abc_\\n_def}`  
            //ヌルトークンと隣り合う空白や改行が、それ以外との、`中間`の場合(abcとdefの中間)、  
            //ヌルトークンと隣り合う空白や改行のうち、ヌルトークンと`前の`空白や改行を除去します。  
        - 複雑な例  
            `{❰_❰&Null❱_❰_ab_❰&Null❱_cd_❰_❰&Null❱_❱❰_ef_❱_gh_❱_❰&Null❱_ij❱}`  
            ⇒  
            `{❰_❰&Null❱_❰_ab_❰&Null❱_cd_❰❱❰_ef_❱_gh_❱_❰&Null❱_ij❱}`  
            ⇒  
            `{❰_❰&Null❱_❰_ab_cd__ef__gh_❱_❰&Null❱_ij❱}`  
            ⇒  
            `{❰_ab_cd__ef__gh__ij❱}`  
            ⇒  
            `{_ab_cd__ef__gh__ij}`  

- `xorとスキップと"∫∫"とlineステージによる構造と評価手順` <a id="tegyun"></a>  
    `$recursion=❰\❰{~}❰❰\❰{❰\¦❱,2~}❰∫∫ˆsVWN¦∫ˆrecursion❱\❱❱¦∫∫ˆsVWN¦∫ˆrecursion❱\❱❱`  
    `$sVWN=❰❰&s@ˆ∫ˆskip❱&[s]=@❰\❰❱❰&v@❰\∫❱❱&[v]=@❰\❰❱❰∫ˆtokenXorNull❱&[v]=@❰\❱❱&[s]=@❰\❱❱❱`  
    `$tokenXorNull=❰\❰❰∫ˆLToken¦\&Null❱\❱❱`  
    `$skip=❰{~}❰\&&0@❰#idˆ∫ˆLToken❱&1@❰-❱&0@❰#idˆ∫ˆLIndex❱❱@❰\&\[❰∫ˆcondition❱\]❱❱ ❰/:$condition=❰#セレクトフラグ変数との論理演算#❱`  
        (❰❱の数は必要以上に多くなるが基本的な構造はあってると思う。。)  
    xorステージの直前までステージが進むと上記のような構造になります。つまり、  
    `❰❰A❱❰B❱❰C❱..❱`というlineの構造と`❰A¦B¦C¦..❱`というxorの構造が、入れ子になった構造になります。  
    例えば`{❰❰∫ˆa¦∫ˆb❱❰∫ˆc¦❰❰∫ˆd❱❰∫ˆe❱❱❱❱} $a=ˆ$b=ˆ$c=ˆ$d=ˆ$e=❰∫ˆLExpress❱`という構造は、  
    `❰❰∫ˆd❱❰∫ˆe❱❱`がline、プログラミングでいう多次元配列やクラスなどのデータ構造、数学でいう直積。  
    `❰∫ˆa¦∫ˆb❱`がxor、プログラミングでいう変数(bool==❰True¦False❱, int==❰..¦-2¦-1¦0¦1¦2¦..❱)、数学でいう直和。  
    それが入れ子になっています。  
    構造をが分かったところで、xorブロックとスキップと`"∫∫"`とtokenIndexとlineステージによる評価の手順は、(`xor->スキップ->"∫∫"代入->"∫∫"->tokenIndex->line`)  
    1. 全てのxorブロックの全ての選択のパターンを網羅するように更新して確定させて、  
        １つの形にします。`("{} ⇒ {{}または{}..}"ではなく"{} ⇒ {}"の形にする)`  
    2. スキップステージで望まてれいない`1.`の`xorブロックの選択`の(違法な)パターンは`1.`に戻り、そのパターンをスキップします。  
        望まれた`1.`の`xorブロックの選択`の(合法な)パターンは`3.`に進み、そのパターンをパスします。  
    3. variableステージの`"∫"代入`で`言語表現の内部でトークンブロックがマーク`され、そのトークンブロックを同期変数(例:{`$val=`の`∫∫val`})へ代入し、  
        同期変数演算子(例:{`∫∫❰val❱`})の引数(val)と同じ名前の変数(∫∫val)を見つけ、その代入されたものを出現させます。  
    4. tokenIndexステージで❰token≈❱のようなトークンの最後に"≈"が付いた同じトークンブロックが複数あった場合、一番最初に出現したトークンから番号を0から振っていく。  
    5. lineステージはトークンブロックとヌルトークンを解決し１つの文にします。  
    6. `1.`から`5.`を繰り返して全ての文を完成させます。  
    というふうに`全てのxorを網羅(xor(ブロック))`しその`パターンを選別(スキップ)`し、  
    `同期変数演算子を評価("∫∫"代入->"∫∫")`をし`❰token≈❱の"≈"に番号を振り(tokenIndex)`全ての`文を完成(line)`させます。  
