# シェーダーバリアント

ここでは`Keyword`⇔`ShaderKeyword`

## シェーダーバリアントの物理的意味

- シェーダーは*DirectX12*では、**#define配列**と**ShaderStage**を指定し**コンパイル**して**Shader**を作成します。
  **描画時**には、その**Shader**を`PSO`の**各ShaderStage**に設定しその`PSO`を`R_GraphicsCommandList`に設定します。
  そして、**DrawCall**でその**各Shader**が起動されます。
  - *DirectX12*
    - **コンパイル**`(..,`out **Shader**`)`
      - **#define配列**: `#define ｢Name｣`
      - **ShaderStage**: `⟪vs¦ps¦gs¦hs¦ds¦cs⟫_⟪4_0¦4_1¦5_0¦5_1¦6_0⟫`
    - `R_GraphicsCommandList`
      - `PSO`
        - **各ShaderStage**: `⟪VS¦PS¦DS¦HS¦GS⟫`: **コンパイル**した**Shader**を設定

- 以下の`Shaderコード`を**fragmentShader**で**コンパイル**するとき以下の**構成**になります。
  - **コンパイル**`(..,`out **fragmentShader**`)`
    - **#define配列**: **なし**
    - **ShaderStage**: **ps** (p⇔fragment)
    - `EntryPoint`: `"fragmentShader"`
  - このとき、`#if defined(_Vertex_Keyword)`は必ず**false**になります。
    なぜなら、**fragmentShader(ps)**のコンパイル時に **#define配列**に`_Vertex_Keyword`が渡ってなく**定義されていない**からです。
  - そして、`#if defined(VERTEX_DEFINE)`は、必ず**true**になります。なぜなら、**fragmentShader**のコンパイルでも**全て**の`Shaderコード`を取り込むからです。
  - **各ShaderStage**の**Shader**の**コンパイル範囲**は、
    その**Shader**の、**入出力セマンティクス**(一応共有可能)と **#pragmaで指定される関数**と
    その**関数**から参照される**各ShaderStage**で**共有可能**な❰**Shaderリソース(uniform)**や**struct**や**関数群**❱です。(コンパイルは**各ShaderStage**独立)
`Shaderコード`
``` c
#pragma vertex vert
#pragma fragment fragmentShader

#pragma multi_compile_vertex _ _Vertex_Keyword

Varyings vert(Attributes input)
{
    ..
    #define VERTEX_DEFINE
    ..
}

float4 fragmentShader(Varyings input) : SV_TARGET
{
    ..
    #if defined(_Vertex_Keyword) //false
        ..
    #endif
    ..
    #if defined(VERTEX_DEFINE) //true
        ..
    #endif
    ..
}
```

## バリアントルール

- 最終的な**バリアント数**は、`multi_compile` x (`設定独立な.mat数` + `shader_featureのデフォルトパターン`) となる。

### shader_feature

- **shader_feature**は、`cmd.SetKeyword(material,keyword,bool)`などで設定される、
  `.mat`に**保存**された`material.enableKeywords`によって**Shader**の**コンパイル時**に**単一のバリアント**が生成されます。
    (`enableKeywords`の中に`shader_feature`を決定する`Keyword`が含まれる)
  そして、**異なるkeyword設定を持つ**`.mat`の数(`設定独立な.mat数`)だけ**バリアント**が生成されます。
  あと、`shader_featureのデフォルトパターン`の**バリアント**が**常に生成**されます。
  - `shader_featureのデフォルトパターン`とは、以下の場合`Key0`,`Key3`,`_`,`_`となり、**一番最初**の`Keyword`が**選択**された**1バリアント**である。
```c
shader_feature Key0 Key1 Key2
shader_feature Key3 Key4
shader_feature _  Key5
shader_feature Key6  //Keywordが1つのみの場合、 shader_feature Key ⇔ shader_feature _ Key となる`_`の省略パターンがある。
```

### multi_compile

- **multi_compile**は、単純にその`keyword`の**組み合わせ分**の**バリアント**を生成します。
  以下の場合**バリアント数**は、`3(Key0 Key1 Key2)`x`2(Key3 Key4)`x`2(_  Key5)`x`1(Key6)`=`12`**バリアント**となる。
```c
multi_compile Key0 Key1 Key2
multi_compile Key3 Key4
multi_compile _  Key5
multi_compile Key6 //shader_featureのように`_`の省略パターンは存在しない。つまり、常に`Key6`を選択するバリアントが生成される。
```

### ＠❰`_local`❱＠⟪`_vertex`¦`_fragment`⟫ サフィックス

- [Frame Debugger](images\Frame_Debugger.png)

- `_local`**サフィックス**: `LocalKeyword[] material.enableKeywords`**のみ**から**設定可能**。
    (`GlobalKeyword[] Shader.enableGlobalKeyword`からは**設定不能**にする) (`_local`が付いた`Keyword`は、`LocalKeyword.isOverridable`を`false`にする)

- ⟪`_vertex`¦`_fragment`⟫ **サフィックス**: `keyword`をその**ShaderStage**のみに**限定**して**コンパイル**する。
  つまり、`multi_compile_fragment Key`としたならば、
  - **コンパイル**`(..,`out **Shader**`)`
    - **#define配列**: `#define Key`
    - **ShaderStage**: **ps** (p⇔`_fragment`)
  となり、**ps**のみ**限定**して**コンパイル**される。(`_fragment`が無ければ、`ps`と`vs`(`_vertex`)の両方にコンパイルされる(`gs`があればそれも))

- ⟪`shader_feature`¦`multi_compile`⟫＠❰`_local`❱＠⟪`_vertex`¦`_fragment`⟫  (`shader_feature_local`も可能だが*バリアントの選択*により意味は無いと思われる)

## ⟪Local¦Global⟫Keywordによる バリアントの選択 と ～Keywords と 生成/設定 と マッチ失敗

- **バリアントの選択**
  - `shader_feature`の**選択**: `material.enableKeywords` (`GlobalKeyword`からは**選択不可**)
  - `multi_compile`の**選択**: `material.enableKeywords`∪(`Shader.enableGlobalKeywords`∩`Shader.KeywordSpace.keywords`)

- **⟪Local¦Global⟫Keyword[]**の**状態**
  - **リセット/更新**のタイミング
    - *LocalKeyword[]*
      - `material.enableKeywords`: `.mat`があれば**永続的(リセット無し)**だが、`.mat`が無ければ**C#ドメインリロード**で**空にリセット**となる
      - `Shader.KeywordSpace.keywords`: **C#ドメインリロード**で**更新**される
    - *GlobalKeyword[]*
      - `Shader.enableGlobalKeywords`: **Editor再起動**で**リセット**される
      - `Shader.globalKeywords`: **Editor再起動**で**リセット**される
  - **Unityがデフォルト**で**設定(追加)**する,設定されうる、`Keyword`群
    - *LocalKeyword[]*
      - `material.enableKeywords`: **STEREO_INSTANCING_ON** (こいつが**稀**に**勝手に追加**され**マッチ失敗**されるので、`cmd.SetKeyword(..)`で`enableKeywords`から**削除**する)
      - `Shader.KeywordSpace.keywords`: `STEREO_INSTANCING_ON`, `UNITY_SINGLE_PASS_STEREO`, `STEREO_MULTIVIEW_ON`, `STEREO_CUBEMAP_RENDER_ON`
    - *GlobalKeyword[]*
      - `Shader.enableGlobalKeywords`: `UNITY_DEVICE_SUPPORTS_WAVE_ANY`, `UNITY_DEVICE_SUPPORTS_WAVE_32`
      - `Shader.globalKeywords`
        :`SPOT`, `DIRECTIONAL`, `DIRECTIONAL_COOKIE`, `POINT`, `POINT_COOKIE`, `SHADOWS_DEPTH`, `SHADOWS_SCREEN`, `SHADOWS_CUBE`, `SHADOWS_SOFT`, `SHADOWS_SPLIT_SPHERES`, `SHADOWS_SINGLE_CASCADE`, `LIGHTMAP_ON`, `DIRLIGHTMAP_COMBINED`, `DYNAMICLIGHTMAP_ON`, `LIGHTMAP_SHADOW_MIXING`, `SHADOWS_SHADOWMASK`, `LIGHTPROBE_SH`, `FOG_LINEAR`, `FOG_EXP`, `FOG_EXP2`, `_EMISSION`, `VERTEXLIGHT_ON`, `SOFTPARTICLES_ON`, `UNITY_HDR_ON`, `LOD_FADE_CROSSFADE`, `INSTANCING_ON`, `PROCEDURAL_INSTANCING_ON`, `DOTS_INSTANCING_ON`, `UNITY_SINGLE_PASS_STEREO`, `ETC1_EXTERNAL_ALPHA`, `STEREO_INSTANCING_ON`, `STEREO_MULTIVIEW_ON`, `STEREO_CUBEMAP_RENDER_ON`, `EDITOR_VISUALIZATION`, `GEOM_TYPE_LEAF`, `GEOM_TYPE_FROND`, `GEOM_TYPE_BRANCH_DETAIL`, `GEOM_TYPE_BRANCH`, `GEOM_TYPE_MESH`, `EFFECT_BUMP`, `EFFECT_HUE_VARIATION`, `EFFECT_BILLBOARD`, `EFFECT_EXTRA_TEX`, `EFFECT_SUBSURFACE`, `_WINDQUALITY_NONE`, `_WINDQUALITY_FASTEST`, `_WINDQUALITY_FAST`, `_WINDQUALITY_BETTER`, `_WINDQUALITY_BEST`, `_WINDQUALITY_PALM`, `BILLBOARD_FACE_CAMERA_POS`, `UNITY_DEVICE_SUPPORTS_WAVE_ANY`, `UNITY_DEVICE_SUPPORTS_WAVE_8`, `UNITY_DEVICE_SUPPORTS_WAVE_16`, `UNITY_DEVICE_SUPPORTS_WAVE_32`, `UNITY_DEVICE_SUPPORTS_WAVE_64`, `UNITY_DEVICE_SUPPORTS_WAVE_128`, `UNITY_DEVICE_SUPPORTS_NATIVE_16BIT`, `UNITY_DEVICE_SUPPORTS_INLINE_RAY_TRACING`, `_MAIN_LIGHT_SHADOWS`, `_MAIN_LIGHT_SHADOWS_CASCADE`, `_MAIN_LIGHT_SHADOWS_SCREEN`, `_ADDITIONAL_LIGHTS_VERTEX`, `_ADDITIONAL_LIGHTS`, `_ADDITIONAL_LIGHT_SHADOWS`, `_REFLECTION_PROBE_BLENDING`, `_REFLECTION_PROBE_BOX_PROJECTION`, `_REFLECTION_PROBE_ATLAS`, `_CASTING_PUNCTUAL_LIGHT_SHADOW`, `_SHADOWS_SOFT`, `_MIXED_LIGHTING_SUBTRACTIVE`, `_ALPHATEST_ON`, `_GBUFFER_NORMALS_OCT`, `_SCREEN_SPACE_OCCLUSION`
```CSharp
ctx.Submit();
if (renderLoopCounter == 0) //ctx.Submit()でmaterial.enabledKeywords に設定される
{
    Debug.Log($"staticRenderLoopCounter: {staticRenderLoopCounter} ============================================================");
    staticRenderLoopCounter++;
    // 有効なキーワード (LocalKeyword[]) //C#リロードで更新 または Materialに保存されている
    var enabledKeywords = shaderKeywordTestMaterial.enabledKeywords;
    string enabledStr = string.Join(", ", enabledKeywords.Select(k => k.name));
    Debug.Log($"material.enabledKeywords: {enabledStr}");

    // シェーダーに定義されている全てのキーワード (LocalKeyword[]) //C#リロードで更新
    var shaderKeywords = shaderKeywordTestMaterial.shader.keywordSpace.keywords;
    string allKeywordsStr = string.Join(", ", shaderKeywords.Select(k => k.name));
    Debug.Log($"shader.keywordSpace: {allKeywordsStr}");

    // Shader.enableGlobalKeywords (GlobalKeyword[]) //これのリセットはEditor再起動 (C#リロード貫通) //明示的に設定すれば反映される
    var enabledGlobalKeywords = Shader.enabledGlobalKeywords;
    string enabledGlobalKeywordsStr = string.Join(", ", enabledGlobalKeywords.Select(k => k.name));
    Debug.Log($"Shader.enableGlobalKeywords: {enabledGlobalKeywordsStr}");

    // Shader.globalKeywords (GlobalKeyword[]) //これのリセットはEditor再起動 (C#リロード貫通)
    var globalKeywords = Shader.globalKeywords;
    string globalKeywordsStr = string.Join(", ", globalKeywords.Select(k => k.name));
    Debug.Log($"Shader.globalKeywords: {globalKeywordsStr}");
}
renderLoopCounter++;
```

### LocalKeyword

- `LocalKeyword`の**生成**は、`new LocalKeyword(shader, ｢"keyword"｣)`で`shader`に**存在**する`｢"keyword"｣`を**指定**して作る。
    (`shader`に存在する`｢"keyword"｣`とは、`multi_compile Key0 Key1 Key2`なら`Key0`,`Key1`,`Key2`のことである。(**存在しない**`｢"keyword"｣`を指定すると**エラー**))
- `LocalKeyword`の**設定**は、`cmd.SetKeyword(material, localKeyword, bool)`を実行して`material.enableKeywords`に`localKeyword`を **⟪追加¦削除⟫**して設定する。
  - 必ず、`material.enableKeywords`⊆`Shader.KeywordSpace.keywords`になる。

### GlobalKeyword

- `GlobalKeyword`の**生成**は、`GlobalKeyword.Create(｢"keyword"｣)`で作る。(**任意**の`｢"keyword"｣`を指定することが可能)
- `GlobalKeyword`の**設定**は、`cmd.SetKeyword(globalKeyword, bool)`を実行して`Shader.enableGlobalKeywords`に`globalKeyword`を **⟪追加¦削除⟫**して設定する。

### マッチ失敗

**マッチ失敗**とは、**存在しないバリアント**への**バリアントの選択**である。

- **マッチ失敗**は、基本的に**未定義動作**となる。

- **Strict shader variant matching**は、**Standalone Player Mode時のみ**効果があり、
  **Strict shader variant matching**の**有効時**、**マッチ失敗**は**マゼンタ**となる。

## ⟪Editor¦Play⟫ Mode と Standalone Player Mode の コンパイルタイミングの違い

- **⟪Editor¦Play⟫ Mode**では、**バリアント**を**常に動的**に**生成**するため、
  - `.mat`に`shader_feature`の`Keyword`が**保存していない**場合でも**必要時**に**動的に生成**され選択し使用される。
  - `multi_compile`も同様に**動的に生成**されるため、`2^100`ある**バリアント数**でも**即時にコンパイルせず**、**必要時**に**生成**される。

- **Standalone Player Mode**では、**Player Build時**に**使用する全てのバリアント**を**コンパイルして生成**するため、
  - `.mat`に`shader_feature`の`Keyword`が**保存していない**場合は、`shader_featureのデフォルトパターン`**以外**は**マッチ失敗**となり、
  - `multi_compile`は、**Player Build時**に`2^100`ある**バリアント数**の**コンパイルが走り**終わらなくなる。
  - [シェーダーは爆発する](images\Shaderバリアント爆発.png)

## ShaderVariantCollection(SVC)

- [SVCのイメージ](images/SVC.png)
- **SVC**は、単に**シェーダーバリアント**の**コレクション**である。つまり、`.mat`の集合のようなもの。(`Resourcesフォルダ`に置く)
- **ストリッピング**されないと聞いたが、全然普通に**ストリッピング**される。
  (元々ある同じ**Shader**と同一であり、`Full variant space`から加算され、`OnProcessShader(..)`でストリッピングされる(**全てのstripping段階**でストリップされそう))
  なので`multi_compile`の**バリアント**を作っても、いつも通り**ストリッピング**されるなら**意味がない**気がする。(`shader_feature`のバリアントしか意味がない)
- あと、`.WarmUp()`(Preloaded Shaders)もできるが、**DirectX12では効かない**。*DirectX12*などの最新グラフィックスAPIでは**PSOごとキャッシュ**をする必要がある。
  - `graphicsStateCollection`,`.⟪Begin¦Enc⟫Trace()`,`.SendToEditor(｢outputFileName｣)`,`JobHandle .WarmUp()`

- `Project Settings/Graphics`にある**Save to asset…**で、**⟪Editor¦Play⟫ Mode**で**現在使用されているバリアント**をSVCに含めることができる。(**Clear**で**記録をリセット**)
  (`Currently tracked: 19 shaders 25 total variants`: `ShaderVariantCollection`の*Inspector*でリストされた内容の数と一致した)
  - 全ての`material`の**バリアントの選択**を**追跡**していると思われるが、たまにうまく反映されない気がする。(気のせいかも)

### Always Included Shaders

>Unity がすべてのビルドですべての可能な バリアント を有するシェーダのリストです。(`Resourcesフォルダ`と何が明確に**違うか**は不明)
ユーザーが作成した`.shader`を設定すると、なぜか`.shader`2個分の**Compiling shader**が**実行**される。(Unity組み込みの`Shader`では1個分のみ)

## デバッグログ (Player Build時)

**Shaderが更新**されている**通知**するために`NewUnlitShader`を作っていた

### Editor.log/Compiling shader

`C:\Users\～\AppData\Local\Unity\Editor\Editor.log`の中にある**Compiling shader**項目 (VSCodeで見ると固まるのでWindows標準のやつで見る)

- `Fire/Build And Run` => **Editor.log/Compiling shader** で確認。
  **Compiling shader** `"｢ShaderName｣"` pass `"｢ShaderPassName｣"` (`｢ShaderStage`)
  *Full variant space*: バリアントルール/**バリアント数**
  *After settings filtering*: Project Settings (主に**Graphicsページ**) によるストリッピング
  *After built-in stripping*: **シーン** (.unityファイル, Lightingウインドウ(Fogなど), Rendererコンポーネント, など)
  *After scriptable stripping*: IPreProcessShaders (**.OnProcessShader(..)**) (SRP, RenderPipelineAsset)

- **ユーザーが作ったシェーダー**でも**Unityが定義しているShaderKeyword**(`LIGHTMAP_ON`,`FOG_LINEAR`,など)
  なら、**Unityの自動バリアントストリッピング**は効く。(*settings filtering*, *built-in stripping*, *scriptable stripping*)
  - **自作シェーダー**で`#pragma multi_compile_fog`の`FOG_EXP2`が**スプリット**されることを確認した
      (`Project Settings/Graphics/Fog Modes`と`Lighting/Environment/Fog`を試したが、
        どちらも`After scriptable stripping`**のみ**に効果がでた(`Fog Modes`は`settings filtering`のはずだが))

``` c
Compiling shader "Universal Render Pipeline/Lit" pass "ForwardLit" (vp)
    Full variant space:         884736
    After settings filtering:   6144
    After built-in stripping:   12
    After scriptable stripping: 4
    Processed in 0.00 seconds
    starting compilation...
    finished in 0.00 seconds. Local cache hits 4 (0.00s CPU time), remote cache hits 0 (0.00s CPU time), compiled 0 variants (0.00s CPU time), skipped 0 variants
    Prepared data for serialisation in 0.00s
Compiling shader "Universal Render Pipeline/Lit" pass "ForwardLit" (fp)
    Full variant space:         9059696640
    After settings filtering:   49152
    After built-in stripping:   96
    After scriptable stripping: 16
    Processed in 0.00 seconds
    starting compilation...
    finished in 0.00 seconds. Local cache hits 16 (0.01s CPU time), remote cache hits 0 (0.00s CPU time), compiled 0 variants (0.00s CPU time), skipped 0 variants
    Prepared data for serialisation in 0.00s
```
`Shader "Universal Render Pipeline/Lit" (6000.1.0b5)`
``` c
//Vertex Shader  : 4^2 * 3^3 * 2^11 = 884,736 variants (一致)
//Fragment Shader: 5^1 * 4^1 * 2^9 * 884736 = 9,059,696,640 variants (一致)
//shader_featureは、`shader_featureのデフォルトパターン`(全てkeyword無し版(`_`))を使っていたためバリアントは無かったと思われる
// -------------------------------------
// Universal Pipeline keywords
#pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN
#pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS
#pragma multi_compile _ EVALUATE_SH_MIXED EVALUATE_SH_VERTEX
#pragma multi_compile_fragment _ _ADDITIONAL_LIGHT_SHADOWS
#pragma multi_compile_fragment _ _REFLECTION_PROBE_BLENDING
#pragma multi_compile_fragment _ _REFLECTION_PROBE_BOX_PROJECTION
#pragma multi_compile_fragment _ _REFLECTION_PROBE_ATLAS
#pragma multi_compile_fragment _ _SHADOWS_SOFT _SHADOWS_SOFT_LOW _SHADOWS_SOFT_MEDIUM _SHADOWS_SOFT_HIGH
#pragma multi_compile_fragment _ _SCREEN_SPACE_OCCLUSION
#pragma multi_compile_fragment _ _DBUFFER_MRT1 _DBUFFER_MRT2 _DBUFFER_MRT3
#pragma multi_compile_fragment _ _LIGHT_COOKIES
#pragma multi_compile _ _LIGHT_LAYERS
#pragma multi_compile _ _CLUSTER_LIGHT_LOOP
//#include_with_pragmas "RenderingLayers.hlsl"
    #pragma multi_compile_fragment _ _WRITE_RENDERING_LAYERS
// -------------------------------------
// Unity defined keywords
#pragma multi_compile _ LIGHTMAP_SHADOW_MIXING
#pragma multi_compile _ SHADOWS_SHADOWMASK
#pragma multi_compile _ DIRLIGHTMAP_COMBINED
#pragma multi_compile _ LIGHTMAP_ON
#pragma multi_compile_fragment _ LIGHTMAP_BICUBIC_SAMPLING
#pragma multi_compile _ DYNAMICLIGHTMAP_ON
#pragma multi_compile _ USE_LEGACY_LIGHTMAPS
#pragma multi_compile _ LOD_FADE_CROSSFADE
#pragma multi_compile_fragment _ DEBUG_DISPLAY
//#include_with_pragmas "Fog.hlsl"
    #pragma multi_compile_fog //#pragma multi_compile _ FOG_LINEAR FOG_EXP FOG_EXP2
//#include_with_pragmas "ProbeVolumeVariants.hlsl"
    #pragma multi_compile _ PROBE_VOLUMES_L1 PROBE_VOLUMES_L2
//--------------------------------------
// GPU Instancing
#pragma multi_compile_instancing //#pragma multi_compile _ INSTANCING_ON
//#include_with_pragmas "DOTS.hlsl"
    #pragma multi_compile _ DOTS_INSTANCING_ON
```

### IPreprocessShaders.OnProcessShader(..)

- `Fire/Build And Run` => **Consoleログ(Debug.Log(..))** で確認。

- `OnProcessShader(Shader shader, ShaderSnippetData snippet, IList<ShaderCompilerData> data)`
  - 全ての**Shader**毎にこのメソッドが呼ばれ、その`shader`全ての**バリアント**(`IList<ShaderCompilerData> data`)を**列挙(IList)**する事ができる。
    そして、そのバリアントの**ShaderKeyword**を`ShaderKeyword[] ShaderCompilerData.shaderKeywordSet.GetShaderKeywords()`で取得できる。
    そして、`IList.RemoveAt(i)`によって、`IList`から**削除**することによって**バリアント**を**ストリップ**することができる。

- この**ストリッピングのためのメソッド**を**利用**して、ある**Shader**の**バリアント**と**ShaderKeyword**を`Debug.Log(..)`に**列挙**する処理を書き、
  **バリアントの選択**を利用して**バリアント毎**に**マッチ**を**検証**しマッチしたら`<== ★MATCH`を付ける処理を書いた。
```CSharp
using System.Collections.Generic;
using UnityEngine;

using UnityEditor;
using UnityEditor.ShaderKeywordFilter;
using UnityEditor.Build;
using UnityEditor.Build.Reporting;
using UnityEditor.Rendering;
using System.Linq;

// ShaderKeywordTestShaderの"_SWITCH_0"キーワードをストリップするプリプロセッサ
public class ShaderKeywordTestShaderKeywordStripper : IPreprocessShaders
{
    // [RemoveIf(true, keywordNames: "_SWITCH_0")]
    // bool switch_0 = false; // "_SWITCH_0"キーワードをストリップするためにfalseにする 
    public int callbackOrder => 0;

    public void OnProcessShader(Shader shader, ShaderSnippetData snippet, IList<ShaderCompilerData> data)
    {
        if (shader.name == "Custom/ShaderKeywordTestShader" || shader.name == "Custom/ShaderKeywordTestShader_Asset")
        {
            // 現在有効なキーワードセット（material.enabledKeywords）を取得
            // ※ここではエディタ上のMaterialから取得する例
            var materials = Resources.FindObjectsOfTypeAll<Material>().Where(m => m.shader == shader);
            //最強のFindだけど、isPersistent以外のUnityObjectはAllWeakDestroyで消えてる?

            for (int i = data.Count - 1; i >= 0; --i)
            {
                var variantKeywords = new HashSet<string>(data[i].shaderKeywordSet.GetShaderKeywords().Select(k => k.name));

                // 各マテリアルのenabledKeywords + 現在有効なグローバルキーワードを合成して判定
                var shaderGlobalKeywordNames = new HashSet<string>(
                    shader.keywordSpace.keywords
                        .Select(k => k.name)
                );

                var enabledGlobalKeywordNames = new HashSet<string>(
                    Shader.enabledGlobalKeywords.Select(k => k.name)
                );

                // シェーダーで有効なグローバルキーワードのみ抽出
                var enabledShaderGlobalKeywords = shaderGlobalKeywordNames.Intersect(enabledGlobalKeywordNames).ToHashSet();

                var matchedMaterials = materials
                    .Where(m =>
                    {
                        var matKeywords = new HashSet<string>(m.enabledKeywords.Select(k => k.name));
                        matKeywords.UnionWith(enabledShaderGlobalKeywords);
                        return matKeywords.SetEquals(variantKeywords);
                    })
                    .Select(m => m.name)
                    .ToList();
                //Material**アセット**が無い場合はマッチチェックが出来ない
                //あと、GlobalKeyword**のみ**からshader_featureのKeywordを有効にする時のマッチ失敗はチェックできない
                string mark = matchedMaterials.Count > 0 ? $" <== ★MATCH [{string.Join(", ", matchedMaterials)}]" : "";

                Debug.Log($"OnProcessShader: {shader.name} [Stage:{snippet.shaderType}] {string.Join(",", variantKeywords)}{mark}");

                foreach (var keyword in data[i].shaderKeywordSet.GetShaderKeywords())
                {
                    // if (keyword.name == "_STRIP")
                    // {
                    //     Debug.Log($"{keyword.name}を{shader.name}から削除");
                    //     data.RemoveAt(i);
                    //     break;
                    // }
                }
            }
        }
    }
}
```

### Shader Variant Log Level (多分URPのみ)

- [Shader Variant Log Level](images/ShaderVariantLogLevel.png)

`Project Settings/Graphics/URP/Shader Variant Log Level: All Shaders`

- `Fire/Build And Run` => **Consoleログ(Debug.Log(..))** で確認。
  - *After built-in stripping*から*After scriptable stripping*の差を見ている

``` c
Universal Render Pipeline/Lit - Total=38/133(28.57%)
- ForwardLit (ScriptableRenderPipeline) (SubShader: 0) (ShaderType: Vertex) - Total=4/12(33.33%) - Time=0.0956ms
- ForwardLit (ScriptableRenderPipeline) (SubShader: 0) (ShaderType: Fragment) - Total=16/96(16.67%) - Time=0.4209ms
- ShadowCaster (ShadowCaster) (SubShader: 0) (ShaderType: Vertex) - Total=4/4(100.00%) - Time=0.064ms
- ShadowCaster (ShadowCaster) (SubShader: 0) (ShaderType: Fragment) - Total=2/2(100.00%) - Time=0.0504ms
- GBuffer (ScriptableRenderPipeline) (SubShader: 0) (ShaderType: Vertex) - Total=0/4(0.00%) - Time=0.0502ms
- DepthOnly (ScriptableRenderPipeline) (SubShader: 0) (ShaderType: Vertex) - Total=2/2(100.00%) - Time=0.0473ms
- DepthOnly (ScriptableRenderPipeline) (SubShader: 0) (ShaderType: Fragment) - Total=2/2(100.00%) - Time=0.0466ms
- DepthNormals (ScriptableRenderPipeline) (SubShader: 0) (ShaderType: Vertex) - Total=2/2(100.00%) - Time=0.0506ms
- DepthNormals (ScriptableRenderPipeline) (SubShader: 0) (ShaderType: Fragment) - Total=2/2(100.00%) - Time=0.0449ms
- Universal2D (ScriptableRenderPipeline) (SubShader: 0) (ShaderType: Vertex) - Total=0/1(0.00%) - Time=0.0739ms
- MotionVectors (MotionVectors) (SubShader: 0) (ShaderType: Vertex) - Total=2/2(100.00%) - Time=0.0471ms
- MotionVectors (MotionVectors) (SubShader: 0) (ShaderType: Fragment) - Total=2/2(100.00%) - Time=0.0446ms
- XRMotionVectors (ScriptableRenderPipeline) (SubShader: 0) (ShaderType: Vertex) - Total=0/2(0.00%) - Time=0.0373ms

UnityEditor.BuildPlayerWindow:BuildPlayerAndRun ()
```

## その他

- シェーダーの**multi_compileの順序を変えるとバグる**ので不用意に変えない事。(変えたら**C#ドメインリロードで直る**)
  `LocalKeyword`を`cmd.SetKeyword(..)`で`true`に設定して実行し、その後シェーダーでその`LocalKeyword`を含む`multi_compile`の順序を**入れ替える**と、
  正しく`ShaderKeyword`が**設定されなくなる**。その後に**C#をリロード**すると**直る**。
  (恐らく、*C#側*が`multi_compile`を**順序で記憶**していて、*シェーダー側*でその順序を変えると、操作する`multi_compile`の対象が入れ替わってしまう(バグ)と思われる)

- `Shader.globalRenderPipeline`と`SabShader{Tags{"RenderPipeline" = "ココ"}}`の`ココ`が違うと**シェーダー自体**が**ストリップ**されるらしい。(`cmd.rendererList(..)`からも除外される?)

[シェーダーバリアントの数の確認](https://docs.unity3d.com/ja/2023.2/Manual/shader-how-many-variants.html)
[ビルドログから理解するシェーダーストリッピング](https://zenn.dev/r_ngtm/articles/unity-shaderstripping)
[GPTへシェーダーバリアントの質問](https://chatgpt.com/share/68933090-13d8-8013-b161-94ce2100bca9)

## その他コード

DrawShaderKeywordTest
```CSharp
void DrawShaderKeywordTest(CommandBuffer cmd)
{
    if (renderLoopCounter == 0)
    {
        svc_keyword = new LocalKeyword(shaderKeywordTestMaterial.shader, "_SVC");
        vertex_keyword = new LocalKeyword(shaderKeywordTestMaterial.shader, "_VERTEX");
        default_keyword = new LocalKeyword(shaderKeywordTestMaterial_Asset_0.shader, "_DEFAULT");
        asset_0_keyword = new LocalKeyword(shaderKeywordTestMaterial_Asset_0.shader, "_ASSET_0");
        asset_1_keyword = new LocalKeyword(shaderKeywordTestMaterial_Asset_0.shader, "_ASSET_1");
        stereo_keyword_Asset = new LocalKeyword(shaderKeywordTestMaterial_Asset_0.shader, "STEREO_INSTANCING_ON");
        stereo_keyword = new LocalKeyword(shaderKeywordTestMaterial.shader, "STEREO_INSTANCING_ON");
    }
    //GlobalKeywordの設定
    cmd.SetKeyword(global_keyword, asset.global_keyword_enable);
    cmd.SetKeyword(strip_keyword, asset.strip_keyword_enable);
    //LocalKeywordの設定
    cmd.SetKeyword(shaderKeywordTestMaterial, svc_keyword, asset.svc_keyword_enable);
    cmd.SetKeyword(shaderKeywordTestMaterial, vertex_keyword, asset.vertex_keyword_enable);
    cmd.SetKeyword(shaderKeywordTestMaterial_Asset_0, default_keyword, !asset.asset_0_keyword_enable);
    cmd.SetKeyword(shaderKeywordTestMaterial_Asset_0, asset_0_keyword, asset.asset_0_keyword_enable);
    cmd.SetKeyword(shaderKeywordTestMaterial_Asset_1, default_keyword, !asset.asset_1_keyword_enable);
    cmd.SetKeyword(shaderKeywordTestMaterial_Asset_1, asset_1_keyword, asset.asset_1_keyword_enable);
    //STEREO_INSTANCING_ON を false
    cmd.SetKeyword(shaderKeywordTestMaterial_Asset_1, stereo_keyword_Asset, false);
    cmd.SetKeyword(shaderKeywordTestMaterial_Asset_0, stereo_keyword_Asset, false);
    cmd.SetKeyword(shaderKeywordTestMaterial, stereo_keyword, false);

    cmd.SetGlobalVectorArray(atlasRanges_id, new Vector4[]
    {
        new Vector4(0.0f, 0.0f, 0.5f, 0.5f), // 左上
        new Vector4(0.5f, 0.0f, 1.0f, 0.5f), // 右上
        new Vector4(0.0f, 0.5f, 0.5f, 1.0f), // 左下
        new Vector4(0.5f, 0.5f, 1.0f, 1.0f)  // 右下
    });
    cmd.SetGlobalInteger(faceCount_id, asset.faceCount);
    cmd.SetGlobalTexture(face_id, face);
    float posX = 1.0f - (0.25f * asset.faceCount / aspect);
    Matrix4x4 ObjectToWorld = Matrix4x4.TRS(new Vector3(posX, -1.00f, 0.0f), Quaternion.identity, new Vector3(1.0f, 1.0f, 1.0f));
    cmd.DrawMesh(facePlane, ObjectToWorld, shaderKeywordTestMaterial);
    ObjectToWorld = Matrix4x4.TRS(new Vector3(posX, -0.75f, 0.2f), Quaternion.identity, new Vector3(1.0f, 1.0f, 1.0f));
    cmd.DrawMesh(facePlane, ObjectToWorld, shaderKeywordTestMaterial_Asset_1);
    ObjectToWorld = Matrix4x4.TRS(new Vector3(posX, -0.50f, 0.2f), Quaternion.identity, new Vector3(1.0f, 1.0f, 1.0f));
    cmd.DrawMesh(facePlane, ObjectToWorld, shaderKeywordTestMaterial_Asset_0);
}
```
ShaderKeywordTestShader
```c
Shader "Custom/ShaderKeywordTestShader"
{
    SubShader
    {
        Pass
        {
            Name "Name_ShaderKeywordTestShader"

            Blend SrcAlpha OneMinusSrcAlpha

            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #pragma target 5.0
            
            #pragma multi_compile _ _GLOBAL
            #pragma multi_compile_fog //FOG_EXP2 //Lighting/Environment/Fog と Project Settings/Graphics/Fog Modes
            #pragma shader_feature _SVC //Assets\Resources\_SVC.shadervariants を削除するとマッチ失敗する //_feature 1Keyword無し版(`_`) 省略
            #pragma multi_compile_local_vertex _ _VERTEX //_fragmentにすると効くようになる

            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

            int _spritCount;
            float4 _atlasRanges[4];
            TEXTURE2D(_face);
            SAMPLER(sampler_face);

            struct Rect
            {
                float2 min;
                float2 max;
            };

            Rect VectorToRect(float4 vec)
            {
                Rect rect;
                rect.min = float2(vec.x, vec.y);
                rect.max = float2(vec.z, vec.w);
                return rect;
            }

            float Map(float2 destRange, float2 srcRange, float srcValue)
            {
                return (((destRange.y - destRange.x) / (srcRange.y - srcRange.x)) * (srcValue - srcRange.x)) + destRange.x;
            }

            float2 MapToRectUV(Rect rect, float2 uvRange, float2 uv)
            {
                return float2(Map(float2(rect.min.x, rect.max.x), uvRange, uv.x), Map(float2(rect.min.y, rect.max.y), float2(0.0, 1.0), uv.y));
            }

            float2 CalculateAtlasUV(float4 atlasRange, float2 uvRange, float2 uv)
            {
                return MapToRectUV(VectorToRect(atlasRange), uvRange, uv);
            }

            struct Attributes
            {
                float3 positionOS : POSITION;
                float2 uv         : TEXCOORD;
            };

            struct Varyings
            {
                float4 positionCS : SV_POSITION;
                float2 uv         : TEXCOORD0;
            };

            Varyings vert(Attributes input)
            {
                Varyings output = (Varyings)0;
                output.positionCS = float4(TransformObjectToWorld(input.positionOS), 1.0);
                output.uv = input.uv;
                return output;
            }

            float4 frag(Varyings input) : SV_TARGET
            {
                float2 uv;
                uv = input.uv;
                float spritRange = 1.0 / _spritCount;
                for(int i = 0; i < _spritCount; i++)
                {
                    float2 range = float2(i * spritRange, (i + 1) * spritRange);
                    //Generate Mipmap を Off にしたら線が消えた。
                        //(恐らく、Atlasの境界でUV座標が大幅に変わってddx(uv.x)が大きくなりMaxMipLvが参照された(多分、1SubMeshに1Atlasしか貼らない))
                    if (/*input.uv.x >= range.x &&*/ input.uv.x < range.y)
                    {
                        if(i == 0)
                        {
                            #if defined(_GLOBAL)
                                uv = CalculateAtlasUV(_atlasRanges[1], range, input.uv);
                            #else
                                uv = CalculateAtlasUV(_atlasRanges[0], range, input.uv);
                            #endif
                            break;
                        }
                        else if(i == 1)
                        {
                            #if defined(FOG_EXP2)
                                uv = CalculateAtlasUV(_atlasRanges[2], range, input.uv);
                            #else
                                uv = CalculateAtlasUV(_atlasRanges[0], range, input.uv);
                            #endif
                            break;
                        }
                        else if(i == 2)
                        {
                            #if defined(_SVC)
                                uv = CalculateAtlasUV(_atlasRanges[3], range, input.uv);
                            #else
                                uv = CalculateAtlasUV(_atlasRanges[0], range, input.uv);
                            #endif
                            break;
                        }
                        else if(i == 3)
                        {
                            #if defined(_VERTEX) //_vertexサフィックスなのでこれは常にfalse
                                uv = CalculateAtlasUV(_atlasRanges[1], range, input.uv);
                            #else
                                uv = CalculateAtlasUV(_atlasRanges[0], range, input.uv);
                            #endif
                            break;
                        }
                        else
                        {
                            uv = CalculateAtlasUV(_atlasRanges[0], range, input.uv);
                            break;
                        }
                    }
                }

                float4 color = SAMPLE_TEXTURE2D(_face, sampler_face, uv);
                return color; 
            }
            ENDHLSL
        }
    }
}
```
ShaderKeywordTestShader_Asset
```c
Shader "Custom/ShaderKeywordTestShader_Asset"
{
    Properties
    {
        // [Toggle(_SWITCH_0)] _switch_0 ("Switch 0", Float) = 0
        _face ("Face Atlas", 2D) = "white" {}
    }
    SubShader
    {
        Pass
        {
            Name "Name_ShaderKeywordTestShader_Asset"

            Blend SrcAlpha OneMinusSrcAlpha

            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #pragma target 5.0
            
            #pragma multi_compile _ _GLOBAL
            #pragma shader_feature _DEFAULT _ASSET_0 _ASSET_1 //2 * 2 * ⟪1¦2¦3⟫ バリアント を生成
            #pragma multi_compile _ _STRIP //Assets\Editor\ShaderKeywordTestShaderKeywordStripper.cs からストリップされる Keyword

            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

            int _spritCount = 4;
            float4 _atlasRanges[4];
            TEXTURE2D(_face);
            SAMPLER(sampler_face);

            struct Rect
            {
                float2 min;
                float2 max;
            };

            Rect VectorToRect(float4 vec)
            {
                Rect rect;
                rect.min = float2(vec.x, vec.y);
                rect.max = float2(vec.z, vec.w);
                return rect;
            }

            float Map(float2 destRange, float2 srcRange, float srcValue)
            {
                return (((destRange.y - destRange.x) / (srcRange.y - srcRange.x)) * (srcValue - srcRange.x)) + destRange.x;
            }

            float2 MapToRectUV(Rect rect, float2 uvRange, float2 uv)
            {
                return float2(Map(float2(rect.min.x, rect.max.x), uvRange, uv.x), Map(float2(rect.min.y, rect.max.y), float2(0.0, 1.0), uv.y));
            }

            float2 CalculateAtlasUV(float4 atlasRange, float2 uvRange, float2 uv)
            {
                return MapToRectUV(VectorToRect(atlasRange), uvRange, uv);
            }

            struct Attributes
            {
                float3 positionOS : POSITION;
                float2 uv         : TEXCOORD;
            };

            struct Varyings
            {
                float4 positionCS : SV_POSITION;
                float2 uv         : TEXCOORD0;
            };

            Varyings vert(Attributes input)
            {
                Varyings output = (Varyings)0;
                output.positionCS = float4(TransformObjectToWorld(input.positionOS), 1.0);
                output.uv = input.uv;
                return output;
                #define VERTEX
            }

            float4 frag(Varyings input) : SV_TARGET
            {
                float2 uv;
                uv = input.uv;
                //これでもGenerate Mipmap を ON にすると線が出る。//spritIndex と range 計算
                int spritIndex = clamp(int(input.uv.x * _spritCount), 0, _spritCount - 1);
                float spritRange = 1.0 / _spritCount;
                float2 range = float2(spritIndex * spritRange, (spritIndex + 1) * spritRange);
                if(spritIndex == 0)
                {
                    #if defined(_GLOBAL)
                        uv = CalculateAtlasUV(_atlasRanges[1], range, input.uv);
                    #else
                        uv = CalculateAtlasUV(_atlasRanges[0], range, input.uv);
                    #endif
                }
                else if(spritIndex == 1)
                {
                    #if defined(_DEFAULT)
                        uv = CalculateAtlasUV(_atlasRanges[0], range, input.uv);
                    #elif defined(_ASSET_0)
                        uv = CalculateAtlasUV(_atlasRanges[1], range, input.uv);
                    #elif defined(_ASSET_1)
                        uv = CalculateAtlasUV(_atlasRanges[2], range, input.uv);
                    #endif
                }
                else if(spritIndex == 2)
                {
                    #if defined(VERTEX) //これは必ずtrue
                        uv = CalculateAtlasUV(_atlasRanges[3], range, input.uv);
                    #else
                        uv = CalculateAtlasUV(_atlasRanges[0], range, input.uv);
                    #endif
                }
                else if(spritIndex == 3)
                {
                    #if defined(_STRIP)
                        uv = CalculateAtlasUV(_atlasRanges[1], range, input.uv);
                    #else
                        uv = CalculateAtlasUV(_atlasRanges[0], range, input.uv);
                    #endif
                }
                else
                {
                    uv = CalculateAtlasUV(_atlasRanges[0], range, input.uv);
                }
                float4 color = SAMPLE_TEXTURE2D(_face, sampler_face, uv);
                return color;
            }
            ENDHLSL
        }
    }
}
```
全コード
```CSharp
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEditor;
using System.Linq;

[CreateAssetMenu(fileName = "RenderGraphTest_PipelineAsset", menuName = "Rendering/RenderGraph Test PipelineAsset")]
public class CommandBufferTestAsset : RenderPipelineAsset<CommandBufferTestAsset.CommandBufferTestPipeline>
{
    public Texture2D cat;
    public Texture2D beluga;
    public Texture2D face;
    public Shader cmdTest;
    [Range(0.0f, 0.3f)]
    public float moveOffset; // = 0.0f; //恐らくAsset以外はInspectorに出せない
    public Rect viewportRect = new Rect(0.20f, 0.1f, 0.6f, 0.7f);
    public Rect scissorRect = new Rect(0.3f, 0.3f, 0.6f, 0.6f);
    public bool wireframe = true;
    public bool invertCullingFlag = false;
    public Vector2 globalDepthBias = new Vector2(1000.0f, 1.0f);
    public int faceCount = 4;
    public bool global_keyword_enable = true;
    public bool strip_keyword_enable = false;
    public bool svc_keyword_enable = true;
    public bool vertex_keyword_enable = false;
    public bool asset_0_keyword_enable = true;
    public bool asset_1_keyword_enable = true;
    void Reset() => Debug.Log($"Reset()");
    protected override RenderPipeline CreatePipeline() { return new CommandBufferTestPipeline(this); }

    public class CommandBufferTestPipeline : RenderPipeline
    {
        CommandBufferTestAsset asset;
        public Texture2D cat => asset.cat;
        public Texture2D beluga => asset.beluga;
        public Texture2D face => asset.face;
        public CommandBufferTestPipeline(CommandBufferTestAsset asset)
        {
            this.asset = asset;
        }
        Material material;
        Material shaderKeywordTestMaterial;
        Material shaderKeywordTestMaterial_Asset_0;
        Material shaderKeywordTestMaterial_Asset_1;
        Mesh plane;
        Mesh viewportPlane;
        Mesh scissorPlane;
        Mesh facePlane;
        float aspect;
        int aspect_id = Shader.PropertyToID("_aspect");
        int face_id = Shader.PropertyToID("_face"); int faceCount_id = Shader.PropertyToID("_spritCount");
        int atlasRanges_id = Shader.PropertyToID("_atlasRanges");
        int renderLoopCounter = 0;
        static int staticRenderLoopCounter = 0;
        protected override void Render(ScriptableRenderContext ctx, List<Camera> _)
        {
            aspect = (float)Screen.width / Screen.height;
            CommandBuffer cmd = CommandBufferPool.Get("cmd0");

            // if (renderLoopCounter == 0) //Bulid And Run時にMeshがnullになりエラーがでる
            // MeshやMaterialがnullなら毎回初期化 //ビルドで動いたが画面は真っ暗。なぜGameViewと違う？
            // cmd.ClearRenderTarget(..)以外ほぼコメントアウトでも真っ暗(BRTT.CameraTargetじゃない?)
            // 何をしてもOnProcessShader(..)が呼ばれないから、Strict shader variant matching のエラーも出ない。
            if (plane == null || viewportPlane == null || scissorPlane == null || facePlane == null || material == null || shaderKeywordTestMaterial == null || shaderKeywordTestMaterial_Asset_0 == null || shaderKeywordTestMaterial_Asset_1 == null)
            {
                // PlaneMeshの初期化
                plane = CreatePlaneMesh(new Rect(new Vector2(-0.5f, -0.5f), new Vector2(1.0f, 1.0f)));
                viewportPlane = CreatePlaneMesh(ToPlaneRect(asset.viewportRect));
                scissorPlane = CreatePlaneMesh(ToPlaneRect(asset.scissorRect));
                facePlane = CreatePlaneMesh(new Rect(new Vector2(0.0f, 0.0f), ApplyAspect(new Vector2(0.25f * asset.faceCount, 0.25f), aspect)));
                // マテリアルの初期化
                material = new Material(asset.cmdTest);
                shaderKeywordTestMaterial = new Material(Shader.Find("Custom/ShaderKeywordTestShader"));
                shaderKeywordTestMaterial_Asset_0 = Resources.Load<Material>("ShaderKeywordTestMaterial_Asset_0");
                shaderKeywordTestMaterial_Asset_1 = Resources.Load<Material>("ShaderKeywordTestMaterial_Asset_1");
            }
            cmd.SetRenderTarget(BuiltinRenderTextureType.CameraTarget);
            cmd.ClearRenderTarget(RTClearFlags.ColorDepth, Color.brown.linear);

            using (cmd.WithWireframe(asset.wireframe))
            {
                using (cmd.WithKeyword(material, new LocalKeyword(asset.cmdTest, "_VIEWPORT")))
                {
                    cmd.DrawMesh(viewportPlane, Matrix4x4.identity, material);
                }
                using (cmd.WithKeyword(material, new LocalKeyword(asset.cmdTest, "_SCISSOR")))
                {
                    cmd.DrawMesh(scissorPlane, Matrix4x4.identity, material);
                }
            }

            var screenSize = new Vector2(Screen.width, Screen.height);
            using (cmd.WithViewport(new Rect(asset.viewportRect.position * screenSize, asset.viewportRect.size * screenSize)))
            {
                using (cmd.WithScissorRect(new Rect(asset.scissorRect.position * screenSize, asset.scissorRect.size * screenSize)))
                {
                    cmd.SetGlobalFloat(aspect_id, aspect);

                    material.mainTexture = cat;
                    Matrix4x4 move = Matrix4x4.TRS(new Vector3(-0.55f + asset.moveOffset, 0.25f, 0.1f), Quaternion.identity, new Vector3(1.0f, 1.0f, 1.0f));
                    cmd.SetInvertCulling(asset.invertCullingFlag);
                    cmd.DrawMesh(plane, move, material);
                    cmd.SetInvertCulling(false);

                    ctx.ExecuteCommandBuffer(cmd); //⟪Begin¦End⟫Event(cmd0)が自動的に挿入される
                    ctx.Submit();                  //cmd群実行。ローカルプロパティ設定が反映される単位
                    cmd.Clear();

                    material.mainTexture = beluga;
                    move = Matrix4x4.TRS(new Vector3(0.55f - asset.moveOffset, -0.25f, 0.1f), Quaternion.identity, new Vector3(1.0f, 1.0f, 1.0f));
                    cmd.SetGlobalDepthBias(asset.globalDepthBias.x, asset.globalDepthBias.y);
                    cmd.DrawMesh(plane, move, material);
                    cmd.SetGlobalDepthBias(0.0f, 0.0f);
                }
            }

            DrawShaderKeywordTest(cmd);

            ctx.ExecuteCommandBuffer(cmd);
            CommandBufferPool.Release(cmd);
            ctx.Submit();
            if (renderLoopCounter == 0) //ctx.Submit()でmaterial.enabledKeywordsに設定される
            {
                Debug.Log($"staticRenderLoopCounter: {staticRenderLoopCounter} ============================================================");
                staticRenderLoopCounter++;
                // 有効なキーワード (LocalKeyword[]) //C#リロードで更新 または Materialに保存されている
                var enabledKeywords = shaderKeywordTestMaterial.enabledKeywords;
                string enabledStr = string.Join(", ", enabledKeywords.Select(k => k.name));
                Debug.Log($"material.enabledKeywords: {enabledStr}");

                // シェーダーに定義されている全てのキーワード (LocalKeyword[]) //C#リロードで更新
                var shaderKeywords = shaderKeywordTestMaterial.shader.keywordSpace.keywords;
                string allKeywordsStr = string.Join(", ", shaderKeywords.Select(k => k.name));
                Debug.Log($"shader.keywordSpace: {allKeywordsStr}");

                // Shader.enableGlobalKeywords (GlobalKeyword[]) //これのリセットはEditor再起動 (C#リロード貫通) //明示的に設定すれば反映される
                var enabledGlobalKeywords = Shader.enabledGlobalKeywords;
                string enabledGlobalKeywordsStr = string.Join(", ", enabledGlobalKeywords.Select(k => k.name));
                Debug.Log($"Shader.enableGlobalKeywords: {enabledGlobalKeywordsStr}");

                // Shader.globalKeywords (GlobalKeyword[]) //これのリセットはEditor再起動 (C#リロード貫通)
                var globalKeywords = Shader.globalKeywords;
                string globalKeywordsStr = string.Join(", ", globalKeywords.Select(k => k.name));
                Debug.Log($"Shader.globalKeywords: {globalKeywordsStr}");
            }
            renderLoopCounter++;
        }

        GlobalKeyword global_keyword = GlobalKeyword.Create("_GLOBAL");
        GlobalKeyword strip_keyword = GlobalKeyword.Create("_STRIP");
        LocalKeyword stereo_keyword_Asset, stereo_keyword, svc_keyword, vertex_keyword, default_keyword, asset_0_keyword, asset_1_keyword;
        void DrawShaderKeywordTest(CommandBuffer cmd)
        {
            if (renderLoopCounter == 0)
            {
                svc_keyword = new LocalKeyword(shaderKeywordTestMaterial.shader, "_SVC");
                vertex_keyword = new LocalKeyword(shaderKeywordTestMaterial.shader, "_VERTEX");
                default_keyword = new LocalKeyword(shaderKeywordTestMaterial_Asset_0.shader, "_DEFAULT");
                asset_0_keyword = new LocalKeyword(shaderKeywordTestMaterial_Asset_0.shader, "_ASSET_0");
                asset_1_keyword = new LocalKeyword(shaderKeywordTestMaterial_Asset_0.shader, "_ASSET_1");
                stereo_keyword_Asset = new LocalKeyword(shaderKeywordTestMaterial_Asset_0.shader, "STEREO_INSTANCING_ON");
                stereo_keyword = new LocalKeyword(shaderKeywordTestMaterial.shader, "STEREO_INSTANCING_ON");
            }
            //GlobalKeywordの設定
            cmd.SetKeyword(global_keyword, asset.global_keyword_enable);
            cmd.SetKeyword(strip_keyword, asset.strip_keyword_enable);
            //LocalKeywordの設定
            cmd.SetKeyword(shaderKeywordTestMaterial, svc_keyword, asset.svc_keyword_enable);
            cmd.SetKeyword(shaderKeywordTestMaterial, vertex_keyword, asset.vertex_keyword_enable);
            cmd.SetKeyword(shaderKeywordTestMaterial_Asset_0, default_keyword, !asset.asset_0_keyword_enable);
            cmd.SetKeyword(shaderKeywordTestMaterial_Asset_0, asset_0_keyword, asset.asset_0_keyword_enable);
            cmd.SetKeyword(shaderKeywordTestMaterial_Asset_1, default_keyword, !asset.asset_1_keyword_enable);
            cmd.SetKeyword(shaderKeywordTestMaterial_Asset_1, asset_1_keyword, asset.asset_1_keyword_enable);
            //STEREO_INSTANCING_ON を false
            cmd.SetKeyword(shaderKeywordTestMaterial_Asset_1, stereo_keyword_Asset, false);
            cmd.SetKeyword(shaderKeywordTestMaterial_Asset_0, stereo_keyword_Asset, false);
            cmd.SetKeyword(shaderKeywordTestMaterial, stereo_keyword, false);

            cmd.SetGlobalVectorArray(atlasRanges_id, new Vector4[]
            {
                new Vector4(0.0f, 0.0f, 0.5f, 0.5f), // 左上
                new Vector4(0.5f, 0.0f, 1.0f, 0.5f), // 右上
                new Vector4(0.0f, 0.5f, 0.5f, 1.0f), // 左下
                new Vector4(0.5f, 0.5f, 1.0f, 1.0f)  // 右下
            });
            cmd.SetGlobalInteger(faceCount_id, asset.faceCount);
            cmd.SetGlobalTexture(face_id, face);
            float posX = 1.0f - (0.25f * asset.faceCount / aspect);
            Matrix4x4 ObjectToWorld = Matrix4x4.TRS(new Vector3(posX, -1.00f, 0.0f), Quaternion.identity, new Vector3(1.0f, 1.0f, 1.0f));
            cmd.DrawMesh(facePlane, ObjectToWorld, shaderKeywordTestMaterial);
            ObjectToWorld = Matrix4x4.TRS(new Vector3(posX, -0.75f, 0.2f), Quaternion.identity, new Vector3(1.0f, 1.0f, 1.0f));
            cmd.DrawMesh(facePlane, ObjectToWorld, shaderKeywordTestMaterial_Asset_1);
            ObjectToWorld = Matrix4x4.TRS(new Vector3(posX, -0.50f, 0.2f), Quaternion.identity, new Vector3(1.0f, 1.0f, 1.0f));
            cmd.DrawMesh(facePlane, ObjectToWorld, shaderKeywordTestMaterial_Asset_0);
        }
        Vector2 ApplyAspect(Vector2 pos, float aspect)
        {
            if (aspect > 1.0)
            {
                pos.x /= aspect;
            }
            else
            {
                pos.y *= aspect;
            }
            return pos;
        }
        Rect ToPlaneRect(Rect rect)
        {
            Vector2 position = rect.position * 2.0f - Vector2.one; // 左下原点に変換
            Vector2 size = rect.size * 2.0f; // サイズを2倍
            return new Rect(position, size);
        }
        Mesh CreatePlaneMesh(Rect scaleRect)
        {
            Mesh mesh = new Mesh();

            // 頂点属性の定義
            mesh.SetVertexBufferParams(4, new VertexAttributeDescriptor[]
            {
                new VertexAttributeDescriptor(VertexAttribute.Position, VertexAttributeFormat.Float32, 3, 0),
                new VertexAttributeDescriptor(VertexAttribute.TexCoord0, VertexAttributeFormat.Float32, 2, 0)
            });

            // 頂点データ（Position, TexCoord0） スケール適用
            var vertexData = new Vertex[]
            {
                new Vertex { position = new Vector3(scaleRect.xMin, scaleRect.yMin, 0), uv = new Vector2(0, 0) },
                new Vertex { position = new Vector3(scaleRect.xMin, scaleRect.yMax, 0) , uv = new Vector2(0, 1) },
                new Vertex { position = new Vector3(scaleRect.xMax, scaleRect.yMax, 0)  , uv = new Vector2(1, 1) },
                new Vertex { position = new Vector3(scaleRect.xMax, scaleRect.yMin, 0) , uv = new Vector2(1, 0) }
            };
            mesh.SetVertexBufferData(vertexData, 0, 0, vertexData.Length);

            // インデックスデータ
            var indices = new ushort[] { 0, 1, 2, 2, 3, 0 }; //時計回り(CW)
            mesh.SetIndexBufferParams(indices.Length, IndexFormat.UInt16);
            mesh.SetIndexBufferData(indices, 0, 0, indices.Length);

            // サブメッシュ設定
            var subMesh = new SubMeshDescriptor(0, indices.Length, MeshTopology.Triangles);
            mesh.subMeshCount = 1;
            mesh.SetSubMesh(0, subMesh);

            return mesh;
        }
        struct Vertex
        {
            public Vector3 position;
            public Vector2 uv;
        }
    }
}

static class CommandBufferExtensions
{
    // AIコード補完=======================================================
    public class WireframeScope : IDisposable
    {
        CommandBuffer cmd;
        public WireframeScope(CommandBuffer cmd)
        {
            this.cmd = cmd;
            cmd.SetWireframe(true);
        }
        public void Dispose()
        {
            cmd.SetWireframe(false);
        }
    }
    public class NullScope : IDisposable
    {
        public void Dispose(){ }
    }
    public static IDisposable WithWireframe(this CommandBuffer cmd, bool enable = true)
    {
        if(enable)
            return new WireframeScope(cmd);
        else
            return new NullScope();
    }
    // ==================================================================

    // AI自動コード生成(SetKeywordとEnableScissorRect版も作ってください)====
    public class KeywordScope : IDisposable
    {
        CommandBuffer cmd;
        Material material;
        LocalKeyword keyword;
        public KeywordScope(CommandBuffer cmd, Material material, LocalKeyword keyword)
        {
            this.cmd = cmd;
            this.material = material;
            this.keyword = keyword;
            cmd.SetKeyword(material, keyword, true);
        }
        public void Dispose()
        {
            cmd.SetKeyword(material, keyword, false);
        }
    }
    public static KeywordScope WithKeyword(this CommandBuffer cmd, Material material, LocalKeyword keyword)
    {
        return new KeywordScope(cmd, material, keyword);
    }

    public class ScissorScope : IDisposable
    {
        CommandBuffer cmd;
        public ScissorScope(CommandBuffer cmd, Rect rect)
        {
            this.cmd = cmd;
            cmd.EnableScissorRect(rect);
        }
        public void Dispose()
        {
            cmd.DisableScissorRect();
        }
    }
    public static ScissorScope WithScissorRect(this CommandBuffer cmd, Rect rect)
    {
        return new ScissorScope(cmd, rect);
    }

    public class ViewportScope : IDisposable
    {
        CommandBuffer cmd;
        Rect prevViewport;
        public ViewportScope(CommandBuffer cmd, Rect rect)
        {
            this.cmd = cmd;
            cmd.SetViewport(rect);
        }
        public void Dispose()
        {
            cmd.SetViewport(new Rect(0, 0, Screen.width, Screen.height));
        }
    }
    public static ViewportScope WithViewport(this CommandBuffer cmd, Rect rect)
    {
        return new ViewportScope(cmd, rect);
    }
    // ================================================================
}
```
