# RenderGraph

- RenderGraphは、RenderGraph内で扱う`～Handle`を準備し、
  `.Add～Pass(..)`で**RenderPass**を生成し、その`builder`で`～Handle`入出力と`SetRenderFunc(..)`で実行する`cmd`を記述し、
  `BeginRecording(.)`から`EndRecordingAndExecute()`で生成された**RenderPassのグラフ**を**コンパイル**することでパスカリングなどを行い、
  上記を`camera`の`renderer`毎に実行し、最後に`EndFrame()`を呼び、
  最終的に最初に`RenderGraph`にセットした`cmd`に必要な全ての**RenderPass**のみを記述され、最後にその`cmd`を`ctx.Submit(cmd)`する。
  (drawioで表現する)
- リソースは、最初Writeで確保、最後Readで解放
- NRPは、パスカル後にNRP条件から外れるまで複数のSubPassを1つのNRPに含め続ける(RasterPassのみパスマージされる)
- Computeととの同期ポイントも作られる
- `～Handle`は`RenderGraph`内のみ使用可能

- `＠⟪Create¦Import¦Use⟫⟪Texture¦Buffer¦RendererList⟫＠⟪Desc¦Handle⟫`
  - `Set⟪Input¦Render⟫Attachment＠❰Depth❱`
- `＠❰Add❱⟪Raster＠❰Render❱¦Compute¦Unsafe⟫⟪Pass¦GraphContext⟫`

- 謎: `void AllowGlobalStateModification(bool value)`、`void EnableAsyncCompute(bool value)`、`TextureUVOrigin`、`bool disableFallBackToImportedTexture`

- まずは極力中身を見ない

- RenderGraph
  - ライフサイクル
    - **.ctor**`(string name = "RenderGraph")`
    - `void` **BeginRecording**`(RenderGraphParameters parameters)`: >`RenderGraph`の**記録を開始**します。
      - `struct RenderGraphParameters parameters`:
        - `CommandBuffer` **cmd**, `ScriptableRenderContext` **ctx**
        - `int currentFrameIndex`: **Time.frameCount**を設定する
        - `bool generateDebugData`: `true`にして↓を設定すると*Render Graph Viewer*が表示される
        - `EntityId executionId`: `cameras[i].GetEntityId()`を設定する
        - `bool rendererListCulling`: >`RendererList`のカリングを有効にするかどうかを制御します。？ `CullingResults`の時点でカリングされているが?->RendererList が空 → Pass 自体を消す
        - `enum RenderTextureUVOriginStrategy renderTextureUVOriginStrategy`: >`renderGraph`がグラフ内の`Unknown TextureUVOrigin のRT`の**UV原点の位置**の戦略
          - `BottomLeft`: >RenderTextures は常に左下方向として扱われます。
          - `PropagateAttachmentOrientation`: >RenderTextures はアタッチメント読み取り経由でのみ使用される場合、バックバッファアタッチメントの方向を継承することがあります。
    - `I⟪Raster¦Compute¦Unsafe⟫RenderGraph`**Builder** `Add`**⟪RasterRender¦Compute¦Unsafe⟫Pass**`<PassData>(string passName, out PassData passData ＠❰, ProfilingSampler sampler❱)`
    - `void` **EndRecordingAndExecute**`()`: >**記録を終了**し、**レンダリンググラフを実行**します。
    - `void` **EndFrame**`()`: >最後のフレーム以降に使用されたリソースを消去し、内部状態をリセットします。
    - `bool ResetGraphAndLogException(Exception e)`: >グラフの記録または実行中に発生する可能性のある例外をキャッチして記録します
    - `void` **Cleanup**`()`: >`renderGraph`が内部で使用している**全てのリソースを解放**します。
  - **リソース準備**
    - **Create系**
      - TextureHandle
        - `TextureHandle` **CreateTexture**`(⟪ TextureDesc desc¦ TextureHandle texture ＠❰, string name, bool clear = false❱⟫)`
        - `void CreateTextureIfInvalid(TextureDesc desc, ref TextureHandle texture)`:
          `texture`が無効(`.IsValid()`)の時、新たに`texture`に`desc`を素に`TextureHandle`を作成する
      - BufferHandle: `BufferHandle` **CreateBuffer**`(⟪BufferDesc desc¦BufferHandle graphicsBuffer⟫)`
      - RendererListHandle
        - `RendererListHandle` **CreateRendererList**`(⟪RendererListParams¦RendererListDesc⟫ desc)`
          - `RendererListHandle Create`Shadow``    RendererList(ShadowDrawingSettings shadowDrawingSettings)`
          - `RendererListHandle Create`Skybox``    RendererList(Camera camera ＠❰＠❰, Matrix4x4 projMatrixL, Matrix4x4 viewMatrixL❱, Matrix4x4 projMatrixR, Matrix4x4 viewMatrixR❱)`
          - `RendererListHandle Create`Gizmo``     RendererList(Camera camera, GizmoSubset gizmoSubset)`
          - `RendererListHandle Create`UIOverlay`` RendererList(Camera camera, UISubset uiSubset)`
          - `RendererListHandle Create`WireOverlay`RendererList(Camera camera)`
    - **Import系**
      - TextureHandle
        - `TextureHandle` **ImportBackbuffer**`(RenderTargetIdentifier rt ＠❰, RenderTargetInfo info, ImportResourceParams importParams = default❱)`
          - `struct RenderTargetInfo info`: ＠❰`RTHandle rt`の中身が❱`RTI`だと不透明なため、`RenderGraph`に必要な**最小限の情報セット**を提供する
            - `GraphicsFormat format`
            - `int msaaSamples`,`bool bindMS`
            - `○⟦, ┃int ⟪width¦height⟫⟧`
            - `int volumeDepth`
          - `enum ImportResourceParams importParams`: >`Import`されたテクスチャの動作を記述するヘルパー構造体。
            - `bool clearOnFirstUse`,`Color clearColor`: `clearOnFirstUse=true`の時、グラフの初めて使用されるとき`Import`された**テクスチャをクリア**(`clearColor`)します。
            - `bool discardOnLastUse`: >`true`:グラフの**最後に使用**された時点で**破棄**(`rt.Release()`?)する。*MSAA*の場合はMSAAテクスチャのみが破棄される
              >5.2:最後に使った後に「内容破棄してよい」ヒント
            - `enum TextureUVOrigin textureUVOrigin`: >`Import`されたテクスチャで使用される**UV方向**(アクティブなグラフィックAPIとは独立)。(混ざることある?)
              - `BottomLeft`: OpenGL
              - `TopLeft`: Vulkan, DirectX, Metal,...
        - `TextureHandle` **ImportTexture**   `(RTHandle rt           ＠❰｡＠❰, RenderTargetInfo info❱, ImportResourceParams importParams = default｡❱)`
      - BufferHandle: `BufferHandle` **ImportBuffer**`(GraphicsBuffer graphicsBuffer)`
      - その他
        - `RayTracingAccelerationStructureHandle ImportRayTracingAccelerationStructure(RayTracingAccelerationStructure accelStruct, string name = null)`
        - `TextureHandle ImportShadingRateImageTexture(RTHandle rt)`
  - **Builder**
    ⟪`IRaster`,`IUnsafe`⟫->`IRenderAttachment`->`IBase` ,  `ICompute`->`IBase`
    - **Passの入出力**
      - `enum`**AccessFlags**: [リスト(-)が長いと開けない?](images\AccessFlags.png)
        - `None`: >このパスはリソースに一切アクセスしません。**Use系**を`None`で呼んでも効果はありません。
        - `Read`: >このパスはリソースのデータを読み取ります。書き込みフラグが無い場合、リソースへの書き込みはしてはいけません。
        - `Write`: >このパスはリソースへ少なくとも一部を書き込みます。書き込み専用の場合、読み取りはしてはいけません。
        - `Discard`: >リソース内の以前のデータは保持されません。パス開始時、リソースには未定義のデータが入っている状態になります。
          初期化されて無いリソースに書き込むことを表している? >いつ使うか： そのパスの開始時に、リソースの中身がゴミ（未定義データ）であっても構わない時。
        - `WriteAll`=`Write|Discard`: >このパスがリソースの全データを書き込みます。そのため、リソースの既存データは読み取るべきではありません。
          これ以前に書き込まれて一度も読まれて無かったらそのパスはカリングされる?
        - `ReadWrite`=`Read|Write`: >`Read|Write`のショートカットです。
      - **Use系**
        - `IBase`
          - TextureHandle:        `void` **UseTexture**     `(TextureHandle input, AccessFlags flags = AccessFlags.Read)`
          - BufferHandle: `BufferHandle` **UseBuffer**      `(BufferHandle  input, AccessFlags flags = AccessFlags.Read)`
            >戻り値:'input'に渡された値。返された値は将来削除されるため、使用しないでください。?
          - RendererListHandle:   `void` **UseRendererList**`(RendererListHandle input)`: Readのみ
        - `IRenderAttachment`, `cmd.SetRandomWriteTarget(..)`と対応してるぽい。戻り値は謎
          - `TextureHandle SetRandomAccessAttachment(TextureHandle tex, int index,                                 AccessFlags flags = AccessFlags.ReadWrite)`
          - `BufferHandle  UseBufferRandomAccess    (BufferHandle tex,  int index ＠❰, bool preserveCounterValue ❱, AccessFlags flags = AccessFlags.Read)`
      - **Attachment系** (`SetRenderTarget(..)`,*NRP*)
        - `IRenderAttachment`
          - `void` **SetRenderAttachment**     `(TextureHandle tex, int index, AccessFlags flags = AccessFlags.Write     ＠❰, int mipLevel, int depthSlice ❱)`:
            >ブレンディングなど読み取る場合は`AccessFlags.ReadWrite`にする必要がある。フルスクリーンパスなどで完全に上書きする場合`AccessFlags.WriteAll`にするとパフォーマンスが良くなる
            - `int index`: MRTスロット(`SV_Target++index`), `int depthSlice`: >`-1`は全てのスライスをバインド(Layered Rendering?)
          - `void` **SetRenderAttachment**Depth`(TextureHandle tex,            AccessFlags flags = AccessFlags.ReadWrite ＠❰, int mipLevel, int depthSlice ❱)`
            >`Write`:`ZWrite On`, `Read`:`Ztest`が`Disabled`,`Never`,`Always`以外のとき。デプスバッファにMipMapは作れないはずだが?..
        - `IRaster`
          - `void` **Set**`Input`**Attachment**`(TextureHandle tex, int index, AccessFlags flags = AccessFlags.Read      ＠❰, int mipLevel, int depthSlice ❱)`
            - `int index`: `LOAD_FRAMEBUFFER_INPUT(index)`
      - CreateTransient系:`IBase`: この**Pass内でのみ使用可能**(Read/Write)
        - TextureHandle: `TextureHandle CreateTransientTexture(⟪TextureDesc desc¦TextureHandle texture⟫)`
        - BufferHandle:   `BufferHandle CreateTransientBuffer (⟪BufferDesc  desc¦BufferHandle  buffer⟫)`
      - **GlobalTexture系**:`IBase`
        - `void AllowGlobalStateModification(bool value)`:`SetGlobalTexture～()`するにはこれを呼ぶ必要があるが、同期ポイントが導入されるらしい。(これいる?)
          `cmd.SetGlobal～`のみだけでもパスカリングされない用?
          - 「このパスはグローバル状態を変更するかもしれない（変更を許可する）」
          - その代償として RenderGraph 側は 同期点（sync-point）を入れる
          - このパス以降のパスは、このパスより前にリオーダーしない（最適化が効きにくくなる）
          - さらに パスカリング（AllowPassCulling）が無効化される（副作用がある可能性があるため間引けない）
        - `void` **SetGlobalTextureAfterPass**`(in TextureHandle input, int propertyId)`: Passの直後に`cmd.SetGlobalTexture(..)`すると思われる
        - `void` **UseGlobalTexture**`(int propertyId, AccessFlags flags = AccessFlags.Read)`
        - `void UseAllGlobalTextures(bool enable)`: `SetGlobalTextureAfterPass(..)`された全ての`propertyId`を使用する?(`AccessFlags.Read`?)
    - **Passの実行**
      - SetRenderFunc:`IRaster`,`ICompute`,`IUnsafe`
        - `void` **SetRenderFunc**`<PassData>(BaseRenderFunc<PassData,`**⟪Raster¦Compute¦Unsafe⟫GraphContext**`> renderFunc) where PassData : class, new()`
          - `⟪struct Raster¦class ⟪Compute¦Unsafe⟫⟫`*GraphContext*
            - `⟪Raster¦Compute¦Unsafe⟫CommandBuffer` **cmd**
            - `RenderGraphObjectPool` *renderGraphPool* `{get;}`: アロケート回避用プール
              - `T[] GetTempArray<T>(int size)`: 任意型の配列を取得
              - `MaterialPropertyBlock GetTempMaterialPropertyBlock()`: 初期化済みの*MPB*を返す
            - `RenderGraphDefaultResources defaultResources {get;}`: デフォルトリソース
              - `TextureHandle ⟪black¦clear¦magenta¦white¦defaultShadow⟫＠❰UInt❱Texture＠❰＠⟪3D¦Array⟫XR❱`
            - `TextureUVOrigin GetTextureUVOrigin(TextureHandle textureHandle)`: >RenderGraphテクスチャの*TextureUVOrigin*を`textureHandle`から取得します。
      - IBase
        - `void` **AllowPassCulling**`(bool value)`: `false`:**パスカリング**を**キャンセル**できる
        - `void` EnableAsyncCompute`(bool value)`: >`true`:このパスの**非同期**Computeを有効にします。(これが無いと同期的になる?)
        - `void EnableFoveatedRasterization(bool value)`: >`true`:このパスの**中心窩レンダリング**を有効にします。
      - `IRaster`
        - ShadingRate (`cmd`に対応する項目がある)
          - `void SetShadingRateCombiner(ShadingRateCombinerStage stage, ShadingRateCombiner combiner)`: >シェーディングレートコンバイナーを設定します。(各*ShadingRate*の比較)
          - `void SetShadingRateFragmentSize(ShadingRateFragmentSize shadingRateFragmentSize)`: >シェーディングレートのフラグメントサイズを設定します。(画面全体)
          - `void SetShadingRateImageAttachment(in TextureHandle tex)`: >現在のラスタライズパスで Variable Rate Shading（VRS）を有効化します。(テクスチャで指定)
        - `void SetExtendedFeatureFlags(ExtendedFeatureFlags extendedFeatureFlags)`: **＠❰Meta❱ XR**関係の**最適化**設定。(>プラットフォーム固有の最適化)
          - `enum ExtendedFeatureFlags extendedFeatureFlags`
            - `MultisampledShaderResolve`: >**Meta XR**上で、このフラグを設定すると、レンダーパスの最後のサブパスでMSAA のシェーダーリゾルブを使用できます。
            - `MultiviewRenderRegionsCompatible`: >**XR**で、Multiview Render Regions に対応したパスに設定できるフラグです。
            - `None`: >拡張機能が何も有効になっていないデフォルト状態。
            - `TileProperties`: >**Meta XR**上で、最も多くの 3D レンダリングを行うパスに設定することで、より高いパフォーマンスを得られる可能性があります。
    - その他:`IBase`
      - `void GenerateDebugData(bool value)`: >`％?true`:*Render Graph Viewer*のためのパスのデバッグデータを生成します。
  - **リソース**
    - **TextureHandle**
      - `TextureDesc` **GetTextureDesc**`(TextureHandle texture)`
      - `RenderTargetInfo GetRenderTargetInfo(TextureHandle texture)`: `RTI`が不透明なため、`RenderGraph`に必要な**最小限の情報セット**を提供する
      - `struct` **TextureHandle**: `renderGraph`によって**有効期間や使用方法など**を管理され、`renderGraph`外でアクセスしてはいけない。[概要](images\TextureHandle概要.png)
        - `static TextureHandle nullHandle {get;}`
        - `bool IsValid()`
        - `TextureDesc GetDescriptor(RenderGraph renderGraph)`: `renderGraph.GetTextureDesc(TextureHandle texture)`を呼ぶだけ。(本体は`renderGraph`にあるらしい)
        - `static implicit operator ⟪RTI¦RenderTexture¦RTHandle¦Texture⟫(TextureHandle texture)`: `SetRenderFunc(..)`内で**各型に変換**される
      - `struct` **TextureDesc**: `TextureHandle`を作成するために使用される説明
        - コンストラクタ
          - `TextureDesc(⟪○⟦, ┃int ⟪width¦height⟫⟧¦Vector2 scale¦ScaleFunc func⟫, bool dynamicResolution = false, bool xrReady = false)`
          - `TextureDesc(⟪RenderTexture＠❰Descriptor❱¦TextureDesc⟫ input)`
        - 名前:`string name`
        - RTDesc
          - ResourceDesc
            - `TextureDimension dimension`
            - `GraphicsFormat format`
            - `MSAASamples msaaSamples`,`bool bindTextureMS`
            - `enum TextureSizeMode sizeMode`: >テクスチャのサイズを決定するモード。
              - `Explicit`: `○⟦, ┃int ⟪width¦height⟫⟧`
              - `Functor`: `ScaleFunc func`
              - `Scale`: `Vector2 scale`
            - `bool useMipMap`,`bool autoGenerateMips`
            - `int slices`: >テクスチャ スライスの数。(`volumeDepth`?)
          - `bool isShadowMap`
          - `bool enableRandomWrite`
          - `bool useDynamicScale`,`bool useDynamicScaleExplicit`
          - `VRTextureUsage vrUsage`
          - `RenderTextureMemoryless memoryless`
        - TextureSampler
          - `FilterMode filterMode`
          - `int anisoLevel`
          - `TextureWrapMode wrapMode`
          - `float mipMapBias`
        - RTHandle
          - `bool enableShadingRate`: >テクスチャをシェーディング レート イメージとして使用する場合は true に設定します。(`○⟦, ┃int ⟪width¦height⟫⟧`はタイル単位になります)
        - TextureHandle
          - クリア
            - `bool clearBuffer`,`Color clearColor`: 初めて使用するときにテクスチャをクリアする必要があります。
          - `bool disableFallBackToImportedTexture`: >テクスチャに書き込まれるすべてのパスがダイナミックレンダーパスカリングによってカリングされた場合、自動的に類似の事前割り当てテクスチャにフォールバックされます。割り当てを強制するには、これをtrueに設定します。
            - あるテクスチャ T を“生成するはず”だったけど、生成パスが全部不要判定で消えた
            - それでも後段が T を参照する（または外に出す）都合がある
            - そのとき RenderGraph が **「じゃあ同等っぽい既存（imported/preallocated）に差し替えて辻褄を合わせる」**ことがある
          - `bool fallBackToBlackTexture`: >テクスチャに書き込まずに読み取った場合に、テクスチャを黒のテクスチャにフォールバックするかどうかを決定します。
          - `FastMemoryDesc fastMemoryDesc`: >テクスチャがそれをサポートするプラットフォーム上の高速メモリにどのように配置されるかを決定する記述子。
          - `bool discardBuffer`: >最後に使用したときにテクスチャを破棄する必要があります。
    - **BufferHandle**
      - `BufferDesc GetBufferDesc(BufferHandle graphicsBuffer)`
      - `struct` **BufferHandle**:
        - `static BufferHandle nullHandle {get;}`
        - `bool IsValid()`
        - `static implicit operator GraphicsBuffer(BufferHandle buffer)`: `SetRenderFunc(..)`内で**変換**される
      - `struct` **BufferDesc**: `BufferHandle`を作成するために使用される説明
        - コンストラクタ
          - `BufferDesc(int count, int stride ＠❰, GraphicsBuffer.Target target❱)`
        - フィールド
          - `string name`
          - `GraphicsBuffer.Target target`
          - `int count`
          - `int stride`
          - `GraphicsBuffer.UsageFlags usageFlags`
    - **RendererListHandle**
      - `struct` **RendererListHandle**
        - `bool IsValid()`
        - `static implicit operator ⟪RendererList¦int⟫(RendererListHandle rendererList)`: `SetRenderFunc(..)`内で**各型に変換**される
  - **CommandBuffer**
    - **無いもの**: `Blit`、`ResolveAntiAliasedSurface`、NativeRenderPass系、Fence系、`CopyBuffer`、`⟪Get¦Release⟫TemporaryRT`、FastMemory
    - **IBase**==================================================================================
      - **カリング**:`SetInvertCulling`、**ビューポート**:`SetViewport`、**シザー**:`⟪Enable¦Disable⟫ScissorRect`、シャドー`SetShadowSamplingMode`
      - *基本ShaderProperty_Set*:`SetGlobal`⟪`Texture(.,`**TextureHandle**`,.)`¦`⟪⟪Float¦Vector¦Matrix⟫＠❰Array❱¦Color¦Integer¦＠❰Constant❱Buffer⟫`⟫と`SetGlobalDepthBias`
        - VP_Matrix,クリッププレーン:`SetupCameraProperties`,`SetViewProjectionMatrices`
      - **ShaderKeyword系**:`SetKeyword`
      - その他
        - IssuePlugin系:`IssuePluginEvent＠❰AndData❱`,`IssuePluginCustomBlit`,`IssuePluginCustomTextureUpdateV2`
        - LateLatch系:`MarkLateLatchMatrixShaderPropertyID`,`UnmarkLateLatchMatrix`,`SetLateLatchProjectionMatrices`
        - CommandBuffer系:`⟪Begin¦End⟫Sample`
        - その他:`IncrementUpdateCount`,`InvokeOnRenderObjectCallbacks`,`SetSinglePassStereo`
    - **IRaster** : `IBase`======================================================================
      - **DrawCall系**:`DrawRenderer＠❰List❱`,`DrawMesh＠❰Instanced＠❰⟪Indirect¦Procedural⟫❱❱`,`DrawProcedural＠❰Indirect❱`,`DrawOcclusionMesh`,`DrawMultipleMeshes`
        - **Clear系**:`ClearRenderTarget`
      - ワイヤーフレーム:`SetWireframe`
      - XR関係:`SetInstanceMultiplier`
        - FoveatedRendering系:`SetFoveatedRenderingMode`,`ConfigureFoveatedRendering`
          - シェーディングレート:`SetShadingRateCombiner`,`SetShadingRateFragmentSize`
    - **ICompute** : `IBase`=====================================================================
      - **Dispatch＠❰Rays❱系**:`Dispatch⟪Compute¦Rays⟫`,`SetRayTracingShaderPass`
      - *基本ShaderProperty_Set*:`Set⟪Compute¦RayTracing⟫`⟪`TextureParam(..,`**TextureHandle**`,..)`¦`⟪⟪Float¦Int⟫Param＠❰s❱¦⟪｡⟪Vector¦Matrix⟫＠❰Array❱¦＠❰Constant❱Buffer｡⟫Param⟫`⟫
        - `SetComputeParamsFromMaterial`,`SetRayTracingAccelerationStructure`
      - ResourceModified系:`SetBufferData`,`⟪SetBuffer¦Copy⟫CounterValue`,`BuildRayTracingAccelerationStructure`
    - **IUnsafe** : `IBase`, `IRaster`, `ICompute`===============================================
      - **RenderTarget系**:`SetRenderTarget`,`SetRandomWriteTarget`
      - **Copy系**:`CopyTexture`
      - *基本ShaderProperty_Set*:`SetGlobalTexture(.,`**RTI**`,.)`,`Set⟪Compute¦RayTracing⟫TextureParam(..,`**RTI**`,..)`
      - MipMap生成:`GenerateMips`
      - **AsyncReadback系**:`RequestAsyncReadback＠❰IntoNativeArray❱`
      - Clear:`Clear`,`ClearRandomWriteTargets`
  - 情報系
    - `string name {get;}`: `renderGraph`の名前
    - `bool nativeRenderPassesEnabled {get; set;}`: >`AddRasterRenderPass()`の従来の`SetRenderTarget(..)`の代わりに、**NRPの使用を有効**にします(6000.3以降デフォルトで有効)。
    - `enum RenderTextureUVOriginStrategy renderTextureUVOriginStrategy {get;}`: `BeginRecording(RenderGraphParameters parameters)`で設定した内容と思われる
    - `static bool isRenderGraphViewerActive {get;}`: >`true`の場合、Render Graph Viewerはアクティブです。
    - `static List<RenderGraph> GetRegisteredRenderGraphs()`: >登録されている全ての`RenderGraph`の`List`を取得します。
  - ユーティリティー
    - `class RenderGraphDefaultResources defaultResources {get;}`: >Pass中にデフォルトのリソースにアクセスできるようにするヘルパークラス。
      - `TextureHandle ⟪black¦clear¦magenta¦white¦defaultShadow⟫＠❰UInt❱Texture＠❰＠⟪3D¦Array⟫XR❱`
    - `void ＠❰Un❱RegisterDebug(DebugUI.Panel panel = null)`: >`RenderGraph`をデバッグウィンドウに⟪登録¦解除⟫します。
